<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«‹æ–¹å·®å…¬å¼ 3D å¯è§†åŒ–æ¼”ç¤º (aÂ³ - bÂ³)</title>
    <style>
        /* å…¨å±€æ ·å¼ - ä¸“æ³¨äºPCç«¯å±•ç¤º */
        body {
            margin: 0;
            padding: 0;
            font-family: "Noto Sans SC", "Microsoft YaHei", sans-serif;
            background-color: #f0f2f5;
            overflow-y: auto; /* å…è®¸å‚ç›´æ»šåŠ¨ */
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* ä¸»å®¹å™¨ï¼šåŒ…å«æ§åˆ¶é¢æ¿å’Œç”»å¸ƒ */
        #main-container {
            display: flex;
            flex-direction: row;
            width: 95%;
            max-width: 1600px;
            height: 90vh; /* ç•™å‡ºé¡µçœ‰é¡µè„šç©ºé—´ */
            margin-top: 20px;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        #control-panel {
            width: 320px;
            min-width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            padding: 24px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* å³ä¾§ 3D ç”»å¸ƒå®¹å™¨ */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: #ffffff;
            overflow: hidden;
        }

        /* æ ‡é¢˜å’Œæ•°å­¦å…¬å¼æ ·å¼ */
        h1 {
            font-size: 20px;
            color: #333;
            margin-bottom: 10px;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 8px;
        }

        .math-display {
            font-family: "Times New Roman", serif;
            font-size: 1.4rem;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            margin-bottom: 20px;
            text-align: center;
            color: #333;
            line-height: 1.6;
        }

        .math-term {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
        }
        
        /* é¢œè‰²å¯¹åº” */
        .color-a2 { color: #2563eb; background: #dbeafe; } /* è“è‰² */
        .color-ab { color: #d97706; background: #fef3c7; } /* æ©™è‰² */
        .color-b2 { color: #059669; background: #d1fae5; } /* ç»¿è‰² */
        .color-cut { color: #dc2626; background: #fee2e2; } /* çº¢è‰² */

        /* æ§ä»¶æ ·å¼ */
        .control-group {
            margin-bottom: 24px;
            background: #fff;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        button.active {
            background: #1e40af;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            border-left: 4px solid #93c5fd;
        }

        /* è¯´æ˜æ–‡å­— */
        .description {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            margin-top: auto;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        /* 3D åœºæ™¯ä¸­çš„æµ®åŠ¨æ ‡ç­¾ */
        #overlay-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            pointer-events: none;
            max-width: 250px;
        }
        
        .overlay-item {
            font-size: 13px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
        }

    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="main-container">
        <!-- å·¦ä¾§æ§åˆ¶åŒº -->
        <div id="control-panel">
            <h1>ç«‹æ–¹å·®å…¬å¼æ¼”ç¤º</h1>
            
            <div class="math-display">
                aÂ³ - bÂ³ = (a-b)(<span class="math-term color-a2">aÂ²</span> + <span class="math-term color-ab">ab</span> + <span class="math-term color-b2">bÂ²</span>)
            </div>

            <div class="control-group">
                <label>è°ƒæ•´ b çš„å¤§å° (ç›¸å¯¹äº a)</label>
                <input type="range" id="slider-b" min="0.1" max="0.9" step="0.01" value="0.5">
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px; color: #888;">
                    <span>å° (0.1a)</span>
                    <span id="val-b">0.5a</span>
                    <span>å¤§ (0.9a)</span>
                </div>
            </div>

            <div class="control-group">
                <label>æ¼”ç¤ºæ­¥éª¤</label>
                <div class="btn-group">
                    <button id="btn-state-0" class="active" onclick="setAppState(0)">
                        <span>1. æ•´ä½“ä¸éƒ¨åˆ†</span>
                        <span>ğŸ“¦</span>
                    </button>
                    <button id="btn-state-1" onclick="setAppState(1)">
                        <span>2. ç§»é™¤ bÂ³</span>
                        <span>âœ‚ï¸</span>
                    </button>
                    <button id="btn-state-2" onclick="setAppState(2)">
                        <span>3. å‡ ä½•åˆ†å‰²</span>
                        <span>ğŸ§©</span>
                    </button>
                    <button id="btn-state-3" onclick="setAppState(3)">
                        <span>4. æ‹¼æ¥æˆé•¿æ–¹ä½“</span>
                        <span>ğŸ“</span>
                    </button>
                </div>
            </div>

            <div class="control-group">
                <label>æ˜¾ç¤ºé€‰é¡¹</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="checkbox" id="chk-edges" checked onchange="updateVisibility()">
                    <span style="font-size: 14px;">æ˜¾ç¤ºè¾¹æ¡†</span>
                </div>
                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                    <input type="checkbox" id="chk-anim" checked>
                    <span style="font-size: 14px;">å¯ç”¨è¿‡æ¸¡åŠ¨ç”»</span>
                </div>
            </div>

            <div class="description">
                <strong>å›¾è§£åŸç†ï¼š</strong><br>
                ä»è¾¹é•¿ä¸º a çš„å¤§æ­£æ–¹ä½“ä¸­æŒ–å»è¾¹é•¿ä¸º b çš„å°æ­£æ–¹ä½“ã€‚å‰©ä½™éƒ¨åˆ†ä½“ç§¯ä¸º aÂ³ - bÂ³ã€‚<br><br>
                æˆ‘ä»¬å°†å‰©ä½™éƒ¨åˆ†åˆ‡å‰²ä¸ºä¸‰å—ï¼Œå®ƒä»¬éƒ½æœ‰ç›¸åŒçš„é«˜åº¦ (a-b)ã€‚æ‹¼æ¥ååº•é¢ç§¯ä¹‹å’Œä¸º (aÂ² + ab + bÂ²)ã€‚
            </div>
        </div>

        <!-- å³ä¾§ç”»å¸ƒåŒº -->
        <div id="canvas-container">
            <div id="overlay-ui">
                <div class="overlay-item"><span class="color-dot" style="background:#3b82f6"></span> åº•åº§: a Ã— a Ã— (a-b)</div>
                <div class="overlay-item"><span class="color-dot" style="background:#f59e0b"></span> ä¾§ç¿¼: b Ã— a Ã— (a-b)</div>
                <div class="overlay-item"><span class="color-dot" style="background:#10b981"></span> å‰è§’: b Ã— b Ã— (a-b)</div>
                <div class="overlay-item" id="info-cut" style="display:none; color:#dc2626; border-top:1px solid #ddd; margin-top:4px; padding-top:4px;">
                    <span class="color-dot" style="background:#ef4444"></span> å·²ç§»é™¤: bÂ³
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. å…¨å±€å˜é‡ ---
        let scene, camera, renderer, controls;
        let blocks = {}; // å­˜å‚¨æ‰€æœ‰å‡ ä½•ä½“ç½‘æ ¼
        let edges = {};  // å­˜å‚¨è¾¹æ¡†çº¿
        
        // å‚æ•°é…ç½®
        const config = {
            a: 40,       // å¤§æ­£æ–¹ä½“è¾¹é•¿ (å•ä½)
            bRatio: 0.5, // b/a æ¯”ä¾‹
            gap: 2,      // åˆ†å‰²æ—¶çš„é—´éš™
            animSpeed: 0.1, // åŠ¨ç”»æ’å€¼é€Ÿåº¦
            currentState: 0 // 0: å®Œæ•´, 1: æŒ–å», 2: åˆ†å‰², 3: æ‹¼æ¥
        };

        // ç›®æ ‡ä½ç½®/æ—‹è½¬å­˜å‚¨ (ç”¨äºåŠ¨ç”»)
        const targets = {
            pos: {},
            rot: {}
        };

        // é¢œè‰²å®šä¹‰
        const COLORS = {
            block1: 0x3b82f6, // è“è‰² (å¤§åº•åº§) a^2
            block2: 0xf59e0b, // æ©™è‰² (é•¿æ¡) ab
            block3: 0x10b981, // ç»¿è‰² (å°å—) b^2
            cubeB:  0xef4444, // çº¢è‰² (è¢«å‡å»çš„å—)
            edge:   0x000000,
            bg:     0xffffff
        };

        // --- 2. åˆå§‹åŒ– Three.js ---
        function init() {
            const container = document.getElementById('canvas-container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.bg);

            // ç›¸æœº (é€è§†æŠ•å½±)
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 1, 1000);
            camera.position.set(80, 70, 100); // åˆå§‹è§†è§’

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // è¾…åŠ©ç½‘æ ¼ (åœ°æ¿)
            const gridHelper = new THREE.GridHelper(200, 20, 0xdddddd, 0xeeeeee);
            scene.add(gridHelper);

            // åˆå§‹åŒ–å‡ ä½•ä½“
            createGeometry();

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);
            
            // ç»‘å®šæ»‘å—äº‹ä»¶
            document.getElementById('slider-b').addEventListener('input', (e) => {
                config.bRatio = parseFloat(e.target.value);
                document.getElementById('val-b').innerText = config.bRatio.toFixed(2) + "a";
                rebuildGeometry(); // æ”¹å˜å¤§å°æ—¶å¿…é¡»é‡å»ºå‡ ä½•ä½“
            });

            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            animate();
            
            // åˆå§‹è®¡ç®—ç›®æ ‡ä½ç½®
            calculateTargets();
        }

        // --- 3. å‡ ä½•ä½“æ„å»º ---
        // è¿™é‡Œçš„é€»è¾‘æ˜¯æ ¸å¿ƒï¼šå¦‚ä½•æŠŠ a^3 - b^3 åˆ‡å‰²æˆä¸‰å—
        // åˆ‡å‰²æ–¹æ¡ˆï¼š
        // 1. ä¸‹å±‚æ¿ (Block 1): é«˜åº¦ a-bï¼Œåº•é¢ a*aã€‚ ä½“ç§¯: a*a*(a-b)
        // 2. ä¸Šå±‚å‰©ä½™éƒ¨åˆ†æ˜¯ä¸ª L å‹ï¼Œå†åˆ‡ä¸€åˆ€ï¼š
        //    - ä¾§æ¡ (Block 2): é«˜åº¦ bï¼Œå®½åº¦ a-bï¼Œé•¿åº¦ aã€‚ ä½“ç§¯: a*(a-b)*b
        //    - å‰è§’ (Block 3): é«˜åº¦ bï¼Œå®½åº¦ bï¼Œé•¿åº¦ a-bã€‚ ä½“ç§¯: b*b*(a-b)
        // è¿™ä¸ªç»„åˆåˆšå¥½å¡«æ»¡é™¤äº† b^3 ä»¥å¤–çš„ç©ºé—´ã€‚
        
        function createGeometry() {
            // æ¸…é™¤æ—§ç‰©ä½“
            ['block1', 'block2', 'block3', 'cubeB'].forEach(key => {
                if(blocks[key]) scene.remove(blocks[key]);
                if(edges[key]) scene.remove(edges[key]);
            });

            const a = config.a;
            const b = config.a * config.bRatio;
            const h_diff = a - b; // å…¬å…±é«˜åº¦å› å­ (a-b)

            // æè´¨
            const matBase = { transparent: true, opacity: 0.9, shininess: 30 };
            const mat1 = new THREE.MeshPhongMaterial({ ...matBase, color: COLORS.block1 });
            const mat2 = new THREE.MeshPhongMaterial({ ...matBase, color: COLORS.block2 });
            const mat3 = new THREE.MeshPhongMaterial({ ...matBase, color: COLORS.block3 });
            const matB = new THREE.MeshPhongMaterial({ ...matBase, color: COLORS.cubeB, opacity: 0.4, transparent: true });

            // --- Block 1: åº•åº§ ---
            // å°ºå¯¸: a * (a-b) * a
            // åˆå§‹ä½ç½®: åº•éƒ¨å±…ä¸­
            const geo1 = new THREE.BoxGeometry(a, h_diff, a);
            blocks.block1 = new THREE.Mesh(geo1, mat1);
            // åæ ‡ä¸­å¿ƒè°ƒæ•´: Yè½´ä» 0 åˆ° a-b
            // åˆå§‹ä½ç½®è®¾ä¸ºåŸç‚¹é™„è¿‘
            blocks.block1.userData = { 
                size: {x: a, y: h_diff, z: a},
                originPos: new THREE.Vector3(0, h_diff/2, 0) 
            };
            
            // --- Block 2: ä¾§ç¿¼ ---
            // ä½äº Block 1 ä¹‹ä¸Šï¼Œä¾§é¢
            // å°ºå¯¸: (a-b) * b * a
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬è®© Block 2 çš„é•¿è¾¹æ²¿ Z è½´ï¼Œå®½æ²¿ X è½´ï¼Œé«˜æ²¿ Y è½´
            // ä¸ºäº†ä¹‹åæ‹¼æ¥æ–¹ä¾¿ï¼Œæˆ‘ä»¬å®šä¹‰ Block 2 ä¸º: å®½(a-b), é«˜ b, é•¿ a
            // æ”¾ç½®åœ¨ Block 1 ä¸Šæ–¹çš„ä¸€ä¾§
            const geo2 = new THREE.BoxGeometry(h_diff, b, a);
            blocks.block2 = new THREE.Mesh(geo2, mat2);
            // åˆå§‹ä½ç½®: Xè½´åå·¦
            blocks.block2.userData = {
                size: {x: h_diff, y: b, z: a},
                originPos: new THREE.Vector3(-(a/2 - h_diff/2), h_diff + b/2, 0)
            };

            // --- Block 3: å‰è§’å°å— ---
            // ä½äº Block 1 ä¹‹ä¸Šï¼ŒBlock 2 æ—è¾¹
            // å°ºå¯¸: b * b * (a-b)
            // æ³¨æ„ï¼šè¢«å‡å»çš„ b^3 ä½äºå³ä¸Šè§’åæ–¹ï¼Œæ‰€ä»¥ Block 3 åœ¨å³ä¸Šè§’å‰æ–¹
            const geo3 = new THREE.BoxGeometry(b, b, h_diff);
            blocks.block3 = new THREE.Mesh(geo3, mat3);
            blocks.block3.userData = {
                size: {x: b, y: b, z: h_diff},
                // ä½ç½®: Xè½´åå³, Zè½´åå‰
                originPos: new THREE.Vector3((a/2 - b/2), h_diff + b/2, (a/2 - h_diff/2))
            };

            // --- Cube B: è¢«å‡å»çš„éƒ¨åˆ† ---
            // å°ºå¯¸: b * b * b
            // ä½ç½®: å³ä¸Šè§’åæ–¹
            const geoB = new THREE.BoxGeometry(b, b, b);
            blocks.cubeB = new THREE.Mesh(geoB, matB);
            blocks.cubeB.userData = {
                originPos: new THREE.Vector3((a/2 - b/2), h_diff + b/2, -(a/2 - b/2))
            };

            // æ·»åŠ åˆ°åœºæ™¯å¹¶åˆ›å»ºè¾¹æ¡†
            ['block1', 'block2', 'block3', 'cubeB'].forEach(key => {
                const mesh = blocks[key];
                // è®¾ç½®åˆå§‹ä½ç½®
                mesh.position.copy(mesh.userData.originPos);
                scene.add(mesh);

                // è¾¹æ¡†
                const edgesGeo = new THREE.EdgesGeometry(mesh.geometry);
                const edgesMat = new THREE.LineBasicMaterial({ color: COLORS.edge, transparent: true, opacity: 0.3 });
                const edgeLines = new THREE.LineSegments(edgesGeo, edgesMat);
                edges[key] = edgeLines;
                mesh.add(edgeLines); // å°†è¾¹æ¡†ä½œä¸ºå­å¯¹è±¡ï¼Œéšçˆ¶å¯¹è±¡ç§»åŠ¨
            });

            // ç«‹å³æ›´æ–°åˆ°å½“å‰çŠ¶æ€
            calculateTargets();
            snapToTargets();
        }

        function rebuildGeometry() {
            createGeometry();
            calculateTargets();
        }

        // --- 4. çŠ¶æ€ä¸åŠ¨ç”»é€»è¾‘ ---

        function setAppState(stateIndex) {
            config.currentState = stateIndex;
            
            // æ›´æ–°æŒ‰é’®UI
            for(let i=0; i<=3; i++) {
                const btn = document.getElementById(`btn-state-${i}`);
                if(i === stateIndex) btn.classList.add('active');
                else btn.classList.remove('active');
            }

            // æ›´æ–°è¯´æ˜UI
            const infoCut = document.getElementById('info-cut');
            if(stateIndex === 0) infoCut.style.display = 'none';
            else infoCut.style.display = 'block';

            calculateTargets();
            
            // å¦‚æœä¸å¯ç”¨åŠ¨ç”»ï¼Œç›´æ¥è·³è½¬
            if(!document.getElementById('chk-anim').checked) {
                snapToTargets();
            }
        }

        function calculateTargets() {
            const a = config.a;
            const b = config.a * config.bRatio;
            const h_diff = a - b;
            const gap = config.gap;
            const s = config.currentState;

            // è¾…åŠ©ï¼šé‡ç½®ç›®æ ‡
            // ç›®æ ‡æ ¼å¼: { pos: Vector3, rot: Vector3(Euler) }
            const keys = ['block1', 'block2', 'block3', 'cubeB'];
            keys.forEach(k => {
                targets.pos[k] = blocks[k].userData.originPos.clone();
                targets.rot[k] = new THREE.Euler(0, 0, 0);
                
                // é»˜è®¤å¯è§æ€§å¤„ç†ï¼ˆé€šè¿‡ç¼©æ”¾å®ç°æ¶ˆå¤±åŠ¨ç”»ï¼Œæ¯” visible å±æ€§æ›´å¹³æ»‘ï¼‰
                targets.scale = targets.scale || {};
                targets.scale[k] = new THREE.Vector3(1, 1, 1);
            });

            // --- çŠ¶æ€é€»è¾‘ ---

            if (s === 0) {
                // çŠ¶æ€ 0: å®Œæ•´ç«‹æ–¹ä½“
                // Cube B ç¨å¾®é—ªçƒæˆ–é«˜äº® (é€»è¾‘åœ¨ render ä¸­å¤„ç†)
                targets.scale['cubeB'].set(1, 1, 1);
            }
            else if (s === 1) {
                // çŠ¶æ€ 1: ç§»é™¤ b^3
                // å°† b^3 å‘ä¸Šå‘åç§»åŠ¨å¹¶æ¶ˆå¤±
                targets.pos['cubeB'].add(new THREE.Vector3(20, 20, -20));
                targets.scale['cubeB'].set(0, 0, 0); // ç¼©å°è‡³æ¶ˆå¤±
            }
            else if (s === 2) {
                // çŠ¶æ€ 2: çˆ†ç‚¸åˆ†è§£
                // b^3 ä¿æŒæ¶ˆå¤±
                targets.pos['cubeB'].add(new THREE.Vector3(20, 20, -20));
                targets.scale['cubeB'].set(0, 0, 0);

                // Block 1 ä¸‹ç§»
                targets.pos['block1'].y -= 10;
                
                // Block 2 å·¦ç§»
                targets.pos['block2'].x -= 10;
                targets.pos['block2'].y += 5; // ç¨å¾®é”™å¼€

                // Block 3 å‰ç§»
                targets.pos['block3'].z += 10;
                targets.pos['block3'].y += 5;
                targets.pos['block3'].x += 5;
            }
            else if (s === 3) {
                // çŠ¶æ€ 3: çº¿æ€§æ‹¼æ¥ (Factorization view)
                // ç›®æ ‡: å°†ä¸‰ä¸ªå—æ’æˆä¸€æ’ï¼Œä¸”é«˜åº¦æ–¹å‘éƒ½æ˜¯ (a-b)
                // è¿™éœ€è¦æ—‹è½¬ Block 2 å’Œ Block 3
                
                // b^3 æ¶ˆå¤±
                targets.scale['cubeB'].set(0, 0, 0);

                // --- Block 1 (è“è‰² a^2 * (a-b)) ---
                // ä¿æŒåŸæ¥çš„æœå‘ï¼Œæ”¾åœ¨ä¸­é—´
                targets.pos['block1'].set(0, h_diff/2, 0);

                // --- Block 2 (æ©™è‰² ab * (a-b)) ---
                // åŸå°ºå¯¸: (a-b) * b * a
                // æˆ‘ä»¬å¸Œæœ›é«˜åº¦æ˜¯ (a-b)ã€‚
                // åŸæ¥çš„é«˜åº¦æ˜¯ bã€‚æˆ‘ä»¬éœ€è¦æ—‹è½¬ï¼Œè®© (a-b) è¾¹å˜ç«–ç›´ã€‚
                // ç»• Z è½´æ—‹è½¬ 90åº¦?
                // åŸ X: a-b, Y: b, Z: a.
                // æ—‹è½¬ -90åº¦ around Z: æ–° Y è½´æ–¹å‘æ˜¯åŸæ¥çš„ X (a-b)ã€‚
                targets.rot['block2'].z = -Math.PI / 2;
                
                // æ—‹è½¬åï¼Œä¸­å¿ƒä½ç½®éœ€è¦é‡æ–°è®¡ç®—ä»¥å¯¹é½åœ°é¢
                // æ—‹è½¬åå°ºå¯¸æ„Ÿå®˜: å®½ b, é«˜ a-b, æ·± a.
                // æ”¾ç½®åœ¨ Block 1 å·¦ä¾§
                // Block 1 å®½åº¦ a (Xè½´èŒƒå›´ -a/2 åˆ° a/2)
                // Block 2 å®½åº¦ b. å·¦ä¾§ä½ç½® X = -a/2 - b/2 - gap
                targets.pos['block2'].set(
                    -(a/2 + b/2 + gap), 
                    h_diff/2, 
                    0
                );

                // --- Block 3 (ç»¿è‰² b^2 * (a-b)) ---
                // åŸå°ºå¯¸: b * b * (a-b)
                // æˆ‘ä»¬å¸Œæœ›é«˜åº¦æ˜¯ (a-b)ã€‚
                // åŸ Z è½´æ˜¯ (a-b)ã€‚ç»• X è½´æ—‹è½¬ 90åº¦ã€‚
                targets.rot['block3'].x = Math.PI / 2;

                // æ—‹è½¬åå°ºå¯¸æ„Ÿå®˜: å®½ b, é«˜ a-b, æ·± b.
                // æ”¾ç½®åœ¨ Block 1 å³ä¾§
                // Block 1 å³è¾¹ç¼˜ a/2.
                // Block 3 å®½åº¦ b. å³ä¾§ä½ç½® X = a/2 + b/2 + gap
                // æ·±åº¦å¯¹é½: Block 1 æ·±åº¦ a. Block 3 æ·±åº¦ b. æˆ‘ä»¬å¯ä»¥å±…ä¸­å¯¹é½ Z=0.
                targets.pos['block3'].set(
                    (a/2 + b/2 + gap),
                    h_diff/2,
                    0
                );
            }
        }

        // ç¬é—´è·³è½¬ï¼ˆä¸åŠ¨ç”»ï¼‰
        function snapToTargets() {
            const keys = ['block1', 'block2', 'block3', 'cubeB'];
            keys.forEach(k => {
                if(blocks[k]) {
                    blocks[k].position.copy(targets.pos[k]);
                    blocks[k].rotation.copy(targets.rot[k]);
                    blocks[k].scale.copy(targets.scale[k]);
                }
            });
        }

        function updateVisibility() {
            const showEdges = document.getElementById('chk-edges').checked;
            Object.values(edges).forEach(e => e.visible = showEdges);
        }

        // --- 5. æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // åŠ¨ç”»æ’å€¼é€»è¾‘
            if (document.getElementById('chk-anim').checked) {
                const speed = config.animSpeed;
                const keys = ['block1', 'block2', 'block3', 'cubeB'];
                
                keys.forEach(k => {
                    const mesh = blocks[k];
                    if(!mesh) return;

                    // ä½ç½®æ’å€¼
                    mesh.position.lerp(targets.pos[k], speed);
                    
                    // æ—‹è½¬æ’å€¼ (ç®€å•å››å…ƒæ•°æ’å€¼)
                    const targetQuat = new THREE.Quaternion().setFromEuler(targets.rot[k]);
                    mesh.quaternion.slerp(targetQuat, speed);

                    // ç¼©æ”¾æ’å€¼
                    mesh.scale.lerp(targets.scale[k], speed);
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>