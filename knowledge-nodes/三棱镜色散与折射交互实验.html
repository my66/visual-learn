<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¸‰æ£±é•œè‰²æ•£ä¸æŠ˜å°„äº¤äº’å®éªŒ (ä¿®æ­£ç‰ˆ)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    /* é¡µé¢åŸºç¡€æ ·å¼ */
    body {
      margin: 0;
      padding: 0;
      font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
      background-color: #f0f2f5;
      color: #333;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* å¸ƒå±€å®¹å™¨ */
    #container {
      display: flex;
      flex: 1;
      flex-direction: row;
      overflow: hidden;
      height: 100%;
    }

    /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
    #sidebar {
      width: 340px;
      background: #ffffff;
      padding: 20px;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      overflow-y: auto;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    /* æ ‡é¢˜åŒºåŸŸ */
    .header {
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
      margin-bottom: 5px;
    }
    .header h2 {
      margin: 0;
      font-size: 20px;
      color: #2c3e50;
    }
    .header p {
      margin: 5px 0 0;
      font-size: 13px;
      color: #7f8c8d;
    }

    /* æ§åˆ¶ç»„ */
    .control-group {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #e9ecef;
    }
    .control-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
      color: #34495e;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    /* æ§ä»¶æ ·å¼ */
    label {
      display: block;
      font-size: 13px;
      margin-bottom: 8px;
      color: #555;
    }
    input[type=range] {
      width: 100%;
      margin: 5px 0;
      cursor: pointer;
    }
    .value-display {
      float: right;
      font-weight: bold;
      color: #3498db;
    }
    
    /* æŒ‰é’®ç»„ */
    .btn-group {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .btn-toggle {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    .btn-toggle.active {
      background: #e1f0fa;
      border-color: #3498db;
      color: #2980b9;
      font-weight: bold;
    }
    
    /* è¯´æ˜æ–‡å­— */
    .info-box {
      font-size: 12px;
      line-height: 1.6;
      color: #666;
      background: #fff3cd;
      padding: 10px;
      border-radius: 4px;
      border-left: 3px solid #ffc107;
    }

    /* çŠ¶æ€æ  */
    .status-bar {
      margin-top: auto;
      padding-top: 15px;
      font-size: 12px;
      color: #888;
      border-top: 1px solid #eee;
    }

    /* ç”»å¸ƒå®¹å™¨ */
    #canvas-container {
      flex: 1;
      position: relative;
      background-color: #f0f2f5;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
  </style>
</head>
<body>

  <div id="container">
    <!-- å·¦ä¾§æ§åˆ¶æ  -->
    <aside id="sidebar">
      <div class="header">
        <h2>ä¸‰æ£±é•œè‰²æ•£ä¸æŠ˜å°„ (ä¿®æ­£ç‰ˆ)</h2>
        <p>æ¢ç©¶çº¢å…‰ä¸ç´«å…‰åœ¨ä»‹è´¨ä¸­çš„å·®å¼‚</p>
      </div>

      <!-- æ ¸å¿ƒå®éªŒæ§åˆ¶ -->
      <div class="control-group">
        <div class="control-title">ğŸ”¦ å…‰æºè®¾ç½®</div>
        
        <label>å…‰çº¿é¢œè‰²æ¨¡å¼ï¼š</label>
        <div class="btn-group">
          <button class="btn-toggle active" onclick="setLightMode('red')" id="btn-red">ğŸ”´ çº¢å…‰</button>
          <button class="btn-toggle" onclick="setLightMode('violet')" id="btn-violet">ğŸŸ£ ç´«å…‰</button>
          <button class="btn-toggle" onclick="setLightMode('both')" id="btn-both">ğŸŒˆ å¯¹æ¯”</button>
        </div>

        <label>å…¥å°„è§’åº¦ (è°ƒæ•´å…‰çº¿å€¾æ–œ) <span id="angle-val" class="value-display">49Â°</span></label>
        <input type="range" id="angle-slider" min="30" max="80" value="49" step="1">
        <div style="font-size:11px; color:#888; margin-top:5px;">* é»˜è®¤ 49Â° æ—¶çº¢å…‰åœ¨æ£±é•œå†…æ°´å¹³ (ç»å…¸è§†è§’)</div>
      </div>

      <!-- å…‰å±å®éªŒ -->
      <div class="control-group">
        <div class="control-title">ğŸ“ å…‰å±å®éªŒ (è§£é¢˜å…³é”®)</div>
        <p style="font-size:12px; margin-bottom:10px; color:#555;">
          é¢˜ç›®é—®ï¼šæ¢æˆç´«å…‰åï¼Œå…‰æ–‘åç¦» a ç‚¹ã€‚<br>
          å‘å·¦è¿˜æ˜¯å‘å³ç§»åŠ¨å…‰å±ï¼Œèƒ½è®©ç´«å…‰æ–‘å›åˆ° a ç‚¹çš„é«˜åº¦ï¼Ÿ
        </p>
        
        <label>å…‰å±ä½ç½® (å·¦å³å¹³ç§») <span id="screen-val" class="value-display">0</span></label>
        <input type="range" id="screen-slider" min="-150" max="100" value="0" step="1">
        
        <div style="margin-top:10px;">
          <input type="checkbox" id="mark-a" checked>
          <label for="mark-a" style="display:inline; cursor:pointer;">é”å®šåˆå§‹çº¢å…‰é«˜åº¦ (è™šçº¿å‚è€ƒ a)</label>
        </div>
      </div>

      <!-- çŸ¥è¯†ç‚¹æç¤º -->
      <div class="info-box">
        <strong>ğŸ’¡ ä¿®æ­£è¯´æ˜ï¼š</strong><br>
        1. å…¥å°„å…‰ç°å·²æ”¹ä¸ºä»å·¦ä¸‹æ–¹å°„å…¥ï¼Œç¬¦åˆæ•™ææ’å›¾ã€‚<br>
        2. ç´«å…‰æŠ˜å°„ç‡å¤§ï¼ŒåæŠ˜è§’å¤§ï¼Œå‡ºå°„å…‰çº¿æ›´é™¡å³­ï¼ˆæ›´å‘ä¸‹ï¼‰ã€‚<br>
        3. è¯•ç€æŠŠå…‰å±å‘å·¦ç§»ï¼ˆé è¿‘æ£±é•œï¼‰ï¼Œè§‚å¯Ÿç´«å…‰æ–‘æ˜¯å¦ä¼šå‡é«˜å›åˆ°è™šçº¿ a å¤„ã€‚
      </div>

      <div class="status-bar">
        Physics Simulation: Refraction & Dispersion
      </div>
    </aside>

    <!-- å³ä¾§ç”»å¸ƒ -->
    <div id="canvas-container"></div>
  </div>

<script>
/**
 * ç‰©ç†ä¸æ•°å­¦å¯è§†åŒ–é€»è¾‘ (p5.js)
 * ä¿®æ­£ç‰ˆï¼šè°ƒæ•´å‡ ä½•å¸ƒå±€ä»¥åŒ¹é…ç»å…¸ç‰©ç†æ•™æ
 */

// ---------------- å…¨å±€å˜é‡ ----------------
let canvasWidth, canvasHeight;
let prismVertices = []; // å­˜å‚¨ä¸‰æ£±é•œé¡¶ç‚¹
let lightMode = 'red';  // 'red', 'violet', 'both'

// ç‰©ç†å‚æ•°
const N_AIR = 1.00;
const N_GLASS_RED = 1.50;
const N_GLASS_VIOLET = 1.60; // å¤¸å¤§å·®å¼‚ä»¥ä¾¿è§‚å¯Ÿ (å®é™…å·®å¼‚è¾ƒå°)

// åœºæ™¯çŠ¶æ€
let incidentAngleDeg = 49; // é»˜è®¤49åº¦ï¼Œä½¿å¾—çº¢å…‰åœ¨æ­£ä¸‰è§’å½¢æ£±é•œä¸­æ°´å¹³ä¼ æ’­
let screenOffset = 0;   
let showMarkA = true;   

// è®°å½•ç‚¹açš„ä½ç½® (çº¢å…‰åœ¨åˆå§‹å±å¹•ä½ç½®çš„è½ç‚¹)
// è¿™é‡Œæˆ‘ä»¬é”å®š a çš„é«˜åº¦ä¸ºâ€œå±å¹•åæ ‡ç³»ä¸‹çš„ç»å¯¹é«˜åº¦â€ï¼Œ
// å‡è®¾é¢˜ç›®æ„æ€æ˜¯ a ç‚¹æ˜¯ä¸€ä¸ªç‰©ç†æ ‡è®°ï¼Œéšå±å¹•ç§»åŠ¨ï¼Ÿ
// ä¸ï¼Œé¢˜ç›®é€šå¸¸æ„æŒ‡â€œç©ºé—´ä½ç½®â€æˆ–â€œç›¸å¯¹é«˜åº¦â€ã€‚
// è¿™é‡Œæˆ‘ä»¬å®šä¹‰ï¼ša æ˜¯çº¢å…‰åœ¨ screenOffset=0 æ—¶æ‰“åœ¨å±å¹•ä¸Šçš„é«˜åº¦ã€‚
// å½“å±å¹•ç§»åŠ¨æ—¶ï¼Œæˆ‘ä»¬ç”»å‡ºä¸€æ¡è™šçº¿è¡¨ç¤ºè¿™ä¸ªâ€œç›®æ ‡é«˜åº¦â€ï¼Œçœ‹ç´«å…‰èƒ½ä¸èƒ½ç¢°åˆ°è¿™æ¡çº¿ã€‚
let targetHeightY = null;

// UI å…ƒç´ å¼•ç”¨
let angleSlider, screenSlider, checkMarkA;
let angleValDisplay, screenValDisplay;

function setup() {
  const container = document.getElementById('canvas-container');
  canvasWidth = container.clientWidth;
  canvasHeight = container.clientHeight;
  const cnv = createCanvas(canvasWidth, canvasHeight);
  cnv.parent('canvas-container');
  
  angleSlider = document.getElementById('angle-slider');
  screenSlider = document.getElementById('screen-slider');
  checkMarkA = document.getElementById('mark-a');
  angleValDisplay = document.getElementById('angle-val');
  screenValDisplay = document.getElementById('screen-val');
  
  angleSlider.addEventListener('input', updateState);
  screenSlider.addEventListener('input', updateState);
  checkMarkA.addEventListener('change', updateState);
  window.addEventListener('resize', windowResized);

  updateState();
}

function updateState() {
  incidentAngleDeg = parseFloat(angleSlider.value);
  screenOffset = parseFloat(screenSlider.value);
  showMarkA = checkMarkA.checked;
  
  angleValDisplay.innerText = incidentAngleDeg + "Â°";
  screenValDisplay.innerText = screenOffset > 0 ? "+" + screenOffset : screenOffset;
}

function setLightMode(mode) {
  lightMode = mode;
  document.querySelectorAll('.btn-toggle').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + mode).classList.add('active');
}

function windowResized() {
  const container = document.getElementById('canvas-container');
  canvasWidth = container.clientWidth;
  canvasHeight = container.clientHeight;
  resizeCanvas(canvasWidth, canvasHeight);
}

// ---------------- æ ¸å¿ƒç»˜åˆ¶å¾ªç¯ ----------------
function draw() {
  background(255);
  translate(width / 2, height / 2);
  
  // 1. å®šä¹‰ä¸‰æ£±é•œ (æ­£ä¸‰è§’å½¢)
  let side = 200;
  let h = side * Math.sqrt(3) / 2;
  // é¡¶ç‚¹ A(top), B(left), C(right)
  let topY = -h / 2;
  let bottomY = h / 2;
  
  let A = createVector(0, topY);
  let B = createVector(-side / 2, bottomY);
  let C = createVector(side / 2, bottomY);
  prismVertices = [A, B, C];
  
  drawPrism(A, B, C);
  
  // 2. ç»˜åˆ¶å…‰å±
  // åˆå§‹ä½ç½®åœ¨æ£±é•œå³ä¾§
  let baseScreenX = side / 2 + 100;
  let currentScreenX = baseScreenX + screenOffset;
  drawScreen(currentScreenX);
  
  // 3. è®¡ç®—â€œå‚è€ƒç‚¹ aâ€çš„é«˜åº¦
  // æ°¸è¿œä»¥çº¢å…‰ã€screenOffset=0ã€å½“å‰è§’åº¦ ä¸ºåŸºå‡†è®¡ç®— a ç‚¹é«˜åº¦
  // è¿™æ ·å¦‚æœç”¨æˆ·æ”¹å˜å…¥å°„è§’ï¼Œa ç‚¹ä¹Ÿä¼šæ›´æ–°ï¼Œç¬¦åˆâ€œä¿æŒå…¥å°„å…‰ä½ç½®ä¸å˜â€çš„å‰æ
  let refRedHit = calculateRayHit(N_GLASS_RED, A, B, C, baseScreenX);
  if (refRedHit) {
    targetHeightY = refRedHit.y;
  }
  
  // ç»˜åˆ¶ç›®æ ‡é«˜åº¦è™šçº¿ (aç‚¹æ°´å¹³çº¿)
  if (showMarkA && targetHeightY !== null) {
    drawTargetLine(currentScreenX, targetHeightY);
  }

  // 4. ç»˜åˆ¶å…‰è·¯
  if (lightMode === 'red' || lightMode === 'both') {
    drawRayTrace(N_GLASS_RED, color(255, 50, 50), currentScreenX, "çº¢");
  }
  
  if (lightMode === 'violet' || lightMode === 'both') {
    drawRayTrace(N_GLASS_VIOLET, color(140, 50, 220), currentScreenX, "ç´«");
  }

  drawLegend();
}

// ---------------- ç»˜å›¾è¾…åŠ© ----------------

function drawPrism(A, B, C) {
  fill(230, 245, 255, 200);
  stroke(100, 150, 200);
  strokeWeight(2);
  triangle(A.x, A.y, B.x, B.y, C.x, C.y);
  
  // æ ‡æ³¨é¡¶ç‚¹
  noStroke();
  fill(100);
  textSize(12);
  // text("A", A.x, A.y - 10);
  // text("B", B.x - 10, B.y + 15);
  // text("C", C.x + 10, C.y + 15);
}

function drawScreen(x) {
  stroke(80);
  strokeWeight(4);
  line(x, -200, x, 200);
  
  noStroke();
  fill(80);
  textAlign(CENTER);
  text("å…‰å±", x, -210);
  
  // åº•éƒ¨å¯¼è½¨
  stroke(200);
  strokeWeight(2);
  line(x-60, 200, x+60, 200);
  // åˆ»åº¦
  for(let i=-50; i<=50; i+=10) line(x+i, 200, x+i, 205);
}

function drawTargetLine(screenX, y) {
  // ç”»ä¸€æ¡è´¯ç©¿å…‰å±åŒºåŸŸçš„æ°´å¹³è™šçº¿ï¼Œè¡¨ç¤ºé«˜åº¦ a
  stroke(255, 100, 100, 150); // çº¢è‰²è™šçº¿
  strokeWeight(1);
  drawingContext.setLineDash([5, 5]);
  line(screenX - 40, y, screenX + 40, y);
  drawingContext.setLineDash([]);
  
  noStroke();
  fill(200, 50, 50);
  textAlign(LEFT, CENTER);
  text(" a (ç›®æ ‡é«˜åº¦)", screenX + 45, y);
  
  // åœ¨å…‰å±ä¸Šç”»ä¸ªç‚¹
  fill(50);
  ellipse(screenX, y, 4, 4);
}

function drawLegend() {
  resetMatrix();
  fill(50);
  noStroke();
  textAlign(LEFT, TOP);
  textSize(12);
  text("å›¾ä¾‹ï¼š", 20, 20);
  
  fill(255, 50, 50);
  rect(20, 40, 10, 10);
  fill(50);
  text("çº¢å…‰ (åæŠ˜å°)", 40, 40);
  
  fill(140, 50, 220);
  rect(20, 60, 10, 10);
  fill(50);
  text("ç´«å…‰ (åæŠ˜å¤§)", 40, 60);
}

// ---------------- ç‰©ç†è®¡ç®—æ ¸å¿ƒ ----------------

function drawRayTrace(n_glass, col, screenX, label) {
  let trace = calculateRayPath(n_glass, prismVertices[0], prismVertices[1], prismVertices[2], screenX);
  if (!trace) return;
  
  stroke(col);
  strokeWeight(2);
  noFill();
  
  // 1. å…¥å°„å…‰çº¿ (ç”»ä¸€éƒ¨åˆ†)
  let startP = p5.Vector.sub(trace.entry, p5.Vector.mult(trace.incidentDir, 100));
  line(startP.x, startP.y, trace.entry.x, trace.entry.y);
  drawArrow(startP, trace.incidentDir, col);
  
  // 2. å†…éƒ¨å…‰çº¿
  line(trace.entry.x, trace.entry.y, trace.exit.x, trace.exit.y);
  
  // 3. å‡ºå°„å…‰çº¿
  // åˆ¤æ–­æ˜¯å¦æ‰“åˆ°å…‰å± (xæ–¹å‘)
  // å¦‚æœå…‰å±åœ¨å‡ºå°„ç‚¹å·¦ä¾§ï¼Œå°±ä¸ç”»äº†ï¼ˆæˆ–è€…ç”»åå‘å»¶é•¿çº¿ï¼Œè¿™é‡Œåªç”»æ­£å‘ï¼‰
  if (screenX > trace.exit.x) {
     let hitY = trace.exit.y + (screenX - trace.exit.x) * (trace.exitDir.y / trace.exitDir.x);
     line(trace.exit.x, trace.exit.y, screenX, hitY);
     drawArrow(trace.exit, trace.exitDir, col);
     
     // å…‰æ–‘
     fill(col);
     noStroke();
     ellipse(screenX, hitY, 6, 6);
     if (lightMode === 'both') {
       textAlign(RIGHT, CENTER);
       text(label, screenX - 10, hitY);
     }
  } else {
     // å…‰å±åœ¨æ£±é•œå†…éƒ¨æˆ–å·¦ä¾§ï¼Œåªç”»ä¸€æ®µå°„çº¿
     let endP = p5.Vector.add(trace.exit, p5.Vector.mult(trace.exitDir, 50));
     line(trace.exit.x, trace.exit.y, endP.x, endP.y);
  }
}

// çº¯è®¡ç®—å‡½æ•°ï¼Œè¿”å›å…‰è·¯å…³é”®ç‚¹
function calculateRayPath(n_glass, A, B, C, targetX) {
  // è®¾å®šå…¥å°„ç‚¹åœ¨ AB è¾¹ä¸­ç‚¹é™„è¿‘
  let entryPoint = p5.Vector.lerp(A, B, 0.65);
  
  // è®¡ç®— AB è¾¹æ³•çº¿ (å‘å¤–)
  // A(0, -h/2), B(-w/2, h/2). Vector AB = (-w/2, h)
  // Normal = (h, w/2) -> Right-Down? No.
  // We want Normal pointing OUT from left face. Should be Left-Up.
  // AB vector is Down-Left. (B-A).
  // Normal (y, -x) of (-w, h) is (h, w). Right-Up?
  // Let's use Geometry explicitly.
  // Left face angle is 120 deg (from X axis counter-clockwise)?
  // Triangle is equilateral. Base is horizontal.
  // Left side leans at 60 deg to horizontal? No, 60 deg is internal.
  // Side slope is -sqrt(3) (if A is origin).
  // Visual normal angle: 150 deg (Left-Up).
  let normalAB = createVector(-Math.cos(radians(30)), -Math.sin(radians(30))); // Normal pointing Left-Up (210 deg? No, 150 deg)
  // Let's just calculate perpendicular to AB.
  let AB = p5.Vector.sub(B, A);
  let normalOut = createVector(AB.y, -AB.x).normalize(); 
  // A=(0,-), B=(-, +). AB=(-, +). Normal=(+, +)? Points Right-Up (Into Prism).
  // So we want -Normal.
  normalOut.mult(-1); // Now points Left-Up.
  
  // å…¥å°„è§’ i
  // å…¥å°„å…‰çº¿æ–¹å‘: 
  // é¢˜ç›®å›¾ä¸­å…‰çº¿ä»å·¦ä¸‹å°„å‘å³ä¸Š.
  // ä¹Ÿå°±æ˜¯ RayDir åº”è¯¥æŒ‡å‘ First Quadrant (x>0, y<0? No y is down in p5)
  // p5 coordinates: y increases downwards.
  // Visual: Up is y<0.
  // Ray goes "Up-Right" visually => x>0, y<0.
  
  // Snell's Law Setup:
  // Angle i is between Normal and Ray.
  // Normal points Left-Up (-x, -y).
  // Ray points Right-Up (+x, -y).
  // To get a nice incident angle, we define Ray relative to Normal.
  // Ray = Normal rotated by (180 - i) or something.
  // Let's define incident angle w.r.t Normal.
  // Ray_IN is approaching surface.
  // Let's construct Ray direction explicitly based on `incidentAngleDeg`.
  // If angle=0, Ray aligns with -Normal (enters perpendicularly).
  // If angle=i, Ray is rotated by i from -Normal.
  // To match "Up-Right" entry, we rotate Clockwise from -Normal?
  // NormalOut points Left-Up. -NormalOut points Right-Down (Into Prism).
  // Wait, Ray direction must be the direction OF travel.
  // Ray travel is Right-Up.
  // NormalOut is Left-Up.
  // Angle between them is obtuse.
  // Snell's angle is angle between Ray and Normal? Actually between Ray and -Normal (if both originate from surface).
  // Let's just use the refract function which handles vectors robustly.
  // We need to define Incident Direction Vector `incidentDir`.
  
  // We want Ray to go Right-Up.
  // Angle of AB surface normal (Out): approx 210 degrees (if 0 is Right, 90 is Down).
  // Wait, p5 coordinates: 0 Right, 90 Down, 180 Left, 270 Up.
  // A=(0, -h), B=(-w, h). AB is Vector(-w, 2h). Points Left-Down.
  // Normal (-dy, dx) = (-2h, -w). Left-Up. Angle approx 240? 
  // Let's simpler: Side angle is 60 deg from horizontal.
  // Normal angle is 150 deg (visual). In p5 (y down):
  // Visual Up is 270. Visual Left is 180.
  // Normal is 210? (Left-Down). No Left-Up visual is 225?
  // Let's stick to vector math.
  
  // Construct Incident Ray based on user slider 'incidentAngle'.
  // We assume 'incidentAngle' is the angle with the Normal.
  // And we want the ray to come from "Below" the normal axis.
  // Vector -Normal points INTO prism (Right-Down).
  // We want Ray to be Right-Up.
  // So we rotate -Normal by some angle to point Up.
  let inNormal = p5.Vector.mult(normalOut, -1); // Points into prism (perp to side)
  // We rotate this vector to get incident ray.
  // If we rotate negative (CCW), we go towards Up.
  // So incidentDir = inNormal.rotate(-radians(incidentAngleDeg)).
  
  // Correction: To ensure internal ray is horizontal when angle is ideal (~49).
  // Side angle is 30 deg from vertical.
  // Normal is 30 deg from horizontal.
  // If we want horizontal ray (0 deg), refraction angle r must be 30 deg.
  // Snell: sin(i) = 1.5 * sin(30) = 0.75. i = 48.6 deg.
  // So if i = 49, r = 30.
  // Ray inside is Horizontal (0 deg or 180).
  // If InNormal is 30 deg down from horizontal (30 deg).
  // We rotate -49 deg (Up). 30 - 49 = -19 deg (Up-Right).
  // Visual: Ray goes Up-Right. Matches!
  
  let incidentDir = inNormal.copy().rotate(radians(-incidentAngleDeg));
  
  // 1. Refract at AB
  let refractDir1 = refractVector(incidentDir, normalOut, N_AIR, n_glass);
  
  // 2. Intersect with AC
  let AC = p5.Vector.sub(C, A);
  let hit = intersectLineLine(entryPoint, refractDir1, A, AC);
  
  if (hit) {
    // 3. Refract at AC
    let AB_vec = p5.Vector.sub(B, A);
    // Normal at AC. Points Right-Up.
    let normalAC = createVector(AC.y, -AC.x).normalize(); // Points Right-Up.
    
    // Refract out
    let refractDir2 = refractVector(refractDir1, p5.Vector.mult(normalAC, -1), n_glass, N_AIR);
    
    return {
      entry: entryPoint,
      incidentDir: incidentDir,
      exit: hit,
      exitDir: refractDir2
    };
  }
  return null;
}

function calculateRayHit(n, A, B, C, screenX) {
  let trace = calculateRayPath(n, A, B, C, screenX);
  if (trace && trace.exitDir.x > 0) {
    let t = (screenX - trace.exit.x) / trace.exitDir.x;
    let y = trace.exit.y + t * trace.exitDir.y;
    return createVector(screenX, y);
  }
  return null;
}

// Snell's Law
function refractVector(I, N, n1, n2) {
  let i = I.copy().normalize();
  let n = N.copy().normalize();
  let eta = n1 / n2;
  let cos_theta1 = - p5.Vector.dot(n, i);
  
  if (cos_theta1 < 0) {
    n.mult(-1);
    cos_theta1 = - p5.Vector.dot(n, i);
  }
  
  let k = 1 - eta * eta * (1 - cos_theta1 * cos_theta1);
  if (k < 0) return createVector(0,0); // TIR
  
  return p5.Vector.add(
    p5.Vector.mult(i, eta),
    p5.Vector.mult(n, eta * cos_theta1 - Math.sqrt(k))
  );
}

function intersectLineLine(P, D, A, AB) {
  let x1 = P.x, y1 = P.y;
  let x2 = P.x + D.x, y2 = P.y + D.y;
  let x3 = A.x, y3 = A.y;
  let x4 = A.x + AB.x, y4 = A.y + AB.y;
  
  let den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (den == 0) return null;
  
  let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
  let u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
  
  if (u > 0 && u < 1 && t > 0) {
    return createVector(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
  }
  return null;
}

function drawArrow(base, dir, col) {
  push();
  stroke(col);
  fill(col);
  translate(base.x + dir.x * 20, base.y + dir.y * 20);
  rotate(dir.heading());
  let s = 5;
  triangle(0, 0, -s, s/2, -s, -s/2);
  pop();
}

</script>
</body>
</html>