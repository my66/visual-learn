<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡ ä½•ç›´è§‚ï¼šç­‰è…°ä¸‰è§’å½¢â€œä¸‰çº¿åˆä¸€â€</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f4f8;
            color: #333;
            user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }
        .canvas-container {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
            cursor: crosshair;
        }
        .control-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .line-preview {
            width: 30px;
            height: 0;
            border-bottom-width: 2px;
            margin-right: 10px;
            display: inline-block;
        }
        /* è‡ªå®šä¹‰æ»‘å—å’Œå¤é€‰æ¡†æ ·å¼ç®€åŒ– */
        input[type="checkbox"] {
            accent-color: #3b82f6;
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .status-iso { background-color: #d1fae5; color: #065f46; }
        .status-scalene { background-color: #fee2e2; color: #991b1b; }
    </style>
</head>
<body class="h-screen flex flex-col md:flex-row p-4 gap-4">

    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <aside class="w-full md:w-80 flex-shrink-0 flex flex-col gap-4 overflow-y-auto">
        
        <!-- é¢˜ç›®/æ¦‚å¿µæè¿° -->
        <div class="control-panel">
            <h1 class="text-xl font-bold text-gray-800 mb-2">ä¸‰çº¿åˆä¸€äº’åŠ¨æ¼”ç¤º</h1>
            <p class="text-sm text-gray-600 mb-2">
                æ‹–åŠ¨é¡¶ç‚¹ <strong class="text-blue-600">A</strong>, <strong class="text-blue-600">B</strong>, æˆ– <strong class="text-blue-600">C</strong> æ”¹å˜ä¸‰è§’å½¢å½¢çŠ¶ã€‚è§‚å¯Ÿåº•è¾¹ BC ä¸Šçš„ä¸‰æ¡çº¿å¦‚ä½•å˜åŒ–ã€‚
            </p>
            <div class="bg-blue-50 p-2 rounded text-xs text-blue-800 border-l-4 border-blue-500">
                <strong>æ ¸å¿ƒå£è¯€ï¼š</strong><br>
                ç­‰è…°ä¸‰è§’å½¢ï¼Œæ€§è´¨çœŸå¥‡å¦™ã€‚<br>
                é¡¶ä¸Šç”»ä¸€ç¬”ï¼Œä¸‰çº¿å…¨æŠ¥åˆ°ã€‚<br>
                æ˜¯é«˜ä¹Ÿæ˜¯ä¸­ï¼Œè§’åˆ†è·‘ä¸æ‰ã€‚
            </div>
        </div>

        <!-- æ¨¡å¼æ§åˆ¶ -->
        <div class="control-panel">
            <h2 class="font-bold text-gray-700 mb-3 border-b pb-1">æ“ä½œæ¨¡å¼</h2>
            <div class="flex items-center justify-between mb-4">
                <label class="flex items-center cursor-pointer">
                    <input type="checkbox" id="toggleIso" onchange="toggleIsoscelesMode()">
                    <span class="font-medium">ğŸ”’ é”å®šä¸ºç­‰è…°ä¸‰è§’å½¢</span>
                </label>
            </div>
            <div class="text-xs text-gray-500">
                å‹¾é€‰åï¼Œé¡¶ç‚¹ A å°†åªèƒ½åœ¨ BC çš„ä¸­å‚çº¿ä¸Šç§»åŠ¨ï¼Œä¸‰çº¿å¼ºåˆ¶åˆä¸€ã€‚
            </div>
        </div>

        <!-- æ˜¾éšå¼€å…³ -->
        <div class="control-panel">
            <h2 class="font-bold text-gray-700 mb-3 border-b pb-1">æ˜¾ç¤ºå›¾å±‚</h2>
            
            <label class="legend-item cursor-pointer">
                <input type="checkbox" id="showAltitude" checked onchange="updateView()">
                <div class="line-preview" style="border-color: #ef4444; border-style: solid;"></div>
                <span>åº•è¾¹ä¸Šçš„é«˜ (ADâŠ¥BC)</span>
            </label>
            
            <label class="legend-item cursor-pointer">
                <input type="checkbox" id="showMedian" checked onchange="updateView()">
                <div class="line-preview" style="border-color: #3b82f6; border-style: dashed;"></div>
                <span>åº•è¾¹ä¸Šçš„ä¸­çº¿ (BD=DC)</span>
            </label>

            <label class="legend-item cursor-pointer">
                <input type="checkbox" id="showBisector" checked onchange="updateView()">
                <div class="line-preview" style="border-color: #10b981; border-style: dotted;"></div>
                <span>é¡¶è§’å¹³åˆ†çº¿ (âˆ 1=âˆ 2)</span>
            </label>

            <div class="mt-4 border-t pt-2">
                <label class="legend-item cursor-pointer">
                    <input type="checkbox" id="showAngleMarks" checked onchange="updateView()">
                    <span>æ˜¾ç¤ºè§’åº¦æ ‡æ³¨</span>
                </label>
                <label class="legend-item cursor-pointer">
                    <input type="checkbox" id="showLengthMarks" checked onchange="updateView()">
                    <span>æ˜¾ç¤ºé•¿åº¦/å‚ç›´æ ‡æ³¨</span>
                </label>
            </div>
        </div>

        <!-- æ•°æ®çŠ¶æ€ -->
        <div class="control-panel">
            <h2 class="font-bold text-gray-700 mb-2 border-b pb-1">å½“å‰çŠ¶æ€</h2>
            <div id="statusText" class="mb-2"></div>
            <div class="grid grid-cols-2 gap-2 text-sm font-mono">
                <div>AB = <span id="valAB"></span></div>
                <div>AC = <span id="valAC"></span></div>
                <div>âˆ B = <span id="valAngB"></span>Â°</div>
                <div>âˆ C = <span id="valAngC"></span>Â°</div>
            </div>
        </div>

    </aside>

    <!-- å³ä¾§å¯è§†åŒ–åŒºåŸŸ -->
    <main class="flex-grow h-full flex flex-col">
        <div class="canvas-container flex-grow h-full w-full" id="canvasWrapper">
            <canvas id="geometryCanvas"></canvas>
            <!-- æ‚¬æµ®æç¤º -->
            <div class="absolute top-2 right-2 bg-white/80 px-2 py-1 rounded text-xs text-gray-500 pointer-events-none">
                æ»šè½®ç¼©æ”¾ / æ‹–åŠ¨ç©ºç™½å¤„å¹³ç§» / æ‹–åŠ¨çº¢ç‚¹ä¿®æ”¹é¡¶ç‚¹
            </div>
        </div>
    </main>

<script>
/**
 * å‡ ä½•è®¡ç®—ä¸ç»˜å›¾é€»è¾‘
 */

const canvas = document.getElementById('geometryCanvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('canvasWrapper');

// çŠ¶æ€å˜é‡
let points = {
    A: { x: 0, y: -150 },
    B: { x: -120, y: 100 },
    C: { x: 120, y: 100 }
};

// è§†å£å˜æ¢
let offset = { x: 0, y: 0 };
let scale = 1;
let isDraggingPoint = null;
let isPanning = false;
let lastMouse = { x: 0, y: 0 };
let isIsoscelesLocked = false;

// é¢œè‰²é…ç½®
const COLORS = {
    triangle: '#1f2937',
    altitude: '#ef4444',
    median: '#3b82f6',
    bisector: '#10b981',
    point: '#dc2626',
    text: '#374151'
};

// åˆå§‹åŒ–
function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // äº‹ä»¶ç›‘å¬
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel);
    
    // åˆå§‹å±…ä¸­
    offset.x = canvas.width / 2;
    offset.y = canvas.height / 2;
    
    updateView();
}

function resizeCanvas() {
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åŠ è½½ï¼Œå±…ä¸­
    if (offset.x === 0 && offset.y === 0) {
        offset.x = canvas.width / 2;
        offset.y = canvas.height / 2;
    }
    updateView();
}

// æ ¸å¿ƒæ›´æ–°å‡½æ•°
function updateView() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);

    // 1. è®¡ç®—è¾…åŠ©ç‚¹ï¼ˆå‚è¶³ã€ä¸­ç‚¹ã€è§’å¹³åˆ†çº¿äº¤ç‚¹ï¼‰
    const feet = calculateFeet();

    // 2. ç»˜åˆ¶ä¸‰æ¡ç‰¹æ®Šçº¿ (æ ¹æ®å¼€å…³)
    const showAlt = document.getElementById('showAltitude').checked;
    const showMed = document.getElementById('showMedian').checked;
    const showBis = document.getElementById('showBisector').checked;

    // ä¸ºäº†é¿å…é‡åˆæ—¶çœ‹ä¸æ¸…ï¼Œå¦‚æœå®ƒä»¬ä½ç½®éå¸¸æ¥è¿‘ï¼Œç¨å¾®åšä¸€ç‚¹åç§»æˆ–è€…æ··åˆ
    // ä½†åœ¨æ•°å­¦è½¯ä»¶ä¸­ï¼Œç›´æ¥é‡å æ˜¯è¡¨è¾¾"åˆä¸€"æœ€ç›´æ¥çš„æ–¹å¼ã€‚
    // ä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬é‡‡ç”¨çº¿å®½å’Œè™šå®ç»“åˆ
    
    // ä¸­çº¿ (è“è‰²è™šçº¿) - æœ€åº•å±‚
    if (showMed) {
        drawLine(points.A, feet.median, COLORS.median, 3, [5, 5]);
    }
    // è§’å¹³åˆ†çº¿ (ç»¿è‰²ç‚¹çº¿) - ä¸­å±‚
    if (showBis) {
        drawLine(points.A, feet.bisector, COLORS.bisector, 2, [2, 4]);
    }
    // é«˜ (çº¢è‰²å®çº¿) - æœ€ä¸Šå±‚
    if (showAlt) {
        drawLine(points.A, feet.altitude, COLORS.altitude, 1.5, []);
    }

    // 3. ç»˜åˆ¶ä¸‰è§’å½¢ä¸»ä½“
    drawTriangle();

    // 4. ç»˜åˆ¶æ ‡æ³¨ (æ ¹æ®å¼€å…³)
    if (document.getElementById('showLengthMarks').checked) {
        drawLengthMarks(feet);
        drawRightAngleMark(feet.altitude, points.B, points.A);
    }
    if (document.getElementById('showAngleMarks').checked) {
        drawAngleMarks(feet);
    }

    // 5. ç»˜åˆ¶é¡¶ç‚¹
    drawPoint(points.A, 'A');
    drawPoint(points.B, 'B');
    drawPoint(points.C, 'C');

    // 6. ç»˜åˆ¶åº•è¾¹ä¸Šçš„ç‚¹æ ‡ç­¾ (D, E, F ç­‰ï¼Œå¦‚æœåˆ†å¼€çš„è¯)
    drawFeetLabels(feet, showAlt, showMed, showBis);

    ctx.restore();

    // æ›´æ–°é¢æ¿æ•°æ®
    updateInfoPanel();
}

// --- å‡ ä½•è®¡ç®— ---

function dist(p1, p2) {
    return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
}

function calculateFeet() {
    // å‘é‡ BC
    const dx = points.C.x - points.B.x;
    const dy = points.C.y - points.B.y;
    const lenBC = Math.sqrt(dx*dx + dy*dy);
    
    // 1. ä¸­ç‚¹ (Median Foot)
    const M = {
        x: (points.B.x + points.C.x) / 2,
        y: (points.B.y + points.C.y) / 2
    };

    // 2. å‚è¶³ (Altitude Foot) - æŠ•å½±
    // å‘é‡ BA
    const bax = points.A.x - points.B.x;
    const bay = points.A.y - points.B.y;
    // æŠ•å½±é•¿åº¦ t = (BA Â· BC) / |BC|^2
    const t = (bax * dx + bay * dy) / (lenBC * lenBC);
    const H = {
        x: points.B.x + t * dx,
        y: points.B.y + t * dy
    };

    // 3. è§’å¹³åˆ†çº¿äº¤ç‚¹ (Bisector Foot)
    // æ ¹æ®è§’å¹³åˆ†çº¿å®šç†ï¼š BD/DC = AB/AC
    const c = dist(points.A, points.B); // AB
    const b = dist(points.A, points.C); // AC
    const ratio = c / (b + c);
    const T = {
        x: points.B.x + ratio * dx,
        y: points.B.y + ratio * dy
    };

    return { median: M, altitude: H, bisector: T };
}

// --- ç»˜å›¾è¾…åŠ© ---

function drawLine(p1, p2, color, width, dash) {
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.setLineDash(dash);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawTriangle() {
    ctx.beginPath();
    ctx.moveTo(points.A.x, points.A.y);
    ctx.lineTo(points.B.x, points.B.y);
    ctx.lineTo(points.C.x, points.C.y);
    ctx.closePath();
    ctx.strokeStyle = COLORS.triangle;
    ctx.lineWidth = 2.5;
    ctx.stroke();
}

function drawPoint(p, label) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = COLORS.point;
    ctx.stroke();

    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 16px Arial';
    // ç®€å•çš„æ ‡ç­¾é¿è®©é€»è¾‘
    let dx = 0, dy = 0;
    if (label === 'A') { dy = -15; }
    else if (label === 'B') { dx = -15; dy = 15; }
    else if (label === 'C') { dx = 15; dy = 15; }
    ctx.fillText(label, p.x + dx, p.y + dy);
}

function drawFeetLabels(feet, showAlt, showMed, showBis) {
    ctx.font = '12px Arial';
    ctx.fillStyle = '#555';
    
    // ç®€å•çš„å»é‡é€»è¾‘ï¼Œå¦‚æœç‚¹å¾ˆè¿‘ï¼Œå°±ä¸é‡å¤ç”»
    const threshold = 10;
    
    let drawnPoints = [];

    const drawLabel = (p, text, color) => {
        // æ£€æŸ¥æ˜¯å¦é‡åˆ
        let isCoincided = false;
        for (let dp of drawnPoints) {
            if (dist(p, dp) < threshold) {
                isCoincided = true;
                break;
            }
        }
        
        ctx.fillStyle = color;
        if (!isCoincided) {
            ctx.fillText(text, p.x, p.y + 20);
            drawnPoints.push(p);
        } else {
            // å¦‚æœé‡åˆï¼Œåœ¨å·²ç”»ä½ç½®è¿½åŠ æ–‡æœ¬ä¼šå¾ˆä¹±ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼š
            // åªè¦ä¸‰çº¿åˆä¸€ï¼Œæˆ‘ä»¬å°±ä¸ä¸“é—¨æ ‡D,E,Fäº†ï¼Œå› ä¸ºå®ƒä»¬å°±æ˜¯ä¸€ä¸ªç‚¹
        }
    };

    // ä¼˜å…ˆç”»é«˜ï¼ˆé€šå¸¸é«˜æœ€é‡è¦ï¼‰
    if (showAlt) drawLabel(feet.altitude, 'H(å‚è¶³)', COLORS.altitude);
    if (showMed) drawLabel(feet.median, 'M(ä¸­ç‚¹)', COLORS.median);
    if (showBis) drawLabel(feet.bisector, 'T(äº¤ç‚¹)', COLORS.bisector);
}

function drawRightAngleMark(H, B, A) {
    // å‘é‡ HB
    let vHB = { x: B.x - H.x, y: B.y - H.y };
    const len = Math.sqrt(vHB.x**2 + vHB.y**2);
    if (len < 1) return; // é˜²æ­¢é™¤ä»¥0
    vHB.x /= len; vHB.y /= len;

    // å‘é‡ HA (æŒ‡å‘ä¸‰è§’å½¢å†…éƒ¨å¤§æ¦‚æ–¹å‘ï¼Œå…¶å®åªè¦å‚ç›´äºBCå³å¯)
    // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬è®¡ç®— BC çš„æ³•å‘é‡
    let vPerp = { x: -vHB.y, y: vHB.x };
    // ç¡®ä¿æŒ‡å‘ A æ‰€åœ¨çš„ä¸€ä¾§
    const vHA = { x: A.x - H.x, y: A.y - H.y };
    if (vPerp.x * vHA.x + vPerp.y * vHA.y < 0) {
        vPerp.x = -vPerp.x;
        vPerp.y = -vPerp.y;
    }

    const size = 10;
    ctx.beginPath();
    ctx.moveTo(H.x + vHB.x * size, H.y + vHB.y * size);
    ctx.lineTo(H.x + vHB.x * size + vPerp.x * size, H.y + vHB.y * size + vPerp.y * size);
    ctx.lineTo(H.x + vPerp.x * size, H.y + vPerp.y * size);
    ctx.strokeStyle = COLORS.altitude;
    ctx.lineWidth = 1;
    ctx.stroke();
}

function drawLengthMarks(feet) {
    // ä¸­çº¿æ ‡è®°ï¼šåœ¨ BM å’Œ MC ä¸Šç”»ä¸¤é“æ 
    const M = feet.median;
    if (document.getElementById('showMedian').checked) {
        drawTick(points.B, M, 2);
        drawTick(M, points.C, 2);
    }
}

function drawTick(p1, p2, count) {
    const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.sqrt(dx*dx + dy*dy);
    const nx = -dy / len * 5; // æ³•å‘é‡ï¼Œé•¿åº¦5
    const ny = dx / len * 5;
    
    ctx.beginPath();
    ctx.strokeStyle = COLORS.median;
    ctx.lineWidth = 1;
    
    for(let i=0; i<count; i++) {
        const offset = (i - (count-1)/2) * 4;
        const cx = mid.x + dx/len * offset;
        const cy = mid.y + dy/len * offset;
        ctx.moveTo(cx - nx, cy - ny);
        ctx.lineTo(cx + nx, cy + ny);
    }
    ctx.stroke();
}

function drawAngleMarks(feet) {
    // è§’å¹³åˆ†çº¿æ ‡è®°
    if (!document.getElementById('showBisector').checked) return;

    // å‘é‡ AB, AC
    const angleA_B = Math.atan2(points.B.y - points.A.y, points.B.x - points.A.x);
    const angleA_C = Math.atan2(points.C.y - points.A.y, points.C.x - points.A.x);
    const angleA_T = Math.atan2(feet.bisector.y - points.A.y, feet.bisector.x - points.A.x);

    const r = 30;
    
    ctx.beginPath();
    ctx.arc(points.A.x, points.A.y, r, angleA_B, angleA_T, false); // ç¬¬ä¸€åŠè§’
    ctx.strokeStyle = COLORS.bisector;
    ctx.stroke();
    // æ ‡è®°ç‚¹ 1
    // ...ç•¥å»å¤æ‚è®¡ç®—ï¼Œç®€å•ç¤ºæ„å³å¯
    
    ctx.beginPath();
    ctx.arc(points.A.x, points.A.y, r, angleA_T, angleA_C, false); // ç¬¬äºŒåŠè§’
    ctx.stroke();
    
    // æ–‡å­— 1, 2
    ctx.fillStyle = COLORS.bisector;
    ctx.font = '10px Arial';
    // ç²—ç•¥ä½ç½®
    ctx.fillText("1", points.A.x + Math.cos((angleA_B + angleA_T)/2)*r*1.2, points.A.y + Math.sin((angleA_B + angleA_T)/2)*r*1.2);
    ctx.fillText("2", points.A.x + Math.cos((angleA_C + angleA_T)/2)*r*1.2, points.A.y + Math.sin((angleA_C + angleA_T)/2)*r*1.2);
}

// --- äº¤äº’é€»è¾‘ ---

function screenToWorld(x, y) {
    return {
        x: (x - offset.x) / scale,
        y: (y - offset.y) / scale
    };
}

function checkHit(x, y) {
    const mouseP = screenToWorld(x, y);
    const threshold = 15 / scale;
    
    if (dist(mouseP, points.A) < threshold) return 'A';
    if (dist(mouseP, points.B) < threshold) return 'B';
    if (dist(mouseP, points.C) < threshold) return 'C';
    return null;
}

function onMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    lastMouse = { x, y };
    isDraggingPoint = checkHit(x, y);
    
    if (!isDraggingPoint) {
        isPanning = true;
        canvas.style.cursor = 'move';
    } else {
        canvas.style.cursor = 'none'; // æ‹–åŠ¨æ—¶éšè—é¼ æ ‡ï¼Œé˜²æ­¢é®æŒ¡
    }
}

function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const dx = x - lastMouse.x;
    const dy = y - lastMouse.y;
    lastMouse = { x, y };

    if (isDraggingPoint) {
        let p = points[isDraggingPoint];
        
        // æ‹–åŠ¨é€»è¾‘
        p.x += dx / scale;
        p.y += dy / scale;

        // å¦‚æœé”å®šäº†ç­‰è…°æ¨¡å¼
        if (isIsoscelesLocked) {
            applyIsoscelesConstraint(isDraggingPoint);
        }

        updateView();
    } else if (isPanning) {
        offset.x += dx;
        offset.y += dy;
        updateView();
    } else {
        // hover effect
        const hit = checkHit(x, y);
        canvas.style.cursor = hit ? 'pointer' : 'crosshair';
    }
}

function onMouseUp() {
    isDraggingPoint = null;
    isPanning = false;
    canvas.style.cursor = 'crosshair';
}

function onWheel(e) {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const zoom = Math.exp(wheel * zoomIntensity);
    
    scale *= zoom;
    updateView();
}

// --- ä¸šåŠ¡é€»è¾‘ ---

function toggleIsoscelesMode() {
    const cb = document.getElementById('toggleIso');
    isIsoscelesLocked = cb.checked;
    
    if (isIsoscelesLocked) {
        // ç«‹å³å¸é™„
        applyIsoscelesConstraint('FORCE');
        updateView();
    }
}

function applyIsoscelesConstraint(movedPointLabel) {
    // ç›®æ ‡ï¼šä¿æŒ AB = AC
    // çº¦æŸï¼šA å¿…é¡»åœ¨ BC çš„ä¸­å‚çº¿ä¸Š
    
    const midBC = { x: (points.B.x + points.C.x)/2, y: (points.B.y + points.C.y)/2 };
    
    // BCå‘é‡
    const vBC = { x: points.C.x - points.B.x, y: points.C.y - points.B.y };
    // ä¸­å‚çº¿æ–¹å‘å‘é‡ (æ—‹è½¬90åº¦)
    const vPerp = { x: -vBC.y, y: vBC.x };
    
    // å¦‚æœç§»åŠ¨çš„æ˜¯ A
    if (movedPointLabel === 'A' || movedPointLabel === 'FORCE') {
        // å°† A æŠ•å½±åˆ° BC çš„ä¸­å‚çº¿ä¸Š
        // çº¿ P = midBC + t * vPerp
        // å‘é‡ MA
        const vMA = { x: points.A.x - midBC.x, y: points.A.y - midBC.y };
        // æŠ•å½±é•¿åº¦
        const lenSq = vPerp.x*vPerp.x + vPerp.y*vPerp.y;
        if (lenSq === 0) return; // é‡åˆäº†
        const t = (vMA.x * vPerp.x + vMA.y * vPerp.y) / lenSq;
        
        points.A.x = midBC.x + t * vPerp.x;
        points.A.y = midBC.y + t * vPerp.y;
    } 
    // å¦‚æœç§»åŠ¨çš„æ˜¯ B æˆ– Cï¼ŒA ä¸åŠ¨ï¼Œæˆ‘ä»¬éœ€è¦è®© A ä¿æŒåœ¨ä¸­å‚çº¿ä¸Šï¼Ÿ
    // æˆ–è€…ï¼Œç§»åŠ¨ B æ—¶ï¼Œå¯¹ç§°ç§»åŠ¨ Cï¼Ÿ è¿™æ ·æ›´ç¬¦åˆç›´è§‰
    else if (movedPointLabel === 'B') {
        // ä¿æŒ A ä¸åŠ¨ï¼Œè®© C å¯¹ç§°è¿‡å»
        // é‡æ–°è®¡ç®— Cï¼Œä½¿å¾— A åœ¨ BC ä¸­å‚çº¿ä¸Š => dist(A,B) = dist(A,C)
        // ç®€å•çš„åšæ³•ï¼šä»¥ A-midBC ä¸ºè½´ï¼Œåš B çš„é•œåƒã€‚
        // ä½†è¿™æ ·äº¤äº’å¤ªè·³è·ƒã€‚
        // æ›´è‡ªç„¶çš„äº¤äº’ï¼šå½“é”å®šç­‰è…°æ—¶ï¼Œç§»åŠ¨ Bï¼ŒC ä¼šè‡ªåŠ¨é•œåƒç§»åŠ¨ï¼ˆç›¸å¯¹äºè¿‡ A çš„ç«–ç›´çº¿ï¼Œå¦‚æœä¸‰è§’å½¢æ˜¯ç«–ç›´æ”¾çš„ï¼‰
        
        // ä¸ºäº†ç®€åŒ–äº¤äº’ä½“éªŒï¼Œæˆ‘ä»¬å‡è®¾ A å§‹ç»ˆåœ¨ BC ä¸­å‚çº¿ä¸Šã€‚
        // å½“ç§»åŠ¨ B æ—¶ï¼Œæˆ‘ä»¬ä¿æŒ A ä¸åŠ¨ï¼Œé‡æ–°å®šä½ Cï¼Œä½¿å¾— C å…³äº A-H å¯¹ç§°ï¼Ÿ
        // ä¸ï¼Œæœ€ç®€å•çš„ç­–ç•¥ï¼š
        // 1. è®¡ç®— A åˆ° B çš„è·ç¦» R
        // 2. ä¿æŒ A ä¸åŠ¨
        // 3. è®¡ç®—å‘é‡ AB çš„è§’åº¦ï¼Œé•œåƒç®—å‡º AC çš„è§’åº¦?
        
        // é‡‡ç”¨æœ€ç¨³å¥çš„ç­–ç•¥ï¼šé•œåƒ B å…³äº A çš„å‚çº¿ï¼Ÿä¸ã€‚
        // ç­–ç•¥ï¼šç§»åŠ¨ B æ—¶ï¼ŒåŒæ—¶ç§»åŠ¨ Cï¼Œä½¿å®ƒä»¬å…³äº A çš„ç«–ç›´çº¿å¯¹ç§°ï¼ˆå‡è®¾åº•è¾¹æ°´å¹³ï¼‰ï¼Ÿ
        // ä¸ï¼Œæœ€é€šç”¨çš„ï¼š
        // ç§»åŠ¨ B åï¼Œä¿æŒ A ä¸åŠ¨ï¼Œç§»åŠ¨ C ä½¿å¾— AC = AB ä¸” BC å‚ç›´äº AHï¼Ÿè¿™ä¹Ÿå¤ªå¤æ‚ã€‚
        
        // ç®€åŒ–ç­–ç•¥ï¼šç§»åŠ¨ B æ—¶ï¼ŒC å¯¹ç§°ç§»åŠ¨ï¼ˆç›¸å¯¹äº A çš„å‚ç›´çº¿ï¼Œè¿™éšå«äº†å‡è®¾åº•è¾¹æ°´å¹³ï¼Œä¸å¤ªå¥½ï¼‰ã€‚
        // æ›´å¥½ç­–ç•¥ï¼šç§»åŠ¨ B æ—¶ï¼ŒA è‡ªåŠ¨è·³åˆ°æ–°çš„ BC ä¸­å‚çº¿ä¸Šã€‚
        applyIsoscelesConstraint('FORCE'); // å¤ç”¨ A çš„é€»è¾‘ï¼ŒæŠŠ A æ‹½è¿‡æ¥
    }
    else if (movedPointLabel === 'C') {
        applyIsoscelesConstraint('FORCE');
    }
}

function updateInfoPanel() {
    const lenAB = dist(points.A, points.B).toFixed(0);
    const lenAC = dist(points.A, points.C).toFixed(0);
    
    // è®¡ç®—è§’åº¦ (ä½¿ç”¨ä½™å¼¦å®šç†)
    const c = dist(points.A, points.B);
    const b = dist(points.A, points.C);
    const a = dist(points.B, points.C);
    
    const radB = Math.acos((a*a + c*c - b*b) / (2*a*c));
    const radC = Math.acos((a*a + b*b - c*c) / (2*a*b));
    
    const degB = (radB * 180 / Math.PI).toFixed(1);
    const degC = (radC * 180 / Math.PI).toFixed(1);
    
    document.getElementById('valAB').textContent = lenAB;
    document.getElementById('valAC').textContent = lenAC;
    document.getElementById('valAngB').textContent = degB;
    document.getElementById('valAngC').textContent = degC;

    const statusDiv = document.getElementById('statusText');
    const diff = Math.abs(lenAB - lenAC);
    
    if (diff < 1) {
        statusDiv.innerHTML = '<span class="status-badge status-iso">âœ“ ç­‰è…°ä¸‰è§’å½¢ (ä¸‰çº¿åˆä¸€)</span>';
        if (!isIsoscelesLocked) {
           // è‡ªåŠ¨å¸é™„æç¤ºæ•ˆæœ? ç®—äº†ï¼Œä¿æŒç®€å•
        }
    } else {
        statusDiv.innerHTML = '<span class="status-badge status-scalene">âœ• ä¸€èˆ¬ä¸‰è§’å½¢ (ä¸‰çº¿åˆ†ç¦»)</span>';
    }
}

// å¯åŠ¨
init();

</script>
</body>
</html>