<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆä¸­æ•°å­¦ï¼šæœ‰ç†æ•°å‡æ³•åŒæ¨¡å‹æ¼”ç¤º</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --c-pos: #27ae60; /* ç»¿è‰²ï¼šæ­£æ•°/å¢åŠ  */
            --c-neg: #c0392b; /* çº¢è‰²ï¼šè´Ÿæ•°/å‡å°‘ */
            --c-neutral: #2c3e50;
            --bg-balloon: #87CEEB;
            --bg-debt: #dcdde1;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-balloon);
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.5s;
        }
        
        body.mode-debt { background-color: var(--bg-debt); }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        #controls {
            width: 320px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            box-shadow: 2px 0 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
        }

        h1 {
            font-size: 18px;
            color: #2c3e50;
            margin: 0 0 10px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            text-align: center;
        }

        .mode-switch {
            display: flex;
            gap: 5px;
            background: #e9ecef;
            padding: 4px;
            border-radius: 8px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            background: transparent;
            color: #666;
            transition: all 0.2s;
        }
        
        .mode-btn.active {
            background: #fff;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        /* æ“ä½œæŒ‰é’®æ ·å¼ä¼˜åŒ– */
        button.op-btn {
            padding: 15px 10px;
            border: 2px solid transparent;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        button.op-btn:active { transform: scale(0.98); box-shadow: 0 2px 3px rgba(0,0,0,0.05); }

        /* é¢œè‰²å¯¹åº”ç³»ç»Ÿ */
        /* åŠ æ­£æ•°ï¼šç»¿è‰²åŠ å·ï¼Œç»¿è‰²æ•° */
        .btn-add-pos { border-color: var(--c-pos); color: var(--c-pos); }
        .btn-add-pos::before { content: ""; position: absolute; top:0; left:0; right:0; height: 4px; background: var(--c-pos); }
        
        /* å‡æ­£æ•°ï¼šçº¢è‰²å‡å·ï¼Œç»¿è‰²æ•° */
        .btn-sub-pos { border-color: var(--c-neg); color: #888; } 
        .btn-sub-pos span.math { color: var(--c-pos); } /* æ•°æœ¬èº«æ˜¯æ­£çš„ */
        .btn-sub-pos::before { content: ""; position: absolute; top:0; left:0; right:0; height: 4px; background: var(--c-neg); }

        /* åŠ è´Ÿæ•°ï¼šç»¿è‰²åŠ å·ï¼Œçº¢è‰²æ•° */
        .btn-add-neg { border-color: var(--c-pos); color: #888; }
        .btn-add-neg span.math { color: var(--c-neg); }
        .btn-add-neg::before { content: ""; position: absolute; top:0; left:0; right:0; height: 4px; background: var(--c-pos); }

        /* å‡è´Ÿæ•°ï¼šçº¢è‰²å‡å·ï¼Œçº¢è‰²æ•° (æ ¸å¿ƒ) */
        .btn-sub-neg { 
            grid-column: span 2; 
            border-color: var(--c-neg); 
            background: #fff5f5;
            color: var(--c-neg);
            font-size: 16px;
        }
        .btn-sub-neg span.math { color: var(--c-neg); font-weight: 900; font-size: 18px; }
        .btn-sub-neg::before { content: ""; position: absolute; top:0; left:0; right:0; height: 4px; background: var(--c-neg); }

        .btn-label { font-size: 12px; color: #666; margin-top: 4px; font-weight: normal; }

        /* å³ä¾§ç”»å¸ƒåŒºåŸŸ */
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        /* HUD ç®—å¼æ˜¾ç¤º (æ‚¬æµ®åœ¨ç”»å¸ƒä¸Šæ–¹) */
        #hud-equation {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 40px;
            border-radius: 50px;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 20;
            min-width: 300px;
            justify-content: center;
            border: 2px solid #fff;
        }
        
        /* ç®—å¼å†…çš„é¢œè‰²ç±» */
        .math-pos { color: var(--c-pos); }
        .math-neg { color: var(--c-neg); }
        .math-op { color: #555; margin: 0 5px; }
        .math-result { color: #2c3e50; border-bottom: 2px solid #2c3e50; }

        /* é‡ç½®æŒ‰é’® */
        .reset-btn {
            margin-top: auto;
            padding: 15px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .reset-btn:hover { background: #7f8c8d; }

    </style>
</head>
<body class="mode-balloon">

    <div id="controls">
        <h1>ğŸ”¢ æœ‰ç†æ•°è¿ç®—å¯è§†åŒ–</h1>
        
        <div class="mode-switch">
            <button class="mode-btn active" onclick="switchMode('balloon')">ğŸˆ çƒ­æ°”çƒæ¨¡å¼</button>
            <button class="mode-btn" onclick="switchMode('debt')">ğŸ’° èµ„äº§è´Ÿå€ºæ¨¡å¼</button>
        </div>

        <div style="flex:1; display:flex; flex-direction:column; justify-content:center;">
            <div class="btn-grid">
                <!-- å‡å»è´Ÿæ•° (æ ¸å¿ƒ) -->
                <button class="op-btn btn-sub-neg" id="btn-sub-neg" onclick="operate('-', -2)">
                    <div><span class="math">- (-2)</span></div>
                    <span class="btn-label" id="label-sub-neg">å‰ªæ–­æ²™è¢‹ -> è´Ÿè´Ÿå¾—æ­£</span>
                </button>

                <!-- åŠ ä¸Šæ­£æ•° -->
                <button class="op-btn btn-add-pos" id="btn-add-pos" onclick="operate('+', 2)">
                    <div><span class="math">+ (+2)</span></div>
                    <span class="btn-label" id="label-add-pos">å¢åŠ æ°”çƒ</span>
                </button>
                
                <!-- å‡å»æ­£æ•° -->
                <button class="op-btn btn-sub-pos" id="btn-sub-pos" onclick="operate('-', 2)">
                    <div><span class="math">- (+2)</span></div>
                    <span class="btn-label" id="label-sub-pos">æ°”çƒç ´äº†</span>
                </button>

                <!-- åŠ ä¸Šè´Ÿæ•° -->
                <button class="op-btn btn-add-neg" id="btn-add-neg" onclick="operate('+', -2)">
                    <div><span class="math">+ (-2)</span></div>
                    <span class="btn-label" id="label-add-neg">å¢åŠ æ²™è¢‹</span>
                </button>
            </div>
        </div>
        
        <div style="font-size:12px; color:#666; text-align:center; line-height:1.5;">
            è§‚å¯Ÿé¢œè‰²å¯¹åº”å…³ç³»ï¼š<br>
            <span style="color:var(--c-pos)">ç»¿è‰² = æ­£æ•°/æ°”çƒ/é‡‘å¸</span><br>
            <span style="color:var(--c-neg)">çº¢è‰² = è´Ÿæ•°/æ²™è¢‹/æ¬ æ¡</span>
        </div>

        <button class="reset-btn" onclick="resetSim()">ğŸ”„ é‡ç½® (Reset)</button>
    </div>

    <div id="canvas-wrapper">
        <div id="hud-equation">
            <span id="eq-content">Start: 0</span>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script>
        // --- æ ¸å¿ƒçŠ¶æ€ ---
        let mode = 'balloon'; 
        let currentVal = 0;
        let targetVal = 0;
        let items = []; // {type: 'pos'|'neg', x, y, state: 'idle'|'removed'}
        
        // p5.js å˜é‡
        let cloudPos = [];
        let camY = 0; // ç®€å•çš„æ‘„åƒæœºå‚ç›´åç§»

        function setup() {
            let canvas = createCanvas(windowWidth - 320, windowHeight);
            canvas.parent('canvas-container');
            
            // åˆå§‹åŒ–äº‘æœµ
            for(let i=0; i<8; i++) cloudPos.push({x: random(width), y: random(-height, height), s: random(0.5, 1.5)});
            
            initGame();
            updateEquationHUD(0); // åˆå§‹æ˜¾ç¤º
        }

        function windowResized() {
            resizeCanvas(windowWidth - 320, windowHeight);
        }

        function initGame() {
            currentVal = 0;
            targetVal = 0;
            items = [];
            
            // åˆå§‹å¹³è¡¡çŠ¶æ€ï¼š2æ­£2è´Ÿ
            // è¿™æ ·æ¼”ç¤ºâ€œå‡å»â€æ—¶æœ‰ä¸œè¥¿å¯å‡
            addItem('pos'); addItem('pos');
            addItem('neg'); addItem('neg');
        }

        function switchMode(m) {
            mode = m;
            document.body.className = mode === 'balloon' ? 'mode-balloon' : 'mode-debt';
            
            // æ›´æ–°æŒ‰é’®æ¿€æ´»æ€
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            // æ›´æ–°æ–‡æ¡ˆ
            if (mode === 'balloon') {
                document.getElementById('label-sub-neg').innerText = "å‰ªæ–­æ²™è¢‹ (å‡å»è´Ÿé‡)";
                document.getElementById('label-add-pos').innerText = "å¢åŠ æ°”çƒ (å¢åŠ æ‹‰åŠ›)";
                document.getElementById('label-sub-pos').innerText = "æ°”çƒç ´äº† (å‡å°‘æ‹‰åŠ›)";
                document.getElementById('label-add-neg').innerText = "å¢åŠ æ²™è¢‹ (å¢åŠ è´Ÿé‡)";
            } else {
                document.getElementById('label-sub-neg').innerText = "å…é™¤å€ºåŠ¡ (æ’•æ‰æ¬ æ¡)";
                document.getElementById('label-add-pos').innerText = "èµšå–é‡‘å¸ (å¢åŠ èµ„äº§)";
                document.getElementById('label-sub-pos').innerText = "æ¶ˆè´¹é‡‘å¸ (å‡å°‘èµ„äº§)";
                document.getElementById('label-add-neg').innerText = "ç­¾ä¸‹æ¬ æ¡ (å¢åŠ è´Ÿå€º)";
            }
            
            resetSim();
        }

        function resetSim() {
            initGame();
            updateEquationHUD(0);
        }

        // --- æ ¸å¿ƒé€»è¾‘ ---

        function operate(op, num) {
            let oldVal = targetVal;
            let change = (op === '+') ? num : -num;
            targetVal += change;

            // 1. æ›´æ–° HUD ç®—å¼ (Process Display)
            updateEquationHUD(oldVal, op, num);

            // 2. è§¦å‘è§†è§‰å˜åŒ–
            // é€»è¾‘ï¼šå¦‚æœæ˜¯å‡æ³•ï¼Œå°è¯•ç§»é™¤ç°æœ‰ç‰©ä½“ï¼›å¦‚æœæ˜¯åŠ æ³•ï¼Œæ·»åŠ æ–°ç‰©ä½“
            // ä¸ºäº†ç®€åŒ–æ¼”ç¤ºï¼Œå¦‚æœå‡æ³•ä½†æ²¡æœ‰å¯¹åº”ç‰©ä½“ï¼Œæˆ‘ä»¬å…ˆæ·»åŠ ä¸€ä¸ªâ€œå¹½çµâ€ç„¶åç§»é™¤ï¼Œæˆ–è€…åªåšæ•°å€¼å˜åŒ–
            // è¿™é‡Œä¸ºäº†è§†è§‰æ•ˆæœï¼Œç¡®ä¿å°½é‡æ“ä½œç°æœ‰ç‰©ä½“
            
            let typeNeeded = (num > 0) ? 'pos' : 'neg'; // æ•°å­—æœ¬èº«çš„æ€§è´¨
            
            if (op === '+') {
                // åŠ æ³•ï¼šå¢åŠ ç‰©ä½“
                addItem(typeNeeded, true); // true = animate entry
            } else {
                // å‡æ³•ï¼šç§»é™¤ç‰©ä½“
                let targets = items.filter(i => i.type === typeNeeded && i.state === 'idle');
                if (targets.length > 0) {
                    targets[0].state = 'removed';
                    targets[0].removeTimer = 0;
                } else {
                    // åœºæ™¯ä¸­æ²¡æœ‰è¯¥ç‰©ä½“ï¼Ÿç”Ÿæˆä¸€ä¸ªç„¶åç«‹åˆ»ç§»é™¤ï¼ˆä¸ºäº†é€»è¾‘è‡ªæ´½ï¼‰
                    // æ¯”å¦‚ 0 - (+2)ï¼Œæ²¡æ­£æ•°ã€‚å…ˆå‡è®¾æœ‰ä¸€ä¸ªæ­£æ•°è¢«æŠµæ¶ˆäº†ã€‚
                    // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç›´æ¥æ·»åŠ ä¸€ä¸ªå¤„äº 'removed' çŠ¶æ€çš„ç‰©ä½“æ¼”ç¤ºç¦»åœº
                    let it = addItem(typeNeeded);
                    it.state = 'removed';
                    it.removeTimer = 0;
                }
            }
        }

        function addItem(type, animateEntry = false) {
            let it = {
                type: type,
                id: random(1000),
                // éšæœºåˆ†å¸ƒåœ¨ç‰©ä½“å‘¨å›´
                ox: random(-40, 40), 
                oy: type === 'pos' ? random(-60, -100) : random(60, 100),
                state: 'idle',
                scale: animateEntry ? 0 : 1
            };
            items.push(it);
            return it;
        }

        function updateEquationHUD(start, op, num) {
            let el = document.getElementById('hud-equation');
            
            if (op === undefined) {
                // åˆå§‹çŠ¶æ€
                el.innerHTML = `<span class="math-result">${start}</span>`;
                return;
            }

            // æ„é€ å¸¦é¢œè‰²çš„ç®—å¼ HTML
            // 1. Start Value
            let html = `<span>${start}</span>`;
            
            // 2. Operator
            // å‡å·ç”¨çº¢è‰²ï¼ŒåŠ å·ç”¨ç»¿è‰²ï¼Œå¢å¼ºæš—ç¤º
            let opColor = (op === '-') ? 'var(--c-neg)' : 'var(--c-pos)';
            html += `<span class="math-op" style="color:${opColor}; font-weight:bold;">${op}</span>`;
            
            // 3. Number (Operand)
            let numColor = (num > 0) ? 'var(--c-pos)' : 'var(--c-neg)';
            let numText = num > 0 ? `(+${Math.abs(num)})` : `(-${Math.abs(num)})`;
            html += `<span style="color:${numColor}; font-weight:bold;">${numText}</span>`;
            
            // 4. Result (delayed show?) -> No, immediate feedback is better for equation logic
            // But visually updating the 'Start' value later.
            // Let's show:  0 - (-2) = 2
            
            let result = start + ((op === '+') ? num : -num);
            html += `<span> = </span><span class="math-result">${result}</span>`;
            
            el.innerHTML = html;
        }

        // --- ç»˜åˆ¶å¾ªç¯ ---

        function draw() {
            // å¹³æ»‘æ•°å€¼
            currentVal = lerp(currentVal, targetVal, 0.1);
            
            // èƒŒæ™¯
            if (mode === 'balloon') {
                background(135, 206, 235);
                drawClouds();
                drawRuler('m');
            } else {
                background(220);
                drawRuler('$');
            }

            // è®¡ç®—ç‰©ä½“ä¸­å¿ƒä½ç½®
            // æ°”çƒæ¨¡å¼ï¼šå€¼è¶Šå¤§ï¼ŒYè¶Šå°ï¼ˆå¾€ä¸Šé£ï¼‰
            // è´Ÿå€ºæ¨¡å¼ï¼šå€¼è¶Šå¤§ï¼ŒYè¶Šå°ï¼ˆæ°´ä½çº¿å‡é«˜/å­˜é’±ç½å˜é«˜ä»£è¡¨è´¢å¯Œç§¯ç´¯ï¼Ÿï¼‰
            // ç»Ÿä¸€ï¼šå±å¹•ä¸­å¿ƒä¸º 0ã€‚æ¯å•ä½ 30pxã€‚
            let centerY = height / 2;
            let objY = centerY - (currentVal * 30);
            
            // æ‘„åƒæœºè·Ÿéšï¼ˆå¦‚æœé£å¤ªé«˜ï¼‰
            let targetCamY = (height/2) - objY;
            camY = lerp(camY, targetCamY, 0.05);
            
            push();
            translate(width/2, objY + camY * 0.5); // 0.5 dampening for camera
            
            if (mode === 'balloon') drawBalloonObj();
            else drawDebtObj();

            pop();
        }

        function drawBalloonObj() {
            // ç»˜åˆ¶æ°”çƒä¸»ä½“
            fill(255, 100, 50);
            stroke(0); strokeWeight(2);
            // ç®€å•çš„æ°”çƒå½¢çŠ¶
            ellipse(0, -40, 90, 100);
            line(0, 10, -20, 50); // ç»³å­
            line(0, 10, 20, 50);
            
            // åŠç¯®
            fill(139, 69, 19);
            rect(-25, 50, 50, 40);
            
            // éšåŠ¨æ•°å€¼æ˜¾ç¤º (HUD on object)
            fill(255); noStroke();
            textAlign(CENTER, CENTER);
            textSize(16); textStyle(BOLD);
            text(Math.round(currentVal), 0, 70);
            textSize(10); text("é«˜åº¦", 0, 85);

            drawItems('balloon');
        }

        function drawDebtObj() {
            // ç»˜åˆ¶å­˜é’±ç½
            fill(255, 192, 203); // Pink
            stroke(0); strokeWeight(2);
            ellipse(0, 0, 120, 90); // Body
            ellipse(-50, -20, 30, 30); // Ear
            
            // çœ¼ç›
            fill(0); ellipse(-30, -10, 5, 5);
            
            // éšåŠ¨æ•°å€¼æ˜¾ç¤º
            fill(0); noStroke();
            textAlign(CENTER, CENTER);
            textSize(20); textStyle(BOLD);
            text("$" + Math.round(currentVal), 0, 5);
            textSize(10); text("èµ„äº§", 0, 25);

            drawItems('debt');
        }

        function drawItems(theme) {
            for (let i = items.length - 1; i >= 0; i--) {
                let it = items[i];
                
                // åŠ¨ç”»é€»è¾‘
                if (it.state === 'removed') {
                    it.removeTimer = (it.removeTimer || 0) + 1;
                    it.oy += 5; // ä¸‹è½
                    it.scale = max(0, 1 - it.removeTimer * 0.05); // ç¼©å°æ¶ˆå¤±
                    if (it.removeTimer > 60) {
                        items.splice(i, 1);
                        continue;
                    }
                } else if (it.scale < 1) {
                    it.scale += 0.1; // Entry animation
                }

                push();
                translate(it.ox, it.oy);
                scale(it.scale);
                
                // ç”»çº¿è¿æ¥
                if (it.state === 'idle') {
                    stroke(100); strokeWeight(1);
                    // è¿æ¥ç‚¹
                    let anchorY = (theme === 'balloon') ? 50 : 0; 
                    line(0, 0, -it.ox, anchorY - it.oy);
                }

                if (theme === 'balloon') {
                    if (it.type === 'pos') {
                        // ç»¿è‰²å°æ°”çƒ
                        fill(39, 174, 96); stroke(30); strokeWeight(1);
                        ellipse(0, -15, 25, 30);
                        fill(255); noStroke(); textSize(12); text("+1", -6, -12);
                    } else {
                        // çº¢è‰²æ²™è¢‹
                        fill(192, 57, 43); stroke(30); strokeWeight(1);
                        rect(-10, 0, 20, 25);
                        fill(255); noStroke(); textSize(12); text("-1", -5, 17);
                    }
                } else {
                    if (it.type === 'pos') {
                        // é‡‘å¸
                        fill(241, 196, 15); stroke(211, 84, 0); strokeWeight(2);
                        ellipse(0, 0, 30, 30);
                        fill(150, 100, 0); noStroke(); textSize(14); text("$", -4, 5);
                    } else {
                        // çº¢è‰²æ¬ æ¡
                        fill(255, 230, 230); stroke(192, 57, 43); strokeWeight(1);
                        rect(-15, -10, 30, 20);
                        fill(192, 57, 43); noStroke(); textSize(10); text("æ¬ ", -5, 4);
                        // æ’•è£‚æ•ˆæœ
                        if (it.state === 'removed') {
                            stroke(0); line(-15, -10, 15, 10);
                        }
                    }
                }
                pop();
            }
        }

        function drawClouds() {
            noStroke(); fill(255, 255, 255, 180);
            for(let c of cloudPos) {
                // Parallax scroll
                let y = c.y + camY * 0.2; 
                // wrap around
                if (y > height) y -= height * 2;
                if (y < -height) y += height * 2;
                ellipse(c.x, y, 60*c.s, 40*c.s);
            }
        }

        function drawRuler(unit) {
            // Draw a static ruler on the right
            let rx = width - 40;
            stroke(0, 50); strokeWeight(2);
            line(rx, 0, rx, height);
            
            // We need to draw ticks based on camera position
            // World Y = 0 is center of screen when camY = 0
            // World Y at screen Y:  screenY = worldY + height/2 + camY*0.5
            // So worldY = screenY - height/2 - camY*0.5
            
            // Iterate visible range
            let centerWorldY = -camY * 0.5;
            let startVal = Math.floor((centerWorldY - height/2) / -30) - 2;
            let endVal = Math.floor((centerWorldY + height/2) / -30) + 2;
            
            textAlign(RIGHT, CENTER); textSize(12); fill(100); noStroke();
            
            for(let v = startVal; v >= endVal; v--) {
                let y = (height/2) - (v * 30) + camY * 0.5;
                
                stroke(0, 50);
                line(rx-5, y, rx+5, y);
                if (v === 0) {
                    stroke(0, 100); strokeWeight(2);
                    line(rx-10, y, rx+10, y);
                }
                noStroke();
                text(v + unit, rx-10, y);
            }
        }
    </script>
</body>
</html>