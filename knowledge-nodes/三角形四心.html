<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰è§’å½¢çš„â€œå››å¿ƒâ€ä¸æ¬§æ‹‰çº¿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: "Inter", sans-serif; background-color: #f8fafc; }
        canvas { touch-action: none; cursor: crosshair; }
        .btn-mode {
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .btn-mode.active {
            background-color: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body class="h-screen flex flex-col items-center p-4 md:p-6 overflow-hidden">

    <header class="w-full max-w-4xl flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
        <div>
            <h1 class="text-2xl font-bold text-slate-800 flex items-center gap-2">
                <span class="text-blue-600">ğŸ“</span> ä¸‰è§’å½¢çš„å¥‡å¦™â€œå¿ƒâ€
            </h1>
            <p class="text-sm text-slate-500 mt-1">æ‹–åŠ¨ä¸‰è§’å½¢é¡¶ç‚¹ï¼Œè§‚å¯Ÿé‡å¿ƒçš„å˜åŒ–</p>
        </div>
        
        <div class="flex flex-wrap gap-2 bg-white p-2 rounded-lg shadow-sm border border-slate-200">
            <button class="btn-mode px-3 py-1.5 rounded text-sm text-slate-600 hover:bg-slate-50" onclick="setMode('centroid')">é‡å¿ƒ (ä¸­çº¿)</button>
            <button class="btn-mode px-3 py-1.5 rounded text-sm text-slate-600 hover:bg-slate-50" onclick="setMode('circumcenter')">å¤–å¿ƒ (ä¸­å‚çº¿)</button>
            <button class="btn-mode px-3 py-1.5 rounded text-sm text-slate-600 hover:bg-slate-50" onclick="setMode('incenter')">å†…å¿ƒ (è§’å¹³åˆ†çº¿)</button>
            <button class="btn-mode px-3 py-1.5 rounded text-sm text-slate-600 hover:bg-slate-50" onclick="setMode('orthocenter')">å‚å¿ƒ (é«˜çº¿)</button>
            <div class="w-px bg-slate-200 mx-1"></div>
            <button class="btn-mode px-3 py-1.5 rounded text-sm text-purple-600 hover:bg-purple-50" onclick="setMode('euler')">âœ¨ æ¬§æ‹‰çº¿</button>
        </div>
    </header>

    <div class="relative w-full max-w-4xl flex-1 bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden">
        <canvas id="geoCanvas" class="w-full h-full block"></canvas>
        
        <div id="info-card" class="absolute top-4 left-4 bg-white/90 backdrop-blur-sm p-4 rounded-xl border border-slate-100 shadow-lg max-w-xs pointer-events-none transition-all duration-300">
            <h3 id="info-title" class="font-bold text-slate-800 mb-2 text-lg">é‡å¿ƒ (Centroid)</h3>
            <p id="info-desc" class="text-sm text-slate-600 leading-relaxed">
                ä¸‰è§’å½¢ä¸‰æ¡<b>ä¸­çº¿</b>çš„äº¤ç‚¹ã€‚<br>
                å®ƒæ˜¯ä¸‰è§’å½¢çš„å‡ ä½•ä¸­å¿ƒï¼Œå°†æ¯æ¡ä¸­çº¿åˆ†ä¸º 2:1 çš„ä¸¤éƒ¨åˆ†ã€‚
            </p>
            <div id="legend-container" class="mt-3 text-xs text-slate-500 space-y-1"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // çŠ¶æ€
        let mode = 'centroid'; // centroid, circumcenter, incenter, orthocenter, euler
        let draggingPoint = null;

        // é¢œè‰²å®šä¹‰
        const COLORS = {
            triangle: '#334155', // slate-700
            fill: 'rgba(241, 245, 249, 0.5)', // slate-100
            vertex: '#3b82f6', // blue-500
            line_main: '#94a3b8', // slate-400 (è¾…åŠ©çº¿)
            center_dot: '#ef4444', // red-500
            euler_line: '#8b5cf6' // purple-500
        };

        // åˆå§‹ä¸‰è§’å½¢é¡¶ç‚¹ (ç›¸å¯¹åæ ‡ 0-1ï¼Œé€‚é… resize)
        const points = [
            { x: 0.5, y: 0.2 }, // A
            { x: 0.2, y: 0.8 }, // B
            { x: 0.8, y: 0.8 }  // C
        ];

        // --- åˆå§‹åŒ–ä¸äº‹ä»¶ ---

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        window.addEventListener('resize', resize);

        // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶å¤„ç† (æ”¯æŒæ‹–æ‹½)
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function isNear(p1, p2, dist = 20) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y) < dist;
        }

        canvas.addEventListener('mousedown', e => {
            const pos = getPos(e);
            // æ£€æŸ¥ç‚¹å‡»äº†å“ªä¸ªé¡¶ç‚¹
            const absPoints = points.map(p => ({ x: p.x * width, y: p.y * height }));
            const idx = absPoints.findIndex(p => isNear(pos, p));
            if (idx !== -1) draggingPoint = idx;
        });

        window.addEventListener('mousemove', e => {
            if (draggingPoint !== null) {
                const pos = getPos(e);
                // é™åˆ¶åœ¨ç”»å¸ƒå†…ï¼Œç•™ç‚¹è¾¹è·
                const padding = 20;
                points[draggingPoint].x = Math.max(padding/width, Math.min(1 - padding/width, pos.x / width));
                points[draggingPoint].y = Math.max(padding/height, Math.min(1 - padding/height, pos.y / height));
                draw();
            } else {
                // æ‚¬åœæ•ˆæœ
                const pos = getPos(e);
                const absPoints = points.map(p => ({ x: p.x * width, y: p.y * height }));
                const idx = absPoints.findIndex(p => isNear(pos, p));
                canvas.style.cursor = idx !== -1 ? 'move' : 'default';
            }
        });

        window.addEventListener('mouseup', () => draggingPoint = null);
        // ç®€å•çš„è§¦æ‘¸æ”¯æŒ
        canvas.addEventListener('touchstart', e => {
            const pos = getPos(e);
            const absPoints = points.map(p => ({ x: p.x * width, y: p.y * height }));
            const idx = absPoints.findIndex(p => isNear(pos, p));
            if (idx !== -1) { draggingPoint = idx; e.preventDefault(); }
        }, {passive: false});
        
        canvas.addEventListener('touchmove', e => {
            if (draggingPoint !== null) {
                const pos = getPos(e);
                e.preventDefault();
                const padding = 20;
                points[draggingPoint].x = Math.max(padding/width, Math.min(1 - padding/width, pos.x / width));
                points[draggingPoint].y = Math.max(padding/height, Math.min(1 - padding/height, pos.y / height));
                draw();
            }
        }, {passive: false});


        // --- å‡ ä½•è®¡ç®— ---

        // ç‚¹åŠ å‡ä¹˜
        const add = (p1, p2) => ({x: p1.x + p2.x, y: p1.y + p2.y});
        const sub = (p1, p2) => ({x: p1.x - p2.x, y: p1.y - p2.y});
        const mult = (p, s) => ({x: p.x * s, y: p.y * s});
        const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const mid = (p1, p2) => mult(add(p1, p2), 0.5);

        // è·å–ä¸‰è¾¹é•¿åº¦
        function getSides(A, B, C) {
            return {
                a: dist(B, C), // å¯¹åº”è§’Açš„è¾¹
                b: dist(A, C),
                c: dist(A, B)
            };
        }

        // 1. é‡å¿ƒ (Centroid) = (A+B+C)/3
        function getCentroid(A, B, C) {
            return { x: (A.x+B.x+C.x)/3, y: (A.y+B.y+C.y)/3 };
        }

        // 2. å¤–å¿ƒ (Circumcenter)
        function getCircumcenter(A, B, C) {
            const D = 2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
            const Ux = (1/D) * ((A.x**2 + A.y**2)*(B.y - C.y) + (B.x**2 + B.y**2)*(C.y - A.y) + (C.x**2 + C.y**2)*(A.y - B.y));
            const Uy = (1/D) * ((A.x**2 + A.y**2)*(C.x - B.x) + (B.x**2 + B.y**2)*(A.x - C.x) + (C.x**2 + C.y**2)*(B.x - A.x));
            return { x: Ux, y: Uy };
        }

        // 3. å†…å¿ƒ (Incenter) = (aA + bB + cC) / (a+b+c)
        function getIncenter(A, B, C) {
            const { a, b, c } = getSides(A, B, C);
            const P = a + b + c;
            return {
                x: (a*A.x + b*B.x + c*C.x) / P,
                y: (a*A.y + b*B.y + c*C.y) / P
            };
        }

        // 4. å‚å¿ƒ (Orthocenter)
        // åˆ©ç”¨æ¬§æ‹‰çº¿æ€§è´¨ï¼šH = 3G - 2O (Gé‡å¿ƒ, Oå¤–å¿ƒ) 
        // æˆ–è€…çŸ¢é‡æ³•ï¼šOH = OA + OB + OC (å¦‚æœOæ˜¯åŸç‚¹). è¿™é‡Œç›´æ¥ç”¨å‡ ä½•è§£æ³•å¤ªå¤æ‚ï¼Œç”¨æ¬§æ‹‰çº¿æ€§è´¨æœ€å¿«
        function getOrthocenter(A, B, C) {
            const G = getCentroid(A, B, C);
            const O = getCircumcenter(A, B, C);
            // Vector OG
            const vOG = sub(G, O);
            // OH = 3 * OG => H = O + 3*vOG
            return add(O, mult(vOG, 3));
        }

        // æ±‚å‚è¶³ (Projection of P onto line AB)
        function getProjection(P, A, B) {
            const vAB = sub(B, A);
            const vAP = sub(P, A);
            const len2 = vAB.x**2 + vAB.y**2;
            const dot = vAP.x*vAB.x + vAP.y*vAB.y;
            const t = dot / len2;
            return add(A, mult(vAB, t));
        }


        // --- ç»˜å›¾ ---

        function drawLine(p1, p2, color, dashed=false, width=1) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.setLineDash(dashed ? [5, 5] : []);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawDot(p, color, r=4) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawLabel(text, p, offset={x:0, y:-10}) {
            ctx.fillStyle = COLORS.triangle;
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(text, p.x + offset.x, p.y + offset.y);
        }

        function draw() {
            if (!width || !height) return;
            ctx.clearRect(0, 0, width, height);

            // è½¬æ¢ç»å¯¹åæ ‡
            const A = { x: points[0].x * width, y: points[0].y * height };
            const B = { x: points[1].x * width, y: points[1].y * height };
            const C = { x: points[2].x * width, y: points[2].y * height };

            // 1. ç»˜åˆ¶ä¸‰è§’å½¢åº•è‰²
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(B.x, B.y);
            ctx.lineTo(C.x, C.y);
            ctx.closePath();
            ctx.fillStyle = COLORS.fill;
            ctx.fill();
            ctx.strokeStyle = COLORS.triangle;
            ctx.lineWidth = 3;
            ctx.stroke();

            // ç»˜åˆ¶é¡¶ç‚¹æ ‡ç­¾
            drawLabel('A', A);
            drawLabel('B', B);
            drawLabel('C', C);

            // 2. æ ¹æ®æ¨¡å¼ç»˜åˆ¶è¾…åŠ©çº¿å’Œç‚¹
            if (mode === 'centroid') {
                const mA = mid(B, C);
                const mB = mid(A, C);
                const mC = mid(A, B);
                
                drawLine(A, mA, COLORS.line_main, true);
                drawLine(B, mB, COLORS.line_main, true);
                drawLine(C, mC, COLORS.line_main, true);
                
                const G = getCentroid(A, B, C);
                drawDot(G, COLORS.center_dot, 6);
                drawLabel('G (é‡å¿ƒ)', G, {x:0, y:20});

            } else if (mode === 'circumcenter') {
                const O = getCircumcenter(A, B, C);
                const R = dist(O, A);
                
                // ç»˜åˆ¶å¤–æ¥åœ†
                ctx.beginPath();
                ctx.arc(O.x, O.y, R, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç»˜åˆ¶ä¸­å‚çº¿ç¤ºæ„ (ä»å„è¾¹ä¸­ç‚¹è¿å‘åœ†å¿ƒ)
                drawLine(mid(B,C), O, COLORS.line_main, true);
                drawLine(mid(A,C), O, COLORS.line_main, true);
                drawLine(mid(A,B), O, COLORS.line_main, true);

                drawDot(O, COLORS.center_dot, 6);
                drawLabel('O (å¤–å¿ƒ)', O, {x:0, y:20});

            } else if (mode === 'incenter') {
                const I = getIncenter(A, B, C);
                // è®¡ç®—å†…åˆ‡åœ†åŠå¾„ (é¢ç§¯/åŠå‘¨é•¿)
                // Area using Heron's or coordinate formula
                const area = 0.5 * Math.abs(A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y));
                const sides = getSides(A,B,C);
                const p = (sides.a+sides.b+sides.c)/2;
                const r = area / p;

                // ç»˜åˆ¶å†…åˆ‡åœ†
                ctx.beginPath();
                ctx.arc(I.x, I.y, r, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();

                drawLine(A, I, COLORS.line_main, true);
                drawLine(B, I, COLORS.line_main, true);
                drawLine(C, I, COLORS.line_main, true);

                drawDot(I, COLORS.center_dot, 6);
                drawLabel('I (å†…å¿ƒ)', I, {x:0, y:20});

            } else if (mode === 'orthocenter') {
                const H = getOrthocenter(A, B, C);
                
                const pA = getProjection(A, B, C); // A on BC
                const pB = getProjection(B, A, C); // B on AC
                const pC = getProjection(C, A, B); // C on AB

                drawLine(A, pA, COLORS.line_main, true);
                drawLine(B, pB, COLORS.line_main, true);
                drawLine(C, pC, COLORS.line_main, true);

                drawDot(H, COLORS.center_dot, 6);
                drawLabel('H (å‚å¿ƒ)', H, {x:0, y:20});
            } else if (mode === 'euler') {
                const G = getCentroid(A, B, C);
                const O = getCircumcenter(A, B, C);
                const H = getOrthocenter(A, B, C);

                // æ¬§æ‹‰çº¿ç©¿è¿‡ O, G, H
                // ç»˜åˆ¶çº¿æ®µ
                drawLine(O, H, COLORS.euler_line, false, 3);

                drawDot(O, '#3b82f6', 5); // Blue
                drawDot(G, '#10b981', 5); // Green
                drawDot(H, '#ef4444', 5); // Red

                drawLabel('O', O, {x:10, y:-10});
                drawLabel('G', G, {x:10, y:-10});
                drawLabel('H', H, {x:10, y:-10});
            }

            // 3. ç»˜åˆ¶æ§åˆ¶ç‚¹ (æœ€åç»˜åˆ¶ï¼Œåœ¨æœ€ä¸Šå±‚)
            drawDot(A, COLORS.vertex, 8);
            drawDot(B, COLORS.vertex, 8);
            drawDot(C, COLORS.vertex, 8);
        }

        // --- UI é€»è¾‘ ---
        const infoMap = {
            centroid: { title: 'é‡å¿ƒ (Centroid)', desc: 'ä¸‰è§’å½¢ä¸‰æ¡<b>ä¸­çº¿</b>çš„äº¤ç‚¹ã€‚å®ƒæ˜¯ä¸‰è§’å½¢çš„ç‰©ç†å¹³è¡¡ç‚¹ï¼ˆå¦‚æœè´¨é‡å‡åŒ€ï¼‰ã€‚é‡å¿ƒå°†æ¯æ¡ä¸­çº¿åˆ†ä¸º 2:1ã€‚', legend: '' },
            circumcenter: { title: 'å¤–å¿ƒ (Circumcenter)', desc: 'ä¸‰è§’å½¢ä¸‰æ¡è¾¹çš„<b>å‚ç›´å¹³åˆ†çº¿</b>çš„äº¤ç‚¹ã€‚å®ƒæ˜¯å¤–æ¥åœ†çš„åœ†å¿ƒï¼Œåˆ°ä¸‰ä¸ªé¡¶ç‚¹çš„è·ç¦»ç›¸ç­‰ã€‚é”è§’ä¸‰è§’å½¢åœ¨å†…éƒ¨ï¼Œé’è§’ä¸‰è§’å½¢åœ¨å¤–éƒ¨ã€‚', legend: '' },
            incenter: { title: 'å†…å¿ƒ (Incenter)', desc: 'ä¸‰è§’å½¢ä¸‰ä¸ªå†…è§’çš„<b>è§’å¹³åˆ†çº¿</b>çš„äº¤ç‚¹ã€‚å®ƒæ˜¯å†…åˆ‡åœ†çš„åœ†å¿ƒï¼Œåˆ°ä¸‰æ¡è¾¹çš„è·ç¦»ç›¸ç­‰ã€‚å®ƒæ°¸è¿œåœ¨ä¸‰è§’å½¢å†…éƒ¨ã€‚', legend: '' },
            orthocenter: { title: 'å‚å¿ƒ (Orthocenter)', desc: 'ä¸‰è§’å½¢ä¸‰æ¡<b>é«˜çº¿</b>çš„äº¤ç‚¹ã€‚é”è§’ä¸‰è§’å½¢åœ¨å†…éƒ¨ï¼Œç›´è§’ä¸‰è§’å½¢åœ¨ç›´è§’é¡¶ç‚¹ï¼Œé’è§’ä¸‰è§’å½¢åœ¨å¤–éƒ¨ã€‚', legend: '' },
            euler: { title: 'æ¬§æ‹‰çº¿ (Euler Line)', desc: 'åœ¨ä»»æ„ä¸‰è§’å½¢ä¸­ï¼Œ<b>å¤–å¿ƒã€é‡å¿ƒã€å‚å¿ƒ</b>æ€»æ˜¯å…±çº¿çš„ï¼è¿™æ¡ç¥å¥‡çš„çº¿è¢«ç§°ä¸ºæ¬§æ‹‰çº¿ã€‚ï¼ˆæ³¨ï¼šæ­£ä¸‰è§’å½¢ä¸‰å¿ƒåˆä¸€ï¼Œæ¬§æ‹‰çº¿ä¸ºä¸€ä¸ªç‚¹ï¼‰', legend: '<span class="legend-dot bg-blue-500"></span>å¤–å¿ƒ <span class="legend-dot bg-green-500"></span>é‡å¿ƒ <span class="legend-dot bg-red-500"></span>å‚å¿ƒ' }
        };

        window.setMode = function(m) {
            mode = m;
            // Update Buttons
            document.querySelectorAll('.btn-mode').forEach(btn => {
                if(btn.getAttribute('onclick').includes(m)) btn.classList.add('active');
                else btn.classList.remove('active');
            });
            
            // Update Info
            const info = infoMap[m];
            document.getElementById('info-title').innerHTML = info.title;
            document.getElementById('info-desc').innerHTML = info.desc;
            document.getElementById('legend-container').innerHTML = info.legend || '';

            draw();
        }

        // å¯åŠ¨
        setMode('centroid');
        resize(); // Initial draw

    </script>
</body>
</html>