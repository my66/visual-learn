<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>凹面镜聚焦原理与切线可视化</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-color: #f4f6f9;
            --panel-bg: #ffffff;
            --text-color: #333333;
            --accent-color: #2196F3;
            --border-color: #e0e0e0;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "SF Pro SC", "HanHei SC", "Microsoft YaHei", sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden; /* 防止整体滚动，内部滚动 */
            display: flex;
            flex-direction: column;
        }

        /* 顶部标题栏 */
        header {
            background-color: var(--panel-bg);
            padding: 15px 30px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: #1a1a1a;
        }

        .subtitle {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* 主布局容器 */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: 100%;
        }

        /* 左侧控制面板 */
        .controls {
            width: 320px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.02);
        }

        /* 控件组 */
        .control-group {
            background: #fafafa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .control-group h3 {
            margin: 0 0 12px 0;
            font-size: 15px;
            color: #444;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 5px;
            display: inline-block;
        }

        /* 滑块样式 */
        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        /* 开关样式 */
        .toggle-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .toggle-row input {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: var(--accent-color);
            cursor: pointer;
        }

        .toggle-row span {
            font-size: 14px;
        }

        /* 说明区域 */
        .info-box {
            font-size: 13px;
            line-height: 1.6;
            color: #555;
            background: #eef7fe;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid var(--accent-color);
        }

        .info-box ul {
            padding-left: 20px;
            margin: 5px 0 0 0;
        }

        /* 右侧画布区域 */
        .canvas-wrapper {
            flex: 1;
            position: relative;
            background-color: #ffffff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 画布自适应 */
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
        }

        /* 状态覆盖层 */
        .status-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 12px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* 移动端/小屏提示 */
        @media (max-width: 1000px) {
            .controls { width: 260px; }
            h1 { font-size: 16px; }
        }
    </style>
</head>
<body>

    <header>
        <div>
            <h1>凹面镜聚焦与切线可视化</h1>
            <div class="subtitle">Interactive Physics: Concave Mirror Reflection & Tangents</div>
        </div>
        <div style="font-size: 12px; color: #888;">
            设计：STEM Visualization Architect
        </div>
    </header>

    <div class="main-container">
        <!-- 控制面板 -->
        <div class="controls">
            
            <div class="info-box">
                <strong>观察指南：</strong>
                <p>本模拟展示平行光（如太阳光）射入凹面镜时的反射路径。</p>
                <ul>
                    <li><strong>切线 (灰色)：</strong> 光线接触镜面瞬间，镜面可视为平面。</li>
                    <li><strong>法线 (虚线)：</strong> 始终垂直于切线。反射遵循“反射角=入射角”。</li>
                    <li><strong>曲率：</strong> 调整镜面弯曲程度，观察焦点位置变化。</li>
                </ul>
            </div>

            <div class="control-group">
                <h3>镜面参数</h3>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>镜面曲率 (弯曲程度)</span>
                        <span id="curvature-val">中</span>
                    </div>
                    <input type="range" id="curvature-slider" min="0.001" max="0.015" step="0.001" value="0.008">
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>光线数量</span>
                        <span id="ray-count-val">12</span>
                    </div>
                    <input type="range" id="ray-slider" min="2" max="30" step="2" value="12">
                </div>
            </div>

            <div class="control-group">
                <h3>可视化开关</h3>
                
                <label class="toggle-row">
                    <input type="checkbox" id="show-tangent" checked>
                    <span>显示切线 (Tangent)</span>
                </label>
                
                <label class="toggle-row">
                    <input type="checkbox" id="show-normal" checked>
                    <span>显示法线 (Normal)</span>
                </label>
                
                <label class="toggle-row">
                    <input type="checkbox" id="show-focus" checked>
                    <span>显示焦点 (Focus)</span>
                </label>

                <label class="toggle-row">
                    <input type="checkbox" id="show-extended" >
                    <span>显示反向延长线</span>
                </label>
            </div>

            <div class="control-group">
                <h3>重置与控制</h3>
                <div style="display: flex; gap: 10px;">
                    <button onclick="resetSim()" style="flex:1; padding: 8px; cursor: pointer; background:#fff; border:1px solid #ccc; border-radius:4px;">重置默认</button>
                </div>
            </div>

        </div>

        <!-- 画布区域 -->
        <div class="canvas-wrapper" id="canvas-container">
            <div class="status-overlay" id="status-display">
                准备就绪
            </div>
        </div>
    </div>

    <script>
        // --- 变量定义 ---
        let curvatureSlider, raySlider;
        let showTangentCheck, showNormalCheck, showFocusCheck, showExtendedCheck;
        let curvatureValDisplay, rayValDisplay, statusDisplay;

        // 物理/几何参数
        // 抛物线方程: y = k * x^2 (顶点在原点)
        // 实际绘制时，为了让镜面朝上(像碗一样接雨水)，我们会翻转坐标或调整系数
        // p5坐标系: y 向下增加。
        // 我们将原点设在屏幕下半部分中心。
        // 镜面方程: y_pixel = -k * x_pixel^2 (开口向上，因为y向上是负)
        let k = 0.005; 
        let rays = [];
        let mirrorWidth = 600; // 镜面水平投影宽度

        function setup() {
            // 创建画布
            const container = document.getElementById('canvas-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const canvas = createCanvas(w, h);
            canvas.parent(container);

            // 获取DOM元素
            curvatureSlider = document.getElementById('curvature-slider');
            raySlider = document.getElementById('ray-slider');
            showTangentCheck = document.getElementById('show-tangent');
            showNormalCheck = document.getElementById('show-normal');
            showFocusCheck = document.getElementById('show-focus');
            showExtendedCheck = document.getElementById('show-extended');
            
            curvatureValDisplay = document.getElementById('curvature-val');
            rayValDisplay = document.getElementById('ray-count-val');
            statusDisplay = document.getElementById('status-display');

            // 初始化设置
            textSize(14);
            textAlign(LEFT, CENTER);
        }

        function windowResized() {
            const container = document.getElementById('canvas-container');
            resizeCanvas(container.clientWidth, container.clientHeight);
        }

        function draw() {
            background(255);

            // --- 1. 更新参数 ---
            k = parseFloat(curvatureSlider.value);
            let rayCount = parseInt(raySlider.value);

            // 更新UI数值显示
            updateLabels(k, rayCount);

            // --- 2. 坐标系变换 ---
            // 移动原点到屏幕底部中央偏上一点，作为抛物线的顶点
            // 注意：p5中y向下为正。为了符合直觉（光从上下来，镜子在下面），
            // 我们设定镜子顶点在 (width/2, height - 100)
            // 抛物线开口向上，即 y 随 |x| 增加而减小（走向屏幕上方）
            // 所以方程: y_local = -k * x_local^2
            
            push();
            translate(width / 2, height - 100);

            // --- 3. 计算焦点 ---
            // 抛物线 y = ax^2 的焦点距离顶点 f = 1 / (4a)
            // 这里我们用像素作为单位
            let f = 1 / (4 * k);
            let focusPos = createVector(0, -f); // 焦点在顶点上方 f 处

            // --- 4. 绘制焦点 (如果开启) ---
            if (showFocusCheck.checked) {
                noStroke();
                fill(255, 50, 50);
                circle(focusPos.x, focusPos.y, 12);
                
                fill(200, 0, 0);
                textAlign(LEFT, CENTER);
                text("焦点 F", focusPos.x + 10, focusPos.y);
                
                // 标注焦距
                if (k > 0.002) { // 只有曲率够大才画焦距线，避免太长
                    stroke(200, 0, 0, 100);
                    strokeWeight(1);
                    line(0, 0, 0, -f + 6);
                    noStroke();
                    fill(150, 50, 50);
                    textSize(12);
                    textAlign(RIGHT, CENTER);
                    text(`f = ${Math.round(f)}px`, -5, -f/2);
                }
            }

            // --- 5. 绘制镜面 (抛物线) ---
            noFill();
            stroke(33, 150, 243);
            strokeWeight(4);
            beginShape();
            // 动态计算镜面宽度，避免超出屏幕
            let halfW = min(width/2 - 20, mirrorWidth/2);
            for (let x = -halfW; x <= halfW; x += 5) {
                let y = -k * x * x;
                vertex(x, y);
            }
            endShape();
            
            // 镜面文字标注
            noStroke();
            fill(33, 150, 243);
            textAlign(CENTER, TOP);
            text("凹面镜 (抛物面)", 0, 10);

            // --- 6. 绘制光线系统 ---
            // 太阳光：平行光，垂直向下，即方向向量 (0, 1)
            // 我们需要计算光线与抛物线的交点。
            // 设光线横坐标为 x0。交点即为 (x0, -k * x0^2)
            
            let spacing = (halfW * 2 * 0.8) / (rayCount - 1);
            if (rayCount <= 1) spacing = 0; // 避免除零

            // 绘制主光轴 (中心虚线)
            stroke(100, 100, 100, 80);
            strokeWeight(1);
            setLineDash([5, 5]);
            line(0, -height, 0, 20);
            setLineDash([]); // Reset

            for (let i = 0; i < rayCount; i++) {
                // 计算当前光线的 x 坐标
                // 分布在镜面宽度的 80% 范围内
                let x0;
                if (rayCount === 1) x0 = 0;
                else x0 = -halfW * 0.8 + i * spacing;

                // 避免正中心的光线与主光轴重叠看不清，微调一点点或者不处理
                // 这里保留正中心光线，因为它展示了垂直入射原路返回

                let y0 = -k * x0 * x0; // 交点 Y
                let p = createVector(x0, y0);

                // A. 绘制入射光线 (从屏幕顶端射到交点)
                stroke(255, 165, 0, 200); // 橙色
                strokeWeight(2);
                // 起点在很高的地方
                let startY = -height + 100; // 相对坐标
                // 箭头画在中间
                drawRayWithArrow(x0, startY, x0, y0, 255, 165, 0);

                // --- 核心数学计算 ---
                // 曲线方程: f(x) = -k * x^2
                // 导数 (切线斜率): f'(x) = -2 * k * x
                // 切线向量: (1, f'(x)) = (1, -2kx)
                // 法线斜率: -1 / f'(x) (如果切线水平，法线垂直)
                // 更简单的方法是利用向量。
                // 切线向量 T = (1, -2*k*x0)。归一化。
                let tangent = createVector(1, -2 * k * x0).normalize();
                
                // 法线向量 N。法线垂直于切线。
                // 二维向量 (a, b) 的垂直向量是 (-b, a) 或 (b, -a)。
                // 抛物线开口向上，法线应该指向凹面“内部”（即上方）。
                // T 指向右侧时（x增），(-2kx)是y分量。
                // 在左侧 (x<0)，斜率正，T指向右上。
                // 法线应该指向右上方（指向主轴）。
                // 让我们用简单的几何直觉：法线 N 垂直 T。
                // 且 N 应该朝向焦点一侧。
                // 方法：计算 N = (-dy, dx) = (2kx, 1)。
                // 验证：当 x=0, N=(0,1) 指向正上方（焦点方向）。正确。
                let normal = createVector(2 * k * x0, 1).normalize();

                // B. 绘制切线 (Tangent) - 如果开启
                if (showTangentCheck.checked) {
                    stroke(100, 100, 100, 150); // 灰色
                    strokeWeight(1);
                    let tanLen = 60; // 切线显示长度
                    line(p.x - tangent.x * tanLen, p.y - tangent.y * tanLen, 
                         p.x + tangent.x * tanLen, p.y + tangent.y * tanLen);
                    
                    // 仅在第一条光线处标注文字，避免混乱
                    if (i === rayCount - 1 && x0 !== 0) {
                        fill(80);
                        noStroke();
                        textSize(10);
                        text("切线", p.x + tangent.x * tanLen, p.y + tangent.y * tanLen);
                    }
                }

                // C. 绘制法线 (Normal) - 如果开启
                if (showNormalCheck.checked) {
                    stroke(0, 150, 255, 150); // 蓝色
                    strokeWeight(1.5);
                    setLineDash([3, 3]);
                    let normLen = 50;
                    line(p.x, p.y, p.x + normal.x * normLen, p.y + normal.y * normLen);
                    
                    // 绘制垂足标记 (切线与法线垂直)
                    if (x0 !== 0) {
                       drawRightAngle(p, tangent, normal, 8);
                    }
                    
                    setLineDash([]);

                     // 仅在最后一条光线标注
                    if (i === rayCount - 1 && x0 !== 0) {
                        fill(0, 150, 255);
                        noStroke();
                        textSize(10);
                        text("法线", p.x + normal.x * normLen, p.y + normal.y * normLen);
                    }
                }

                // D. 计算反射光线
                // 入射向量 I = (0, -1) (因为是从上往下射，但在计算反射时，
                // 通常定义入射向量指向入射点。这里光线向下，向量 (0, 1)。
                // 这里的坐标系y向下为正吗？不，我们translate了。
                // 我们在p5默认坐标系绘图。Translate只是移动原点。
                // p5坐标系中，y向下增加。
                // 我们的抛物线是 y_local = -k*x^2 (p5坐标数值上是负的，即屏幕上方)
                // 等等，我们在translate(w/2, h-100)。y_pixel = -k*x^2。
                // 如果 k=0.01, x=10, y=-1。即点在原点上方1像素。
                // 光线从上方射入，也就是从 y_local = -large 射向 y_local = curve。
                // 入射方向向量 Incident = (0, 1) (向下，y增加方向)。
                
                let incomingDir = createVector(0, 1);
                
                // 反射公式: R = I - 2 * (I · N) * N
                // 注意：公式中 I 和 N 的方向定义很重要。
                // 如果 I 指向表面，N 指向外部：
                // R = I - 2(I·N)N.
                // 我们之前定义的 Normal 是 (2kx, 1)，指向“上方/内部”（y减小? 不，y增加?）
                // 让我们重新检查 Normal 方向。
                // p5坐标系：y向下为正。
                // 顶点在屏幕下方。抛物线向屏幕上方延伸（y值变小）。
                // 所以 y = -k*x^2。
                // 法线应该指向“碗内”。碗口朝上（屏幕上方）。
                // 所以法线应该指向 y 负方向。
                // 之前的 normal = (2kx, 1)。当x=0, n=(0,1) 指向下方（y正）。
                // 这意味着法线指向“碗底外部”。
                // 纠正：法线应该指向光线来源的一侧（反射面侧）。
                // 光从上方来，法线应该指向上方。
                // 所以 Normal 应为 (-2kx, -1) 或之前的相反。
                // 或者直接用公式时注意符号。
                // 让我们修正法线方向：指向反射发生的一侧（上方，y负）。
                // N = (-2kx, -1).normalize()。
                
                let validNormal = createVector(-2 * k * x0, -1).normalize();
                
                // 计算反射向量
                let dotProd = incomingDir.dot(validNormal);
                let reflectDir = p5.Vector.sub(incomingDir, p5.Vector.mult(validNormal, 2 * dotProd));
                
                // E. 绘制反射光线
                stroke(255, 165, 0); // 橙色
                strokeWeight(2);
                
                // 反射光线长度：足够长以穿过焦点
                // 如果是抛物面，它一定经过焦点 (0, -f)
                // 我们直接画到焦点，然后再延长一点
                
                // 为了视觉验证物理计算的正确性，我不强制它画到焦点，
                // 而是画出计算出的向量，看它是否真的经过焦点。
                let reflectLen = height; 
                line(p.x, p.y, p.x + reflectDir.x * reflectLen, p.y + reflectDir.y * reflectLen);

                // 反向延长线 (虚像辅助) - 凹面镜成实像时通常不需要，但如果用户想看光线走向
                if (showExtendedCheck.checked) {
                    stroke(255, 165, 0, 50);
                    setLineDash([5, 5]);
                    line(p.x, p.y, p.x - reflectDir.x * reflectLen, p.y - reflectDir.y * reflectLen);
                    setLineDash([]);
                }
            }

            pop();
        }

        // --- 辅助函数 ---

        function drawRayWithArrow(x1, y1, x2, y2, r, g, b) {
            line(x1, y1, x2, y2);
            // 箭头在中点
            let mx = (x1 + x2) / 2;
            let my = (y1 + y2) / 2;
            // 因为是垂直向下的光，箭头很简单
            push();
            translate(mx, my);
            fill(r, g, b);
            noStroke();
            triangle(-4, -4, 4, -4, 0, 4); // 向下的箭头
            pop();
        }

        // 绘制直角标记
        function drawRightAngle(origin, v1, v2, size) {
            // v1, v2 是归一化向量
            let p1 = p5.Vector.mult(v1, size);
            let p2 = p5.Vector.mult(v2, size);
            let p3 = p5.Vector.add(p1, p2);
            
            stroke(100, 100, 100, 100);
            strokeWeight(1);
            noFill();
            beginShape();
            vertex(origin.x + p1.x, origin.y + p1.y);
            vertex(origin.x + p3.x, origin.y + p3.y);
            vertex(origin.x + p2.x, origin.y + p2.y);
            endShape();
        }

        function setLineDash(list) {
            drawingContext.setLineDash(list);
        }

        function updateLabels(kVal, rCount) {
            // 简单的曲率文字描述
            let desc = "中等";
            if (kVal < 0.003) desc = "接近平面";
            else if (kVal > 0.01) desc = "深凹";
            
            curvatureValDisplay.innerText = desc + ` (k=${kVal})`;
            rayValDisplay.innerText = rCount;

            // 更新状态栏
            let f = Math.round(1/(4*k));
            statusDisplay.innerHTML = `
                焦距 f ≈ ${f} px<br>
                <span style="color:#666">光线平行于主轴入射，反射线必过焦点</span>
            `;
        }

        function resetSim() {
            curvatureSlider.value = 0.008;
            raySlider.value = 12;
            showTangentCheck.checked = true;
            showNormalCheck.checked = true;
            showFocusCheck.checked = true;
            showExtendedCheck.checked = false;
        }

    </script>
</body>
</html>