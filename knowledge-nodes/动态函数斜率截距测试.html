<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆäºŒæ•°å­¦ï¼šä¸€æ¬¡å‡½æ•°åŠ¨æ€å»ºæ¨¡ç»ƒä¹ åœº</title>
    
    <!-- å¼•å…¥ React å’Œ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- å¼•å…¥ Babel ç”¨äºè§£æ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- ç®€å•çš„è‡ªå®šä¹‰æ ·å¼ -->
    <style>
        body {
            touch-action: manipulation; /* ä¼˜åŒ–è§¦å±ä½“éªŒ */
        }
        /* éšè—æ»šåŠ¨æ¡ä½†å…è®¸æ»šåŠ¨ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- å›¾æ ‡ç»„ä»¶ (å†…è” SVG ä»¥æ›¿ä»£ lucide-react åº“) ---
        const Activity = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
        );
        const Play = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"/></svg>
        );
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        );
        const CheckCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
        );
        const AlertCircle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
        );
        const MousePointer2 = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m12 6.246 1.134.623a7 7 0 0 0 3.483 1.131h2.155a3 3 0 0 1 2.872 3.82L19.24 19.56a4 4 0 0 1-3.766 2.44H7a4 4 0 0 1-4-4V11a4 4 0 0 1 4-4h.246"/></svg>
        );

        // --- é€»è¾‘ä»£ç å¼€å§‹ ---

        /**
         * æ•°å­¦é€»è¾‘æ ¸å¿ƒï¼šè§£æç”¨æˆ·è¾“å…¥çš„çº¿æ€§å‡½æ•°å­—ç¬¦ä¸²
         * æ”¯æŒæ ¼å¼: y = kx + b, y=kx, y=b, y = x - 1 ç­‰
         */
        const parseLinearFunction = (input) => {
            // ç§»é™¤æ‰€æœ‰ç©ºæ ¼å¹¶è½¬å°å†™
            const cleanInput = input.replace(/\s/g, '').toLowerCase();

            // å¿…é¡»ä»¥ y= å¼€å¤´
            if (!cleanInput.startsWith('y=')) return null;

            const rightSide = cleanInput.substring(2);

            let k = 0;
            let b = 0;

            // æƒ…å†µ 1: åŒ…å« x
            if (rightSide.includes('x')) {
                const parts = rightSide.split('x');
                let kPart = parts[0];
                let bPart = parts[1];

                // è§£æ k
                if (kPart === '' || kPart === '+') k = 1;
                else if (kPart === '-') k = -1;
                else k = parseFloat(kPart);

                // è§£æ b
                if (!bPart || bPart === '') b = 0;
                else b = parseFloat(bPart);

            } else {
                // æƒ…å†µ 2: å¸¸æ•°å‡½æ•° y = b
                k = 0;
                b = parseFloat(rightSide);
            }

            if (isNaN(k) || isNaN(b)) return null;

            return { k, b };
        };

        /**
         * éšæœºé¢˜ç›®ç”Ÿæˆå™¨
         */
        const generateProblem = () => {
            // é™åˆ¶åœ¨ -5 åˆ° 5 ä¹‹é—´ï¼Œæ–¹ä¾¿åˆå­¦è€…è®¡ç®—å’Œç»˜å›¾
            let k = 0;
            while (k === 0) k = Math.floor(Math.random() * 7) - 3; // -3 åˆ° 3, æ’é™¤0
            const b = Math.floor(Math.random() * 7) - 3; // -3 åˆ° 3

            return {
                k,
                b,
                id: Date.now(),
                desc: `è¯·å†™å‡ºç»è¿‡ç‚¹ (0, ${b}) ä¸”æ–œç‡ä¸º ${k} çš„ç›´çº¿æ–¹ç¨‹ã€‚`,
                points: [
                    { x: 0, y: b },
                    { x: 1, y: k + b }, 
                    { x: -b/k, y: 0} 
                ]
            };
        };

        const LinearFuncPlayground = () => {
            // --- State ---
            const [stage, setStage] = useState('intro'); // intro, practice, report
            const [problem, setProblem] = useState(null);
            const [userInput, setUserInput] = useState('');
            const [feedback, setFeedback] = useState({ type: 'neutral', msg: 'è§‚å¯Ÿå›¾è±¡ï¼Œè¾“å…¥å‡½æ•°å…¬å¼ (ä¾‹å¦‚: y = 2x + 1)' });
            const [parsedUserLine, setParsedUserLine] = useState(null);
            const [history, setHistory] = useState([]);
            const [attempts, setAttempts] = useState(0);
            
            // æ¢é’ˆçŠ¶æ€ (Draggable Probe)
            const [probePos, setProbePos] = useState({ x: 2, y: 2 });
            const [isDragging, setIsDragging] = useState(false);
            const svgRef = useRef(null);

            // --- Effects ---
            
            // å®æ—¶è§£æç”¨æˆ·è¾“å…¥ç”¨äºé¢„è§ˆ
            useEffect(() => {
                const result = parseLinearFunction(userInput);
                setParsedUserLine(result);
            }, [userInput]);

            // --- Handlers ---

            const startPractice = () => {
                setHistory([]);
                nextProblem();
                setStage('practice');
            };

            const nextProblem = () => {
                const newProb = generateProblem();
                setProblem(newProb);
                setUserInput('y=');
                setFeedback({ type: 'neutral', msg: 'è§‚å¯Ÿå›¾è±¡ï¼Œæ‹–åŠ¨æ¢é’ˆè¾…åŠ©æ‰¾ç‚¹ï¼Œç„¶åè¾“å…¥å…¬å¼ã€‚' });
                setAttempts(0);
                // é‡ç½®æ¢é’ˆä½ç½®åˆ°åŸç‚¹é™„è¿‘
                setProbePos({ x: 0, y: 0 });
            };

            const handleVerify = () => {
                if (!parsedUserLine) {
                    setFeedback({ type: 'error', msg: 'å…¬å¼æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ y = kx + b çš„æ ¼å¼ã€‚' });
                    return;
                }

                const { k: userK, b: userB } = parsedUserLine;
                const { k: targetK, b: targetB } = problem;

                // æ ¸å¿ƒæ¯”å¯¹ä¸å¼•å¯¼é€»è¾‘
                // ä½¿ç”¨å¾ˆå°çš„ epsilon å¤„ç†æµ®ç‚¹æ•°æ¯”è¾ƒ
                const EPSILON = 0.001;
                const kMatch = Math.abs(userK - targetK) < EPSILON;
                const bMatch = Math.abs(userB - targetB) < EPSILON;

                if (kMatch && bMatch) {
                    setFeedback({ type: 'success', msg: 'å®Œç¾ï¼å®Œå…¨æ­£ç¡®ï¼' });
                    // è®°å½•æˆç»©
                    setHistory(prev => [...prev, { id: problem.id, result: 'success', attempts: attempts + 1 }]);
                    
                    // å»¶è¿Ÿåè¿›å…¥ä¸‹ä¸€é¢˜æˆ–æŠ¥å‘Š
                    if (history.length >= 4) { // 5é¢˜ä¸€è½®
                        setTimeout(() => setStage('report'), 1500);
                    } else {
                        setTimeout(nextProblem, 1500);
                    }
                } else {
                    setAttempts(prev => prev + 1);
                    
                    // é’ˆå¯¹æ€§é”™è¯¯æç¤º
                    let tips = [];
                    
                    // æ£€æŸ¥æˆªè·
                    if (!bMatch) {
                        tips.push("æˆªè·(b)ä¸å¯¹ã€‚è¯·è§‚å¯Ÿç›´çº¿ä¸ Y è½´çš„äº¤ç‚¹ã€‚");
                    }
                    
                    // æ£€æŸ¥æ–œç‡
                    if (!kMatch) {
                        if (Math.sign(userK) !== Math.sign(targetK)) {
                            tips.push("æ–¹å‘åäº†ï¼æ³¨æ„çœ‹ç›´çº¿æ˜¯ä¸Šå‡(k>0)è¿˜æ˜¯ä¸‹é™(k<0)ã€‚");
                        } else if (Math.abs(userK) > Math.abs(targetK)) {
                            tips.push("å¤ªé™¡äº†ã€‚å°è¯•å‡å° x çš„ç³»æ•°ç»å¯¹å€¼ã€‚");
                        } else {
                            tips.push("å¤ªç¼“äº†ã€‚å°è¯•å¢å¤§ x çš„ç³»æ•°ç»å¯¹å€¼ã€‚");
                        }
                    }
                    
                    setFeedback({ type: 'error', msg: tips.join(' ') });
                }
            };

            // --- SVG Interaction Logic ---
            
            // åæ ‡è½¬æ¢ï¼šæ•°å­¦åæ ‡ -> åƒç´ åæ ‡
            const gridSize = 10; // -10 to 10
            const width = 300;
            const height = 300;
            
            const mapX = (x) => (x + gridSize) * (width / (gridSize * 2));
            const mapY = (y) => height - (y + gridSize) * (height / (gridSize * 2));
            
            const mapXInverse = (px) => (px / (width / (gridSize * 2))) - gridSize;
            const mapYInverse = (py) => ((height - py) / (height / (gridSize * 2))) - gridSize;

            const handlePointerDown = (e) => {
                setIsDragging(true);
                e.target.setPointerCapture(e.pointerId);
            };

            const handlePointerMove = (e) => {
                if (!isDragging || !svgRef.current) return;
                
                const rect = svgRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Snap to grid
                const mathX = Math.round(mapXInverse(x) * 2) / 2; 
                const mathY = Math.round(mapYInverse(y) * 2) / 2;
                
                // Clamp
                const clampedX = Math.max(-gridSize, Math.min(gridSize, mathX));
                const clampedY = Math.max(-gridSize, Math.min(gridSize, mathY));

                setProbePos({ x: clampedX, y: clampedY });
            };

            const handlePointerUp = (e) => {
                setIsDragging(false);
                if(e.target.releasePointerCapture) {
                    e.target.releasePointerCapture(e.pointerId);
                }
            };

            // --- Render Helpers ---

            const renderGrid = () => {
                const lines = [];
                for (let i = -gridSize; i <= gridSize; i++) {
                    // Vertical
                    lines.push(
                        <line 
                            key={`v${i}`} x1={mapX(i)} y1={0} x2={mapX(i)} y2={height} 
                            stroke={i === 0 ? "#000" : "#e5e7eb"} strokeWidth={i === 0 ? 2 : 1} 
                        />
                    );
                    // Horizontal
                    lines.push(
                        <line 
                            key={`h${i}`} x1={0} y1={mapY(i)} x2={width} y2={mapY(i)} 
                            stroke={i === 0 ? "#000" : "#e5e7eb"} strokeWidth={i === 0 ? 2 : 1} 
                        />
                    );
                }
                return lines;
            };

            const renderLine = (k, b, color, isDashed = false) => {
                const x1 = -gridSize;
                const y1 = k * x1 + b;
                const x2 = gridSize;
                const y2 = k * x2 + b;
                
                return (
                    <line 
                        x1={mapX(x1)} y1={mapY(y1)} 
                        x2={mapX(x2)} y2={mapY(y2)} 
                        stroke={color} 
                        strokeWidth={3}
                        strokeDasharray={isDashed ? "8,4" : "0"}
                        opacity={0.8}
                    />
                );
            };

            // --- Main Render ---

            return (
                <div className="min-h-screen bg-slate-50 font-sans text-slate-800 p-4 flex flex-col items-center">
                    <header className="w-full max-w-2xl mb-6 flex justify-between items-center bg-white p-4 rounded-xl shadow-sm">
                        <div className="flex items-center gap-2">
                            <Activity className="text-blue-600" />
                            <h1 className="text-lg font-bold text-slate-800">åˆäºŒæ•°å­¦ï¼šå‡½æ•°å»ºæ¨¡æŒ‘æˆ˜</h1>
                        </div>
                        {stage === 'practice' && (
                            <div className="text-sm font-medium text-slate-500">
                                è¿›åº¦: {history.length + 1} / 5
                            </div>
                        )}
                    </header>

                    {/* STAGE: INTRO */}
                    {stage === 'intro' && (
                        <div className="max-w-md w-full bg-white p-8 rounded-2xl shadow-lg text-center space-y-6">
                            <div className="w-20 h-20 bg-blue-100 rounded-full flex items-center justify-center mx-auto">
                                <Activity size={40} className="text-blue-600" />
                            </div>
                            <div>
                                <h2 className="text-2xl font-bold mb-2">å‡†å¤‡å¥½äº†å—ï¼Ÿ</h2>
                                <p className="text-slate-600">
                                    æˆ‘ä»¬å°†éšæœºç”Ÿæˆä¸€æ¡ç›´çº¿ã€‚ä½ éœ€è¦é€šè¿‡è§‚å¯Ÿå›¾è±¡ï¼Œè®¡ç®—å‡ºå®ƒçš„è§£æå¼ 
                                    <span className="font-mono bg-slate-100 px-1 mx-1 rounded">y = kx + b</span>
                                </p>
                            </div>
                            <div className="bg-blue-50 p-4 rounded-lg text-left text-sm text-blue-800 space-y-2">
                                <p>ğŸ¯ <b>ç›®æ ‡ï¼š</b> æ ¹æ®å›¾è±¡è¾“å…¥æ­£ç¡®çš„å…¬å¼ã€‚</p>
                                <p>ğŸ”§ <b>å·¥å…·ï¼š</b> æ‹–åŠ¨å›¾ä¸­çº¢è‰²çš„â€œæ¢é’ˆâ€æ¥æŸ¥çœ‹åæ ‡ã€‚</p>
                                <p>ğŸ’¡ <b>æç¤ºï¼š</b> å…ˆæ‰¾æˆªè· bï¼Œå†ç®—æ–œç‡ kã€‚</p>
                            </div>
                            <button 
                                onClick={startPractice}
                                className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold flex items-center justify-center gap-2 transition-colors"
                            >
                                <Play size={20} /> å¼€å§‹æŒ‘æˆ˜
                            </button>
                        </div>
                    )}

                    {/* STAGE: PRACTICE */}
                    {stage === 'practice' && problem && (
                        <div className="w-full max-w-4xl grid md:grid-cols-2 gap-6">
                            
                            {/* Left: Visualization */}
                            <div className="bg-white p-4 rounded-2xl shadow-lg flex flex-col items-center relative select-none">
                                <h3 className="absolute top-4 left-4 text-xs font-bold text-slate-400 uppercase tracking-wider">åæ ‡è§†çª—</h3>
                                
                                <div className="relative cursor-crosshair mt-4">
                                    <svg 
                                        ref={svgRef}
                                        width={width} 
                                        height={height} 
                                        className="bg-white border border-slate-200 rounded shadow-inner touch-none"
                                        onPointerDown={handlePointerDown}
                                        onPointerMove={handlePointerMove}
                                        onPointerUp={handlePointerUp}
                                        onPointerLeave={handlePointerUp}
                                    >
                                        {/* Grid & Axes */}
                                        {renderGrid()}

                                        {/* Target Line (Blue) */}
                                        {renderLine(problem.k, problem.b, "#2563eb")}
                                        
                                        {/* Key Points on Target Line */}
                                        <circle cx={mapX(0)} cy={mapY(problem.b)} r={5} fill="#2563eb" />
                                        <circle cx={mapX(1)} cy={mapY(problem.k + problem.b)} r={4} fill="#2563eb" opacity={0.5} />

                                        {/* User's Current Input Line (Orange Dashed) */}
                                        {parsedUserLine && (
                                            renderLine(parsedUserLine.k, parsedUserLine.b, "#f97316", true)
                                        )}

                                        {/* Draggable Probe */}
                                        <g transform={`translate(${mapX(probePos.x)}, ${mapY(probePos.y)})`}>
                                            <circle r={8} fill="rgba(239, 68, 68, 0.2)" />
                                            <circle r={4} fill="#ef4444" />
                                            {/* Tooltip for Probe */}
                                            <rect x={8} y={-30} width={60} height={24} rx={4} fill="rgba(0,0,0,0.8)" />
                                            <text x={38} y={-14} textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">
                                                ({probePos.x}, {probePos.y})
                                            </text>
                                        </g>
                                    </svg>
                                </div>
                                
                                <div className="mt-4 flex gap-4 text-sm text-slate-500">
                                    <div className="flex items-center gap-1">
                                        <div className="w-4 h-1 bg-blue-600 rounded"></div> ç›®æ ‡å›¾è±¡
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <div className="w-4 h-1 border-t-2 border-dashed border-orange-500"></div> ä½ çš„å…¬å¼
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <div className="w-2 h-2 rounded-full bg-red-500"></div> åæ ‡æ¢é’ˆ (å¯æ‹–åŠ¨)
                                    </div>
                                </div>
                            </div>

                            {/* Right: Controls & Logic */}
                            <div className="flex flex-col gap-4">
                                
                                {/* Instruction Card */}
                                <div className="bg-white p-6 rounded-2xl shadow-md border-l-4 border-blue-500">
                                    <h3 className="font-bold text-lg mb-1">ä»»åŠ¡ #{history.length + 1}</h3>
                                    <p className="text-slate-600">
                                        è§‚å¯Ÿå·¦ä¾§è“è‰²ç›´çº¿ã€‚è¯·å†™å‡ºå®ƒçš„å‡½æ•°è§£æå¼ã€‚
                                        <br/>
                                        <span className="text-xs text-slate-400">æç¤ºï¼šå¦‚æœç›´çº¿ç»è¿‡ (0, b)ï¼Œåˆ™ b å°±æ˜¯æˆªè·ã€‚</span>
                                    </p>
                                </div>

                                {/* Input Area */}
                                <div className="bg-white p-6 rounded-2xl shadow-lg flex-1 flex flex-col justify-center">
                                    <label className="block text-sm font-medium text-slate-700 mb-2">å‡½æ•°å…¬å¼</label>
                                    <div className="flex gap-2">
                                        <input 
                                            type="text" 
                                            value={userInput}
                                            onChange={(e) => setUserInput(e.target.value)}
                                            className="flex-1 text-2xl font-mono border-2 border-slate-200 rounded-lg px-4 py-3 focus:border-blue-500 focus:outline-none transition-colors"
                                            placeholder="y = kx + b"
                                            onKeyDown={(e) => e.key === 'Enter' && handleVerify()}
                                        />
                                    </div>
                                    
                                    {/* Feedback Area */}
                                    <div className={`mt-4 p-4 rounded-lg flex items-start gap-3 transition-all duration-300 ${
                                        feedback.type === 'error' ? 'bg-red-50 text-red-800' :
                                        feedback.type === 'success' ? 'bg-green-50 text-green-800' :
                                        'bg-slate-50 text-slate-600'
                                    }`}>
                                        {feedback.type === 'error' && <AlertCircle className="shrink-0 mt-0.5" size={18} />}
                                        {feedback.type === 'success' && <CheckCircle className="shrink-0 mt-0.5" size={18} />}
                                        {feedback.type === 'neutral' && <MousePointer2 className="shrink-0 mt-0.5" size={18} />}
                                        <p className="text-sm font-medium leading-relaxed">{feedback.msg}</p>
                                    </div>

                                    {/* Action Button */}
                                    <button 
                                        onClick={handleVerify}
                                        disabled={feedback.type === 'success'}
                                        className={`mt-6 w-full py-3 rounded-xl font-bold text-lg transition-all shadow-lg active:scale-95 ${
                                            feedback.type === 'success' 
                                                ? 'bg-green-500 text-white cursor-default'
                                                : 'bg-blue-600 hover:bg-blue-700 text-white'
                                        }`}
                                    >
                                        {feedback.type === 'success' ? 'éªŒè¯é€šè¿‡ï¼å³å°†è·³è½¬...' : 'éªŒè¯å…¬å¼'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* STAGE: REPORT */}
                    {stage === 'report' && (
                        <div className="max-w-md w-full bg-white p-8 rounded-2xl shadow-lg space-y-6 animate-in fade-in zoom-in duration-500">
                            <div className="text-center">
                                <h2 className="text-3xl font-bold text-slate-800 mb-2">æŒ‘æˆ˜å®Œæˆ!</h2>
                                <p className="text-slate-500">æ‰€æœ‰çš„é¢˜ç›®éƒ½å·²è§£å†³ã€‚</p>
                            </div>

                            <div className="space-y-3">
                                {history.map((record, idx) => (
                                    <div key={idx} className="flex justify-between items-center p-3 bg-slate-50 rounded-lg border border-slate-100">
                                        <span className="font-bold text-slate-700">ç¬¬ {idx + 1} é¢˜</span>
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm text-slate-500">{record.attempts === 1 ? 'ä¸€æ¬¡é€šè¿‡' : `${record.attempts} æ¬¡å°è¯•`}</span>
                                            {record.attempts === 1 ? <CheckCircle size={16} className="text-green-500" /> : <div className="w-4 h-4 rounded-full bg-yellow-400" />}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="bg-blue-50 p-4 rounded-xl text-center">
                                <p className="text-sm text-blue-900 mb-1">ç»¼åˆè¯„åˆ†</p>
                                <p className="text-4xl font-bold text-blue-600">
                                    {Math.round(history.reduce((acc, curr) => acc + (100 / Math.max(1, curr.attempts)), 0) / history.length)}
                                </p>
                            </div>

                            <button 
                                onClick={() => {
                                    setStage('intro');
                                    setHistory([]);
                                }}
                                className="w-full py-3 bg-slate-800 hover:bg-slate-900 text-white rounded-xl font-bold flex items-center justify-center gap-2 transition-colors"
                            >
                                <RotateCcw size={18} /> å†æ¥ä¸€è½®
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LinearFuncPlayground />);
    </script>
</body>
</html>