<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三角形折叠与几何性质可视化 (题22)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #f4f4f9; color: #333; margin: 0; padding: 10px; height: 100vh; overflow: hidden; }
        h2 { margin: 5px 0 10px 0; font-size: 1.2rem; color: #444; }
        .container { background: white; padding: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); display: flex; flex-direction: column; max-width: 800px; width: 100%; height: 90vh; }
        .canvas-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; border: 1px solid #eee; border-radius: 8px; background: #fff; }
        canvas { display: block; }
        .controls { margin-top: 10px; display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 15px; border-top: 1px solid #eee; padding-top: 10px; }
        .slider-group { display: flex; flex-direction: column; gap: 5px; justify-content: center; }
        .toggles { display: flex; flex-direction: column; gap: 5px; font-size: 0.9rem; }
        .toggle-item { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        label { font-weight: 600; font-size: 0.9rem; }
        input[type=range] { width: 100%; cursor: pointer; }
        .info-panel { background: #f8f9fa; border-radius: 6px; padding: 8px 12px; font-size: 0.85rem; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; border: 1px solid #e9ecef; }
        .highlight { color: #d00; font-weight: bold; }
        .coord-text { font-family: monospace; color: #0056b3; }
        .hint { grid-column: 1 / -1; color: #666; font-style: italic; font-size: 0.8rem; margin-top: 2px; }
    </style>
</head>
<body>

<div class="container">
    <h2>几何折叠问题可视化 (第22题)</h2>
    
    <div class="canvas-wrapper">
        <canvas id="geoCanvas" width="700" height="450"></canvas>
    </div>

    <div class="controls">
        <div class="left-col" style="display:flex; flex-direction:column; gap:10px;">
            <div class="slider-group">
                <label>调整 D 点位置 (m值): <span id="mVal" class="coord-text">6.00</span></label>
                <input type="range" id="mSlider" min="1" max="9" step="0.05" value="6.00">
            </div>
            <div class="toggles">
                <label class="toggle-item"><input type="checkbox" id="showOutlines" checked> 显示三角形边框 (含虚线)</label>
                <label class="toggle-item"><input type="checkbox" id="showFills" checked> 显示填充颜色</label>
            </div>
        </div>

        <div class="info-panel">
            <div>∠DAC: <span id="angleDAC">-</span>°</div>
            <div>EC与DF夹角: <span id="angleCross">-</span>° <span id="perpTag"></span></div>
            <div style="grid-column: 1 / -1;">H 点坐标 (EF与x轴交点): (<span id="hX" class="coord-text">-</span>, 0)</div>
            <div class="hint">提示：拖动滑块寻找 m=6 时的垂直状态</div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('geoCanvas');
    const ctx = canvas.getContext('2d');
    const mSlider = document.getElementById('mSlider');
    const mValSpan = document.getElementById('mVal');
    const angleDACSpan = document.getElementById('angleDAC');
    const angleCrossSpan = document.getElementById('angleCross');
    const perpTag = document.getElementById('perpTag');
    const hXSpan = document.getElementById('hX');
    const showOutlinesCB = document.getElementById('showOutlines');
    const showFillsCB = document.getElementById('showFills');

    // Coordinate system settings
    // Adjusted scale and center to fit better in a shorter canvas
    const scale = 32; 
    const centerX = 150; 
    const centerY = 300; 

    function toScreen(x, y) {
        return { x: centerX + x * scale, y: centerY - y * scale };
    }

    // Mathematical utility functions
    function reflect(px, py, ax, ay, bx, by) {
        const dx = bx - ax;
        const dy = by - ay;
        const t = ((px - ax) * dx + (py - ay) * dy) / (dx * dx + dy * dy);
        const closestX = ax + t * dx;
        const closestY = ay + t * dy;
        return {
            x: 2 * closestX - px,
            y: 2 * closestY - py
        };
    }

    function getLineIntersectionXAxis(x1, y1, x2, y2) {
        if (Math.abs(y1 - y2) < 1e-6) return null;
        const slope = (y2 - y1) / (x2 - x1);
        return x1 + (0 - y1) / slope;
    }

    function getAngleBetweenLines(m1, m2) {
        if (!isFinite(m1) && !isFinite(m2)) return 0;
        if (!isFinite(m1)) return 90 - Math.abs(Math.atan(m2) * 180 / Math.PI);
        if (!isFinite(m2)) return 90 - Math.abs(Math.atan(m1) * 180 / Math.PI);
        const tanTheta = Math.abs((m1 - m2) / (1 + m1 * m2));
        return Math.atan(tanTheta) * 180 / Math.PI;
    }

    function draw() {
        const m = parseFloat(mSlider.value);
        mValSpan.innerText = m.toFixed(2);
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // --- 1. Draw Grid ---
        ctx.strokeStyle = '#f0f0f0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=-10; i<=25; i++) {
            let p1 = toScreen(i, -15); let p2 = toScreen(i, 15);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            let p3 = toScreen(-10, i); let p4 = toScreen(25, i);
            ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        }
        ctx.stroke();

        // --- 2. Draw Axes ---
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let ox = toScreen(-5, 0); let ex = toScreen(20, 0);
        ctx.moveTo(ox.x, ox.y); ctx.lineTo(ex.x, ex.y); // X
        let oy = toScreen(0, -10); let ey = toScreen(0, 12);
        ctx.moveTo(oy.x, oy.y); ctx.lineTo(ey.x, ey.y); // Y
        ctx.stroke();

        // Arrow heads
        drawArrowHead(ex, 'right');
        drawArrowHead(ey, 'up');

        // --- 3. Calculate Points ---
        const A = {x: 2, y: 0};
        const C = {x: 0, y: -4};
        const D = {x: 0, y: m};

        // Fold 1: Reflect D across AC to get E
        const E = reflect(D.x, D.y, A.x, A.y, C.x, C.y);
        
        // Fold 2: Reflect C across AD to get F
        const F = reflect(C.x, C.y, A.x, A.y, D.x, D.y);

        // Intersection H (EF meets X axis)
        const hx_val = getLineIntersectionXAxis(E.x, E.y, F.x, F.y);

        // Update Info Panel
        // Angle DAC
        const vecAD = {x: D.x-A.x, y: D.y-A.y};
        const vecAC = {x: C.x-A.x, y: C.y-A.y};
        const angleAD = Math.atan2(vecAD.y, vecAD.x);
        const angleAC = Math.atan2(vecAC.y, vecAC.x);
        let angDAC = Math.abs(angleAD - angleAC) * 180 / Math.PI;
        if (angDAC > 180) angDAC = 360 - angDAC;
        angleDACSpan.innerText = angDAC.toFixed(1);

        // Angle between EC and DF
        const slopeEC = (C.y - E.y) / (C.x - E.x);
        const slopeDF = (F.y - D.y) / (F.x - D.x);
        let angCross = getAngleBetweenLines(slopeEC, slopeDF);
        angleCrossSpan.innerText = angCross.toFixed(1);
        
        if (Math.abs(angCross - 90) < 1) {
            perpTag.innerHTML = "(垂直!)";
            perpTag.className = "highlight";
        } else {
            perpTag.innerHTML = "";
        }
        hXSpan.innerText = hx_val ? hx_val.toFixed(2) : "平行";


        // --- 4. Draw Geometry ---
        
        const ptA = toScreen(A.x, A.y);
        const ptC = toScreen(C.x, C.y);
        const ptD = toScreen(D.x, D.y);
        const ptE = toScreen(E.x, E.y);
        const ptF = toScreen(F.x, F.y);

        // Fill Colors
        if (showFillsCB.checked) {
            // DAC (Original)
            ctx.fillStyle = "rgba(100, 100, 100, 0.1)"; 
            ctx.beginPath(); ctx.moveTo(ptA.x, ptA.y); ctx.lineTo(ptD.x, ptD.y); ctx.lineTo(ptC.x, ptC.y); ctx.fill();

            // EAC (Folded right)
            ctx.fillStyle = "rgba(0, 123, 255, 0.15)";
            ctx.beginPath(); ctx.moveTo(ptA.x, ptA.y); ctx.lineTo(ptE.x, ptE.y); ctx.lineTo(ptC.x, ptC.y); ctx.fill();

            // DAF (Folded left)
            ctx.fillStyle = "rgba(40, 167, 69, 0.15)";
            ctx.beginPath(); ctx.moveTo(ptA.x, ptA.y); ctx.lineTo(ptD.x, ptD.y); ctx.lineTo(ptF.x, ptF.y); ctx.fill();
        }

        // Outlines
        if (showOutlinesCB.checked) {
            ctx.lineWidth = 1.5;

            // DAC (Base Triangle) - Solid Gray
            ctx.strokeStyle = "#555";
            ctx.setLineDash([]);
            ctx.beginPath(); ctx.moveTo(ptD.x, ptD.y); ctx.lineTo(ptA.x, ptA.y); ctx.lineTo(ptC.x, ptC.y); ctx.lineTo(ptD.x, ptD.y); ctx.stroke();

            // Triangle EAC - Dashed Blue
            ctx.strokeStyle = "#007bff";
            ctx.setLineDash([5, 3]);
            ctx.beginPath(); ctx.moveTo(ptE.x, ptE.y); ctx.lineTo(ptA.x, ptA.y); ctx.lineTo(ptC.x, ptC.y); ctx.lineTo(ptE.x, ptE.y); ctx.stroke();

            // Triangle DAF - Dashed Green
            ctx.strokeStyle = "#28a745";
            ctx.setLineDash([5, 3]);
            ctx.beginPath(); ctx.moveTo(ptF.x, ptF.y); ctx.lineTo(ptA.x, ptA.y); ctx.lineTo(ptD.x, ptD.y); ctx.lineTo(ptF.x, ptF.y); ctx.stroke();
            
            ctx.setLineDash([]);
        }

        // Highlight Important Lines (EC and DF)
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d00"; // Red for EC
        ctx.beginPath(); ctx.moveTo(ptE.x, ptE.y); ctx.lineTo(ptC.x, ptC.y); ctx.stroke();
        
        ctx.strokeStyle = "#00d"; // Blue for DF
        ctx.beginPath(); ctx.moveTo(ptD.x, ptD.y); ctx.lineTo(ptF.x, ptF.y); ctx.stroke();

        // Line EF extended
        ctx.strokeStyle = "#orange"; 
        ctx.fillStyle = "#orange";
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath(); 
        const pEF1 = toScreen(E.x + (E.x-F.x)*1.5, E.y + (E.y-F.y)*1.5);
        const pEF2 = toScreen(F.x + (F.x-E.x)*1.5, F.y + (F.y-E.y)*1.5);
        ctx.moveTo(pEF1.x, pEF1.y); ctx.lineTo(pEF2.x, pEF2.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Labels
        drawLabel("A", ptA, 10, 20);
        drawLabel("C", ptC, 10, 15);
        drawLabel("D", ptD, -20, 0);
        drawLabel("E", ptE, 10, -5);
        drawLabel("F", ptF, -20, -5);
        
        if (hx_val) {
            const ptH = toScreen(hx_val, 0);
            drawPoint(ptH, "#d35400");
            ctx.fillStyle = "#d35400";
            ctx.font = "bold 14px sans-serif";
            ctx.fillText(`H`, ptH.x + 5, ptH.y - 8);
        }
    }

    function drawLabel(text, p, dx, dy) {
        ctx.fillStyle = "#333";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText(text, p.x + dx, p.y + dy);
        drawPoint(p, "#333");
    }

    function drawPoint(p, color) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2);
        ctx.fillStyle = color || "black";
        ctx.fill();
    }

    function drawArrowHead(p, dir) {
        ctx.beginPath();
        if (dir === 'right') {
            ctx.moveTo(p.x, p.y); ctx.lineTo(p.x-8, p.y-4); ctx.lineTo(p.x-8, p.y+4);
        } else if (dir === 'up') {
            ctx.moveTo(p.x, p.y); ctx.lineTo(p.x-4, p.y+8); ctx.lineTo(p.x+4, p.y+8);
        }
        ctx.fillStyle = '#ccc';
        ctx.fill();
    }

    mSlider.oninput = draw;
    showOutlinesCB.onchange = draw;
    showFillsCB.onchange = draw;
    
    // Resize listener to re-center if needed (simple implementation)
    window.addEventListener('resize', draw);

    draw(); // Init
</script>

</body>
</html>