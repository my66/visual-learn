<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è§’å¹³åˆ†çº¿ä½œå›¾æ¼”ç¤º - äº’åŠ¨æ•™å­¦</title>
    <!-- å¼•å…¥ Tailwind CSS ç”¨äºå¿«é€Ÿç¾åŒ–ç•Œé¢ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ MathJax ç”¨äºæ˜¾ç¤ºæ•°å­¦å…¬å¼ -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background-color: #f3f4f6;
            color: #333;
            overflow-x: hidden;
        }
        canvas {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: crosshair;
            touch-action: none; /* é˜²æ­¢è§¦æ‘¸å±æ»šåŠ¨ */
        }
        .control-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .step-active {
            border-left: 4px solid #3b82f6;
            background-color: #eff6ff;
        }
        .btn {
            transition: all 0.2s;
        }
        .btn:active {
            transform: scale(0.95);
        }
        /* è‡ªå®šä¹‰æ»‘å—æ ·å¼ */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
        }
        input[type=range]:focus {
            outline: none; 
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- é¡¶éƒ¨æ ‡é¢˜æ  -->
    <header class="bg-blue-600 text-white p-4 shadow-md flex-none">
        <div class="container mx-auto flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold">è§’å¹³åˆ†çº¿ä½œå›¾æ¼”ç¤º</h1>
                <p class="text-sm opacity-90">äº’åŠ¨æ¼”ç¤ºï¼šä»…ç”¨åœ†è§„æˆ–ä»…ç”¨åˆ»åº¦å°º/ä¸‰è§’æ¿å¹³åˆ†ä¸€ä¸ªè§’</p>
            </div>
            <div class="text-sm bg-blue-700 px-3 py-1 rounded">
                æ•°ç†å¯è§†åŒ–æ•™å­¦å·¥å…·
            </div>
        </div>
    </header>

    <!-- ä¸»ä½“å†…å®¹ -->
    <main class="flex-grow flex flex-col md:flex-row h-full overflow-hidden">
        
        <!-- å·¦ä¾§ï¼šæ§åˆ¶ä¸è¯´æ˜åŒº -->
        <aside class="w-full md:w-1/3 lg:w-1/4 p-4 overflow-y-auto control-panel z-10 flex flex-col gap-4 border-r border-gray-200">
            
            <!-- é¢˜ç›®/åŸç†æè¿° -->
            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100">
                <h3 class="font-bold text-blue-800 mb-2">ğŸ·ï¸ æ¼”ç¤ºç›®æ ‡</h3>
                <p class="text-sm text-gray-700 mb-2">
                    ç»™å®šä¸€ä¸ªè§’ \(\angle AOB\)ï¼Œæ¼”ç¤ºå¦‚ä½•åªä½¿ç”¨ç‰¹å®šå·¥å…·å°†å…¶å¹³åˆ†ã€‚
                </p>
                <div class="text-xs text-gray-500">
                    <span class="font-bold">åŸç†æç¤ºï¼š</span><br>
                    1. å°ºè§„æ³•ï¼šåˆ©ç”¨ SSS å…¨ç­‰åˆ¤å®š (\(\triangle OCP \cong \triangle ODP\))ã€‚<br>
                    2. åˆ»åº¦å°ºæ³•ï¼šåˆ©ç”¨ç­‰è…°ä¸‰è§’å½¢â€œä¸‰çº¿åˆä¸€â€æ€§è´¨ã€‚
                </div>
            </div>

            <!-- æ–¹æ³•é€‰æ‹© -->
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">é€‰æ‹©ä½œå›¾æ–¹æ³•</label>
                <div class="flex rounded-md shadow-sm" role="group">
                    <button onclick="setMethod('compass')" id="btn-compass" class="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-l-lg hover:bg-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-500">
                        ğŸ“ å°ºè§„ä½œå›¾
                    </button>
                    <button onclick="setMethod('ruler')" id="btn-ruler" class="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-r-lg hover:bg-gray-50 focus:z-10 focus:ring-2 focus:ring-blue-500">
                        ğŸ“ ä»…åˆ»åº¦å°º
                    </button>
                </div>
            </div>

            <!-- å‚æ•°æ§åˆ¶ -->
            <div class="space-y-4 border-t pt-4">
                <div>
                    <label class="flex justify-between text-sm font-medium text-gray-700">
                        <span>âˆ AOB è§’åº¦: <span id="angle-val" class="text-blue-600">60Â°</span></span>
                    </label>
                    <input type="range" id="angle-slider" min="20" max="160" value="60" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                </div>

                <!-- æ­¥éª¤æ§åˆ¶ -->
                <div class="bg-gray-50 p-3 rounded border">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm font-bold text-gray-700">æ¼”ç¤ºæ­¥éª¤</span>
                        <span id="step-indicator" class="text-xs font-mono bg-gray-200 px-2 py-1 rounded">0 / 4</span>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="prevStep()" class="btn flex-1 bg-white border border-gray-300 hover:bg-gray-100 text-gray-800 font-semibold py-1 px-2 rounded text-sm shadow-sm">
                            â¬…ï¸ ä¸Šä¸€æ­¥
                        </button>
                        <button onclick="nextStep()" class="btn flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-2 rounded text-sm shadow-sm">
                            ä¸‹ä¸€æ­¥ â¡ï¸
                        </button>
                    </div>
                    <button onclick="resetDemo()" class="btn w-full mt-2 bg-red-50 border border-red-200 text-red-600 hover:bg-red-100 py-1 rounded text-sm">
                        ğŸ”„ é‡ç½®æ¼”ç¤º
                    </button>
                </div>

                <!-- æ ‡æ³¨å¼€å…³ -->
                <div>
                    <h4 class="text-sm font-bold text-gray-700 mb-2">ğŸ‘€ å¯è§†åŒ–é€‰é¡¹</h4>
                    <div class="space-y-2">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="show-labels" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-600">æ˜¾ç¤ºç‚¹æ ‡ç­¾ (A, B, O...)</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="show-aux" checked class="rounded text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-600">æ˜¾ç¤ºè¾…åŠ©è½¨è¿¹/åˆ»åº¦</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="show-principle" class="rounded text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-600">æ˜¾ç¤ºå‡ ä½•åŸç† (å…¨ç­‰/ä¸­çº¿)</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- å½“å‰æ­¥éª¤æ–‡å­—è¯´æ˜ -->
            <div id="step-description" class="mt-auto bg-yellow-50 border-l-4 border-yellow-400 p-3 text-sm text-yellow-800 italic">
                å‡†å¤‡å¼€å§‹ï¼šè¯·æ‹–åŠ¨è§’åº¦æ»‘å—è®¾å®šåˆå§‹è§’ï¼Œç„¶åç‚¹å‡»â€œä¸‹ä¸€æ­¥â€ã€‚
            </div>

        </aside>

        <!-- å³ä¾§ï¼šå¯è§†åŒ–ç”»å¸ƒ -->
        <div class="flex-grow bg-gray-100 relative overflow-hidden flex justify-center items-center p-4">
            <canvas id="geometryCanvas" class="w-full h-full max-w-4xl max-h-[80vh] aspect-video bg-white shadow-lg"></canvas>
            
            <!-- æµ®åŠ¨æç¤ºï¼šåŸç†å…¬å¼ -->
            <div id="math-overlay" class="absolute top-6 right-6 bg-white/90 backdrop-blur p-4 rounded shadow-lg border border-gray-200 hidden max-w-xs">
                <h4 class="font-bold text-gray-800 border-b pb-1 mb-2">ğŸ“ å‡ ä½•åŸç†</h4>
                <div id="math-content" class="text-sm text-gray-700 leading-relaxed"></div>
            </div>
        </div>

    </main>

    <script>
        // --- 1. å…¨å±€çŠ¶æ€ç®¡ç† ---
        const state = {
            method: 'compass', // 'compass' (å°ºè§„) æˆ– 'ruler' (åˆ»åº¦å°º)
            angleDeg: 60,
            step: 0,
            maxSteps: 4,
            width: 800,
            height: 600,
            center: { x: 400, y: 500 }, // Oç‚¹ä½ç½®
            armLength: 350,
            
            // åŠ¨ç”»ç›¸å…³
            progress: 0, // å½“å‰æ­¥éª¤çš„åŠ¨ç”»è¿›åº¦ 0~1
            isAnimating: false,
            
            // å¼€å…³
            showLabels: true,
            showAux: true,
            showPrinciple: false
        };

        // DOM å…ƒç´ å¼•ç”¨
        const canvas = document.getElementById('geometryCanvas');
        const ctx = canvas.getContext('2d');
        const descEl = document.getElementById('step-description');
        const indicatorEl = document.getElementById('step-indicator');
        const mathOverlay = document.getElementById('math-overlay');
        const mathContent = document.getElementById('math-content');

        // --- 2. å‡ ä½•è®¡ç®—è¾…åŠ©å‡½æ•° ---
        
        function toRad(deg) { return deg * Math.PI / 180; }
        
        // è·å–å°„çº¿ç«¯ç‚¹ï¼šä»¥Oä¸ºåŸç‚¹ï¼ŒangleDegä¸ºåè½¬è§’ï¼ˆç›¸å¯¹äºå‚ç›´å‘ä¸Šï¼‰
        // è¿™é‡Œæˆ‘ä»¬æŠŠè§’å¹³åˆ†çº¿è®¾ä¸ºå‚ç›´å‘ä¸Š (-90åº¦åœ¨canvasåæ ‡ç³»)
        // è¿™æ ·å·¦å³å¯¹ç§°æ›´ç¾è§‚
        function getArmPoint(length, angleOffsetDeg) {
            const baseAngle = -90; // å‚ç›´å‘ä¸Š
            const rad = toRad(baseAngle + angleOffsetDeg);
            return {
                x: state.center.x + length * Math.cos(rad),
                y: state.center.y + length * Math.sin(rad)
            };
        }

        // --- 3. æ ¸å¿ƒç»˜å›¾é€»è¾‘ ---

        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, state.width, state.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // è®¡ç®—å…³é”®ç‚¹åæ ‡
            const O = state.center;
            const halfAngle = state.angleDeg / 2;
            const A = getArmPoint(state.armLength, -halfAngle); // å·¦è‡‚
            const B = getArmPoint(state.armLength, halfAngle);  // å³è‡‚
            
            // 1. ç»˜åˆ¶åŸºç¡€è§’ AOB
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(O.x, O.y);
            ctx.lineTo(B.x, B.y);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#333';
            ctx.stroke();

            // ç»˜åˆ¶ç‚¹ O æ ‡ç­¾
            if (state.showLabels) {
                drawLabel('O', O.x, O.y + 25);
                drawLabel('A', A.x - 10, A.y);
                drawLabel('B', B.x + 10, B.y);
            }

            // æ ¹æ®ä¸åŒæ–¹æ³•ç»˜åˆ¶æ­¥éª¤
            if (state.method === 'compass') {
                drawCompassMethod(O, halfAngle);
            } else {
                drawRulerMethod(O, halfAngle);
            }

            // ç»˜åˆ¶åŸç†è¦†ç›–å±‚
            updateMathOverlay();
        }

        // === å°ºè§„ä½œå›¾æ³•ç»˜åˆ¶é€»è¾‘ ===
        function drawCompassMethod(O, halfAngle) {
            const r1 = 180; // ç¬¬ä¸€æ­¥åœ†å¼§åŠå¾„
            const r2 = 180; // ç¬¬äºŒæ­¥åœ†å¼§åŠå¾„
            
            // è®¡ç®— C, D ç‚¹ (ç¬¬ä¸€æ­¥äº¤ç‚¹)
            const C = getArmPoint(r1, -halfAngle);
            const D = getArmPoint(r1, halfAngle);

            // è®¡ç®— P ç‚¹ (æœ€ç»ˆäº¤ç‚¹ - å…¶å®å°±åœ¨æ­£ä¸Šæ–¹ r1 è·ç¦»å¤„ï¼Œç¨å¾®è¿œä¸€ç‚¹)
            // ä¸¥æ ¼å‡ ä½•è®¡ç®—ï¼šPç‚¹æ˜¯åˆ†åˆ«ä»¥Cã€Dä¸ºåœ†å¿ƒï¼Œr2ä¸ºåŠå¾„çš„äº¤ç‚¹
            // ç®€åŒ–ï¼šå› ä¸ºå¯¹ç§°ï¼ŒPç‚¹å°±åœ¨å‚ç›´çº¿ä¸Šã€‚
            // è·ç¦» O çš„é•¿åº¦è®¡ç®—ï¼šåœ¨ç­‰è…°ä¸‰è§’å½¢OCDä¸­ï¼Œé«˜ = sqrt(r1^2 - (CD/2)^2) ... 
            // ç®€å•åŒ–ï¼šä¸ºäº†æ¼”ç¤ºæ¸…æ™°ï¼Œæˆ‘ä»¬è®©Pç‚¹ç¨å¾®è¿œä¸€ç‚¹
            const distCD = 2 * r1 * Math.sin(toRad(halfAngle));
            const h = Math.sqrt(r2*r2 - (distCD/2)*(distCD/2));
            const distOP = r1 * Math.cos(toRad(halfAngle)) + h;
            const P = { x: O.x, y: O.y - distOP };


            // æ­¥éª¤ 1: ä»¥Oä¸ºåœ†å¿ƒç”»å¼§
            if (state.step >= 1) {
                const drawPercent = state.step === 1 ? state.progress : 1;
                
                if (state.showAux) {
                    ctx.beginPath();
                    // ç”»å¼§: ä» A è¾¹åˆ° B è¾¹
                    const startAngle = toRad(-90 - halfAngle);
                    const endAngle = toRad(-90 + halfAngle);
                    // å¦‚æœæ­£åœ¨åŠ¨ç”»ï¼Œæ ¹æ®è¿›åº¦æˆªæ–­
                    const currentEnd = startAngle + (endAngle - startAngle) * drawPercent;
                    
                    ctx.arc(O.x, O.y, r1, startAngle, currentEnd);
                    ctx.strokeStyle = '#ef4444'; // çº¢è‰²è½¨è¿¹
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // ç”»äº¤ç‚¹
                if (drawPercent > 0.9) {
                    drawPoint(C);
                    drawPoint(D);
                    if (state.showLabels) {
                        drawLabel('C', C.x - 15, C.y);
                        drawLabel('D', D.x + 15, D.y);
                    }
                }
            }

            // æ­¥éª¤ 2: ä»¥Cä¸ºåœ†å¿ƒç”»å¼§
            if (state.step >= 2) {
                const drawPercent = state.step === 2 ? state.progress : 1;
                
                if (state.showAux) {
                    ctx.beginPath();
                    // ä¼°ç®—å¼§çš„è§’åº¦èŒƒå›´
                    ctx.arc(C.x, C.y, r2, toRad(-60), toRad(-60) + toRad(90) * drawPercent);
                    ctx.strokeStyle = '#3b82f6'; // è“è‰²
                    ctx.stroke();
                }
            }

            // æ­¥éª¤ 3: ä»¥Dä¸ºåœ†å¿ƒç”»å¼§
            if (state.step >= 3) {
                const drawPercent = state.step === 3 ? state.progress : 1;
                
                if (state.showAux) {
                    ctx.beginPath();
                    ctx.arc(D.x, D.y, r2, toRad(240 - 90 * drawPercent), toRad(240)); 
                    ctx.strokeStyle = '#3b82f6';
                    ctx.stroke();
                }

                if (drawPercent > 0.9 || state.step > 3) {
                    drawPoint(P);
                    if (state.showLabels) drawLabel('P', P.x, P.y - 15);
                }
            }

            // æ­¥éª¤ 4: è¿æ¥ OP
            if (state.step >= 4) {
                const drawPercent = state.step === 4 ? state.progress : 1;
                ctx.beginPath();
                ctx.moveTo(O.x, O.y);
                const targetX = O.x + (P.x - O.x) * 1.5; // å»¶é•¿ä¸€ç‚¹
                const targetY = O.y + (P.y - O.y) * 1.5;
                
                // çº¿æ€§æ’å€¼
                const currX = O.x + (targetX - O.x) * drawPercent;
                const currY = O.y + (targetY - O.y) * drawPercent;

                ctx.lineTo(currX, currY);
                ctx.strokeStyle = '#10b981'; // ç»¿è‰²ç»“æœ
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            // ç»˜åˆ¶åœ†è§„ç¤ºæ„å›¾ (ä»…åœ¨åŠ¨ç”»è¿›è¡Œæ—¶)
            if (state.isAnimating && state.showAux) {
                let compassCenter, compassRadius;
                if (state.step === 1) { compassCenter = O; compassRadius = r1; }
                else if (state.step === 2) { compassCenter = C; compassRadius = r2; }
                else if (state.step === 3) { compassCenter = D; compassRadius = r2; }

                if (compassCenter) {
                    drawCompassIcon(compassCenter, compassRadius);
                }
            }
        }

        // === åˆ»åº¦å°ºæ³•ç»˜åˆ¶é€»è¾‘ ===
        function drawRulerMethod(O, halfAngle) {
            const markDist = 220; // åˆ»åº¦ä½ç½®
            
            const C = getArmPoint(markDist, -halfAngle);
            const D = getArmPoint(markDist, halfAngle);
            const M = { x: (C.x + D.x)/2, y: (C.y + D.y)/2 }; // ä¸­ç‚¹

            // æ­¥éª¤ 1: æ ‡è®°C (é‡å– OC)
            if (state.step >= 1) {
                const drawPercent = state.step === 1 ? state.progress : 1;
                // æ¨¡æ‹Ÿå°ºå­ç§»åŠ¨æ•ˆæœ (æ·¡å…¥)
                if (state.isAnimating && state.step === 1) {
                    drawRulerIcon(O, C, drawPercent);
                }
                
                if (!state.isAnimating || state.step > 1) {
                    drawPoint(C);
                    if(state.showLabels) drawLabel('C', C.x-20, C.y);
                    drawTickMark(C, -halfAngle); // ç”»ä¸€ä¸ªå°åˆ»åº¦çº¿
                }
            }

            // æ­¥éª¤ 2: æ ‡è®°D (é‡å– OD = OC)
            if (state.step >= 2) {
                const drawPercent = state.step === 2 ? state.progress : 1;
                if (state.isAnimating && state.step === 2) {
                    drawRulerIcon(O, D, drawPercent);
                }
                
                if (!state.isAnimating || state.step > 2) {
                    drawPoint(D);
                    if(state.showLabels) drawLabel('D', D.x+20, D.y);
                    drawTickMark(D, halfAngle);
                    
                    // æ ‡è®°ç­‰é•¿ç¬¦å·
                    if(state.showAux) {
                        drawDoubleHash(O, C);
                        drawDoubleHash(O, D);
                    }
                }
            }

            // æ­¥éª¤ 3: è¿æ¥ CD å¹¶å–ä¸­ç‚¹ M
            if (state.step >= 3) {
                const drawPercent = state.step === 3 ? state.progress : 1;
                
                // ç”»è™šçº¿è¿çº¿
                ctx.beginPath();
                ctx.moveTo(C.x, C.y);
                ctx.lineTo(C.x + (D.x - C.x)*drawPercent, C.y + (D.y - C.y)*drawPercent);
                ctx.strokeStyle = '#9ca3af';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                if (drawPercent > 0.8) {
                    drawPoint(M);
                    if(state.showLabels) drawLabel('M', M.x, M.y + 20);
                    // æ ‡è®°ä¸­ç‚¹ç›¸ç­‰ç¬¦å·
                    if(state.showAux) {
                        drawSingleHash(C, M);
                        drawSingleHash(M, D);
                    }
                }
            }

            // æ­¥éª¤ 4: è¿æ¥ OM
            if (state.step >= 4) {
                const drawPercent = state.step === 4 ? state.progress : 1;
                ctx.beginPath();
                ctx.moveTo(O.x, O.y);
                // å»¶é•¿å°„çº¿
                const targetX = O.x + (M.x - O.x) * 2.0; 
                const targetY = O.y + (M.y - O.y) * 2.0;
                
                const currX = O.x + (targetX - O.x) * drawPercent;
                const currY = O.y + (targetY - O.y) * drawPercent;

                ctx.lineTo(currX, currY);
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }

        // --- 4. ç»˜å›¾è¾…åŠ©ç»„ä»¶ ---

        function drawPoint(p) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#1d4ed8';
            ctx.fill();
        }

        function drawLabel(text, x, y) {
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 16px serif';
            ctx.fillText(text, x, y);
        }

        function drawTickMark(p, angleOffsetDeg) {
            const size = 10;
            const rad = toRad(-90 + angleOffsetDeg + 90); // å‚ç›´äºè‡‚
            ctx.beginPath();
            ctx.moveTo(p.x - size*Math.cos(rad), p.y - size*Math.sin(rad));
            ctx.lineTo(p.x + size*Math.cos(rad), p.y + size*Math.sin(rad));
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawDoubleHash(p1, p2) {
            // åœ¨çº¿æ®µä¸­é—´ç”»åŒæ 
            const mx = (p1.x + p2.x)/2;
            const my = (p1.y + p2.y)/2;
            // ç®€å•çš„ç”»ä¸ªåœˆæˆ–æ ‡è®°ä»£æ›¿ï¼Œé¿å…å¤æ‚æ—‹è½¬è®¡ç®—
            ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
            ctx.beginPath();
            ctx.arc(mx, my, 5, 0, Math.PI*2);
            ctx.fill();
        }

        function drawSingleHash(p1, p2) {
            const mx = (p1.x + p2.x)/2;
            const my = (p1.y + p2.y)/2;
            ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
            ctx.beginPath();
            ctx.fillRect(mx-3, my-3, 6, 6);
        }

        function drawCompassIcon(center, radius) {
            // ç®€å•çš„åœ†è§„å›¾æ ‡
            ctx.save();
            ctx.translate(center.x, center.y);
            // æ—‹è½¬åœ†è§„ä»¥äº§ç”Ÿç”»åœ†æ„Ÿ
            // è¿™é‡Œçš„æ—‹è½¬é€»è¾‘ä»…ä½œè§†è§‰è£…é¥°
            ctx.rotate(Date.now() / 200); 
            
            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, -radius); // å·¦è…¿
            ctx.lineTo(10, -radius);  // å³è…¿ (å®é™…ä¸Šåœ†è§„æ˜¯å€’è¿‡æ¥çš„ï¼Œè¿™é‡Œç®€åŒ–)
            ctx.fill();
            
            // ç¬”å°–
            ctx.beginPath();
            ctx.arc(0, -radius, 3, 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.restore();
        }

        function drawRulerIcon(p1, p2, progress) {
            // åœ¨ p1 å’Œ p2 ä¹‹é—´ç”»ä¸€ä¸ªåŠé€æ˜çŸ©å½¢ä»£è¡¨å°ºå­
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
            
            ctx.save();
            ctx.translate(p1.x, p1.y);
            ctx.rotate(angle);
            
            ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
            ctx.fillRect(0, 5, dist * progress, 30); // å°ºå­åœ¨ç‚¹ä¸‹æ–¹
            
            // åˆ»åº¦çº¿
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            for(let i=0; i<dist*progress; i+=20) {
                ctx.beginPath();
                ctx.moveTo(i, 5);
                ctx.lineTo(i, 15);
                ctx.stroke();
            }

            ctx.restore();
        }

        // --- 5. äº¤äº’ä¸é€»è¾‘æ§åˆ¶ ---

        function updateMathOverlay() {
            if (!state.showPrinciple) {
                mathOverlay.classList.add('hidden');
                return;
            }
            mathOverlay.classList.remove('hidden');
            
            if (state.method === 'compass') {
                mathContent.innerHTML = `
                    <ul class="list-disc pl-4 space-y-1">
                        <li>åœ¨ \(\triangle OCP\) å’Œ \(\triangle ODP\) ä¸­ï¼š</li>
                        <li>\(OC = OD\) (ç¬¬ä¸€æ­¥åŠå¾„)</li>
                        <li>\(CP = DP\) (ç¬¬äºŒæ­¥åŠå¾„)</li>
                        <li>\(OP = OP\) (å…¬å…±è¾¹)</li>
                        <li>\(\therefore \triangle OCP \cong \triangle ODP\) (SSS)</li>
                        <li>\(\therefore \angle COP = \angle DOP\)</li>
                    </ul>
                `;
            } else {
                mathContent.innerHTML = `
                    <ul class="list-disc pl-4 space-y-1">
                        <li>æ„å»ºç­‰è…° \(\triangle OCD\) (\(OC=OD\))</li>
                        <li>å–åº•è¾¹ \(CD\) ä¸­ç‚¹ \(M\)</li>
                        <li>ç”±"ä¸‰çº¿åˆä¸€"æ€§è´¨ï¼š</li>
                        <li>åº•è¾¹ä¸Šçš„ä¸­çº¿ \(OM\) ä¹Ÿæ˜¯é¡¶è§’çš„è§’å¹³åˆ†çº¿</li>
                        <li>\(\therefore OM\) å¹³åˆ† \(\angle AOB\)</li>
                    </ul>
                `;
            }
            // è§¦å‘ MathJax æ¸²æŸ“
            if (window.MathJax) {
                MathJax.typesetPromise([mathContent]);
            }
        }

        function updateStepDescription() {
            const m = state.method;
            const s = state.step;
            let text = "";

            if (m === 'compass') {
                const steps = [
                    "å‡†å¤‡ï¼šè®¾å®šè§’åº¦ï¼Œè§‚å¯Ÿè§’ AOBã€‚",
                    "ç¬¬1æ­¥ï¼šä»¥ç‚¹ O ä¸ºåœ†å¿ƒï¼Œä»»æ„é•¿ä¸ºåŠå¾„ç”»å¼§ï¼Œäº¤ OAã€OB äºç‚¹ Cã€Dã€‚",
                    "ç¬¬2æ­¥ï¼šä»¥ç‚¹ C ä¸ºåœ†å¿ƒï¼Œå¤§äº 1/2 CD é•¿ä¸ºåŠå¾„ç”»å¼§ã€‚",
                    "ç¬¬3æ­¥ï¼šä»¥ç‚¹ D ä¸ºåœ†å¿ƒï¼ŒåŒé•¿ä¸ºåŠå¾„ç”»å¼§ï¼Œä¸¤å¼§äº¤äºç‚¹ Pã€‚",
                    "ç¬¬4æ­¥ï¼šä½œå°„çº¿ OPï¼Œåˆ™ OP å³ä¸ºæ‰€æ±‚çš„è§’å¹³åˆ†çº¿ã€‚"
                ];
                text = steps[s];
            } else {
                const steps = [
                    "å‡†å¤‡ï¼šä½¿ç”¨æœ‰åˆ»åº¦çš„ç›´å°ºã€‚",
                    "ç¬¬1æ­¥ï¼šå°†å°ºå­0åˆ»åº¦å¯¹å‡† Oï¼Œåœ¨ OA ä¸Šé‡å–è·ç¦» kï¼Œæ ‡è®°ç‚¹ Cã€‚",
                    "ç¬¬2æ­¥ï¼šåŒæ ·åœ¨ OB ä¸Šé‡å–ç›¸åŒè·ç¦» kï¼Œæ ‡è®°ç‚¹ D (ä½¿ OC = OD)ã€‚",
                    "ç¬¬3æ­¥ï¼šè¿æ¥ CDï¼Œå¹¶ç”¨å°ºå­é‡å‡º CD çš„ä¸­ç‚¹ Mã€‚",
                    "ç¬¬4æ­¥ï¼šè¿æ¥ OMï¼Œå°„çº¿ OM å³ä¸ºè§’å¹³åˆ†çº¿ã€‚"
                ];
                text = steps[s];
            }
            descEl.textContent = text;
            indicatorEl.textContent = `${s} / ${state.maxSteps}`;
            
            // æ›´æ–° MathJaxï¼ˆå¦‚æœæœ‰å…¬å¼å˜åŒ–ï¼‰
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            if (state.isAnimating) {
                state.progress += 0.03; // åŠ¨ç”»é€Ÿåº¦
                if (state.progress >= 1) {
                    state.progress = 1;
                    state.isAnimating = false;
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        // --- äº‹ä»¶å¤„ç† ---

        function setMethod(m) {
            state.method = m;
            state.step = 0;
            state.progress = 0;
            state.isAnimating = false;
            
            // æ›´æ–°æŒ‰é’®æ ·å¼
            document.getElementById('btn-compass').className = m === 'compass' 
                ? "flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-l-lg hover:bg-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-500"
                : "flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-l-lg hover:bg-gray-50 focus:z-10 focus:ring-2 focus:ring-blue-500";
            
            document.getElementById('btn-ruler').className = m === 'ruler'
                ? "flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-r-lg hover:bg-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-500"
                : "flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-r-lg hover:bg-gray-50 focus:z-10 focus:ring-2 focus:ring-blue-500";

            updateStepDescription();
        }

        function nextStep() {
            if (state.step < state.maxSteps) {
                state.step++;
                state.progress = 0;
                state.isAnimating = true;
                updateStepDescription();
            }
        }

        function prevStep() {
            if (state.step > 0) {
                state.step--;
                state.progress = 1; // å›é€€æ—¶ç›´æ¥æ˜¾ç¤ºå®Œæˆæ€ï¼Œæˆ–è€…è®¾ä¸º0çœ‹éœ€æ±‚
                state.isAnimating = false;
                updateStepDescription();
            }
        }

        function resetDemo() {
            state.step = 0;
            state.progress = 0;
            state.isAnimating = false;
            updateStepDescription();
        }

        // ç›‘å¬æ»‘å—
        document.getElementById('angle-slider').addEventListener('input', (e) => {
            state.angleDeg = parseInt(e.target.value);
            document.getElementById('angle-val').textContent = state.angleDeg + "Â°";
            // è§’åº¦æ”¹å˜æ—¶ï¼Œä¸éœ€è¦é‡ç½®æ­¥éª¤ï¼Œä½†è¦é‡ç»˜
            draw();
        });

        // ç›‘å¬å¼€å…³
        document.getElementById('show-labels').addEventListener('change', (e) => state.showLabels = e.target.checked);
        document.getElementById('show-aux').addEventListener('change', (e) => state.showAux = e.target.checked);
        document.getElementById('show-principle').addEventListener('change', (e) => {
            state.showPrinciple = e.target.checked;
            updateMathOverlay();
        });

        // å“åº”å¼ Canvas å¤§å°
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            state.width = canvas.width;
            state.height = canvas.height;
            state.center.x = state.width / 2;
            state.center.y = state.height * 0.85; // Oç‚¹åœ¨ä¸‹æ–¹
            state.armLength = Math.min(state.width, state.height) * 0.6;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);

        // åˆå§‹åŒ–
        resizeCanvas();
        updateStepDescription();
        animate(); // å¯åŠ¨å¾ªç¯

    </script>
</body>
</html>