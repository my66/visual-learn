<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¹³é¢é•œæˆåƒä¸è¿åŠ¨è½¨è¿¹æ¼”ç¤º - ç¬¬11é¢˜å¯è§†åŒ–</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #f1f5f9; height: 100vh; margin: 0; overflow: hidden; }
        .canvas-container { cursor: crosshair; }
        /* æ›´åŠ æ˜æ˜¾çš„æ»‘å—æ ·å¼ */
        .slider-thumb::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; background: #16a34a; border: 3px solid white; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .slider-thumb::-moz-range-thumb { width: 24px; height: 24px; background: #16a34a; border: 3px solid white; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const degreesToRadians = (deg) => deg * (Math.PI / 180);
        const radiansToDegrees = (rad) => rad * (180 / Math.PI);

        // --- æ ¸å¿ƒç®—æ³• ---
        const reflectPoint = (px, py, mx, my, angleDeg) => {
            const angleRad = degreesToRadians(angleDeg);
            const x = px - mx;
            const y = py - my;
            const lx = Math.cos(angleRad);
            const ly = Math.sin(angleRad);
            const dot = x * lx + y * ly;
            const footX = mx + dot * lx;
            const footY = my + dot * ly;
            const rx = 2 * footX - px;
            const ry = 2 * footY - py;
            return { x: rx, y: ry, footX, footY };
        };

        const App = () => {
            // --- çŠ¶æ€ ---
            const [candleX, setCandleX] = useState(250); // åˆå§‹ä½ç½®
            const [mirrorAngle, setMirrorAngle] = useState(225); // é»˜è®¤ 45åº¦(åƒåœ¨ä¸Š)
            const [showConnectLine, setShowConnectLine] = useState(true);
            const [showTrajectory, setShowTrajectory] = useState(true);
            const [isAutoPlaying, setIsAutoPlaying] = useState(false);

            // --- åæ ‡ç³»è®¾ç½® (å¤§å°ºå¯¸æ¨¡å¼) ---
            // ä½¿ç”¨è¾ƒå°çš„é€»è¾‘åˆ†è¾¨ç‡ï¼Œè®©å…ƒç´ çœ‹èµ·æ¥æ›´å¤§
            const viewWidth = 1200;
            const viewHeight = 900; 
            
            // åœºæ™¯å¸ƒå±€
            const tableY = 450; // å‚ç›´å±…ä¸­
            const mirrorBaseX = 800; // é•œå­åŸºç‚¹
            const mirrorBaseY = tableY;
            const candleY = tableY; 

            // å…ƒç´ å°ºå¯¸ (æ”¾å¤§2å€)
            const candleW = 40;  // ä¹‹å‰æ˜¯20
            const candleH = 100; // ä¹‹å‰æ˜¯60
            const mirrorLen = 500; // é•œå­é•¿åº¦

            // ViewBox: èšç„¦äºæ ¸å¿ƒåŒºåŸŸ
            // x: -50 åˆ° 1150 (å®½1200)
            // y: -100 åˆ° 800 (é«˜900)
            const viewBoxStr = `-50 -100 ${viewWidth} ${viewHeight}`;

            const animationRef = useRef();
            const trajectoryRef = useRef([]);

            // é•œå­ç«¯ç‚¹è®¡ç®—
            const mirrorTipX = mirrorBaseX + mirrorLen * Math.cos(degreesToRadians(mirrorAngle));
            const mirrorTipY = mirrorBaseY + mirrorLen * Math.sin(degreesToRadians(mirrorAngle));
            
            // ç‰©ä½“åæ ‡
            const objBase = { x: candleX, y: candleY };
            const objTop = { x: candleX, y: candleY - candleH };
            
            // åƒåæ ‡
            const refBase = reflectPoint(objBase.x, objBase.y, mirrorBaseX, mirrorBaseY, mirrorAngle);
            const refTop = reflectPoint(objTop.x, objTop.y, mirrorBaseX, mirrorBaseY, mirrorAngle);

            // åƒçš„æ—‹è½¬è§’åº¦
            const dx = refTop.x - refBase.x;
            const dy = refTop.y - refBase.y;
            const imageRotationDeg = radiansToDegrees(Math.atan2(dy, dx));
            const rotationTransform = imageRotationDeg + 90;

            // åƒçš„è¿åŠ¨æ–¹å‘è®¡ç®—
            const imageMoveDir = (2 * mirrorAngle) % 360; 
            const isVerticalMove = Math.abs((imageMoveDir % 180) - 90) < 1;
            const isHorizontalMove = Math.abs(imageMoveDir % 180) < 1;
            const displayAngle = Math.abs(180 - (mirrorAngle % 180));

            // åŠ¨ç”»å¾ªç¯
            useEffect(() => {
                if (isAutoPlaying) {
                    const animate = () => {
                        setCandleX(prev => {
                            if (prev >= mirrorBaseX - 120) { // ç¢°åˆ°é•œå­å‰åœæ­¢
                                setIsAutoPlaying(false);
                                return prev;
                            }
                            return prev + 3; // é€Ÿåº¦
                        });
                        animationRef.current = requestAnimationFrame(animate);
                    };
                    animationRef.current = requestAnimationFrame(animate);
                } else {
                    cancelAnimationFrame(animationRef.current);
                }
                return () => cancelAnimationFrame(animationRef.current);
            }, [isAutoPlaying, mirrorBaseX]);

            // è½¨è¿¹é€»è¾‘
            useEffect(() => {
                if (showTrajectory) {
                    trajectoryRef.current.push({ ox: objTop.x, oy: objTop.y, ix: refTop.x, iy: refTop.y });
                    if (trajectoryRef.current.length > 400) trajectoryRef.current.shift();
                } else {
                    trajectoryRef.current = [];
                }
            }, [candleX, showTrajectory, mirrorAngle]);

            // è§’åº¦æ”¹å˜æ¸…ç©ºè½¨è¿¹
            useEffect(() => {
                trajectoryRef.current = [];
            }, [mirrorAngle]);

            const handleReset = () => {
                setCandleX(250);
                setIsAutoPlaying(false);
                trajectoryRef.current = [];
            };

            return (
                <div className="flex w-full h-full bg-slate-100">
                    
                    {/* å·¦ä¾§ï¼šæ§åˆ¶é¢æ¿ (å›ºå®šå®½åº¦ 320px) */}
                    <div className="w-80 flex-shrink-0 bg-white shadow-xl z-20 flex flex-col border-r border-gray-200 h-full overflow-y-auto">
                        
                        {/* æ ‡é¢˜åŒº */}
                        <div className="p-5 border-b border-gray-100 bg-slate-50">
                            <h1 className="text-xl font-bold text-gray-800 leading-tight">ç¬¬11é¢˜<br/>å¹³é¢é•œæˆåƒå¯è§†åŒ–</h1>
                            <div className="mt-2 text-xs text-green-600 bg-green-50 inline-block px-2 py-1 rounded font-medium border border-green-100">
                                å…¨å±é«˜æ¸…æ¼”ç¤ºç‰ˆ
                            </div>
                        </div>

                        <div className="p-5 flex flex-col gap-6">
                            
                            {/* è§’åº¦æ§åˆ¶ */}
                            <div className="space-y-3 bg-blue-50 p-4 rounded-xl border border-blue-100">
                                <div className="flex justify-between items-center">
                                    <label className="font-bold text-blue-900 text-sm">é•œé¢è§’åº¦ (Î±)</label>
                                    <span className="bg-white text-blue-700 px-2 py-0.5 rounded text-sm font-mono font-bold shadow-sm">
                                        {Math.round(displayAngle)}Â°
                                    </span>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={() => setMirrorAngle(225)} className={`flex-1 py-2 text-xs font-bold rounded shadow-sm transition-all ${Math.abs(mirrorAngle - 225) < 1 ? 'bg-blue-600 text-white ring-2 ring-blue-300' : 'bg-white text-blue-600 hover:bg-blue-100'}`}>
                                        45Â°(åƒåœ¨ä¸Š)
                                    </button>
                                    <button onClick={() => setMirrorAngle(315)} className={`flex-1 py-2 text-xs font-bold rounded shadow-sm transition-all ${Math.abs(mirrorAngle - 315) < 1 ? 'bg-blue-600 text-white ring-2 ring-blue-300' : 'bg-white text-blue-600 hover:bg-blue-100'}`}>
                                        45Â°(åƒåœ¨ä¸‹)
                                    </button>
                                </div>
                                <input 
                                    type="range" min="180" max="360" step="1" 
                                    value={mirrorAngle} 
                                    onChange={(e) => setMirrorAngle(Number(e.target.value))}
                                    className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer slider-thumb accent-blue-600"
                                />
                            </div>

                            {/* è¿åŠ¨æ§åˆ¶ */}
                            <div className="space-y-4">
                                <div>
                                    <div className="flex justify-between mb-2">
                                        <label className="font-bold text-gray-700 text-sm">èœ¡çƒ›ä½ç½®</label>
                                        <div className="flex gap-2">
                                            <button onClick={() => setIsAutoPlaying(!isAutoPlaying)} className={`px-3 py-1 text-xs rounded font-bold transition-colors ${isAutoPlaying ? 'bg-amber-100 text-amber-700' : 'bg-green-600 text-white shadow-sm hover:bg-green-700'}`}>
                                                {isAutoPlaying ? 'æš‚åœ' : 'æ’­æ”¾'}
                                            </button>
                                            <button onClick={handleReset} className="px-3 py-1 text-xs bg-gray-100 text-gray-600 rounded font-bold hover:bg-gray-200">
                                                é‡ç½®
                                            </button>
                                        </div>
                                    </div>
                                    <input 
                                        type="range" min="100" max="700" 
                                        value={candleX} 
                                        onChange={(e) => { setCandleX(Number(e.target.value)); setIsAutoPlaying(false); }}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-thumb"
                                    />
                                </div>
                            </div>

                            {/* æ˜¾ç¤ºé€‰é¡¹ */}
                            <div className="space-y-3 pt-2 border-t border-gray-100">
                                <label className="flex items-center gap-3 cursor-pointer group">
                                    <div className={`w-5 h-5 rounded border flex items-center justify-center transition-colors ${showTrajectory ? 'bg-green-500 border-green-500' : 'bg-white border-gray-300'}`}>
                                        {showTrajectory && <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7" /></svg>}
                                    </div>
                                    <input type="checkbox" checked={showTrajectory} onChange={(e) => setShowTrajectory(e.target.checked)} className="hidden" />
                                    <span className="text-sm font-medium text-gray-700 group-hover:text-green-700">æ˜¾ç¤ºè¿åŠ¨è½¨è¿¹</span>
                                </label>
                                <label className="flex items-center gap-3 cursor-pointer group">
                                    <div className={`w-5 h-5 rounded border flex items-center justify-center transition-colors ${showConnectLine ? 'bg-green-500 border-green-500' : 'bg-white border-gray-300'}`}>
                                        {showConnectLine && <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7" /></svg>}
                                    </div>
                                    <input type="checkbox" checked={showConnectLine} onChange={(e) => setShowConnectLine(e.target.checked)} className="hidden" />
                                    <span className="text-sm font-medium text-gray-700 group-hover:text-green-700">æ˜¾ç¤ºç‰©åƒè¿çº¿</span>
                                </label>
                            </div>

                            <div className="mt-auto bg-amber-50 p-4 rounded-lg border border-amber-100 text-amber-900 text-sm leading-relaxed">
                                <strong>ğŸ’¡ ç‰©ç†è§„å¾‹ï¼š</strong><br/>
                                æ‹–åŠ¨é•œå­è§’åº¦æ»‘å—ã€‚å½“è§’åº¦ä¸º <span className="font-bold">45Â°</span> æ—¶ï¼Œæ°´å¹³è¿åŠ¨çš„èœ¡çƒ›ï¼Œå…¶åƒåš <span className="font-bold border-b-2 border-amber-400">ç«–ç›´è¿åŠ¨</span>ã€‚
                            </div>
                        </div>
                    </div>

                    {/* å³ä¾§ï¼šç”»å¸ƒåŒºåŸŸ (å æ»¡å‰©ä½™ç©ºé—´) */}
                    <div className="flex-1 relative bg-slate-50 overflow-hidden">
                        {/* è£…é¥°æ€§ç½‘æ ¼èƒŒæ™¯ */}
                        <div className="absolute inset-0" style={{backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', backgroundSize: '40px 40px', opacity: 0.3}}></div>

                        <svg 
                            className="w-full h-full absolute inset-0 canvas-container"
                            viewBox={viewBoxStr}
                            preserveAspectRatio="xMidYMid meet" 
                        >
                            <defs>
                                <marker id="arrow" markerWidth="8" markerHeight="8" refX="7" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                                </marker>
                                {/* é˜´å½±æ»¤é•œï¼Œå¢åŠ ç«‹ä½“æ„Ÿ */}
                                <filter id="dropShadow" x="-20%" y="-20%" width="150%" height="150%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
                                    <feOffset dx="4" dy="4" result="offsetblur"/>
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.2"/>
                                    </feComponentTransfer>
                                    <feMerge> 
                                        <feMergeNode in="offsetblur"/>
                                        <feMergeNode in="SourceGraphic"/> 
                                    </feMerge>
                                </filter>
                            </defs>

                            {/* åŠ¨æ€ç»“è®ºæ ‡é¢˜ (æ˜¾ç¤ºåœ¨ç”»å¸ƒæ­£ä¸Šæ–¹) */}
                            <g transform={`translate(${viewWidth/2}, 50)`} textAnchor="middle">
                                <text y="0" fontSize="32" fill="#334155" fontWeight="800" textAnchor="middle">
                                    åƒçš„è¿åŠ¨æ–¹å‘ï¼š
                                    {isVerticalMove ? 
                                        <tspan fill="#16a34a">ç«–ç›´{Math.sin(degreesToRadians(imageMoveDir)) > 0 ? "å‘ä¸‹" : "å‘ä¸Š"}</tspan> 
                                        : (isHorizontalMove ? <tspan fill="#d97706">æ°´å¹³{Math.cos(degreesToRadians(imageMoveDir)) > 0 ? "å‘å³" : "å‘å·¦"}</tspan> 
                                        : <tspan fill="#64748b">å€¾æ–œæ–¹å‘</tspan>)
                                    }
                                </text>
                                <text y="40" fontSize="20" fill="#64748b" fontWeight="normal" textAnchor="middle">
                                    ( é•œé¢è§’åº¦: {Math.round(displayAngle)}Â° )
                                </text>
                            </g>

                            {/* æ¡Œé¢ */}
                            <line x1="-100" y1={tableY} x2="1300" y2={tableY} stroke="#334155" strokeWidth="6" />
                            <text x="50" y={tableY + 40} fill="#64748b" fontSize="24" fontWeight="bold">æ°´å¹³æ¡Œé¢</text>

                            {/* é•œå­ (åŠ å®½åŠ ç²—) */}
                            <g filter="url(#dropShadow)">
                                <line 
                                    x1={mirrorBaseX} y1={mirrorBaseY} 
                                    x2={mirrorTipX} y2={mirrorTipY} 
                                    stroke="#3b82f6" strokeWidth="12" strokeLinecap="round" 
                                />
                                <line 
                                    x1={mirrorBaseX} y1={mirrorBaseY} 
                                    x2={mirrorTipX} y2={mirrorTipY} 
                                    stroke="#93c5fd" strokeWidth="6" strokeLinecap="round" 
                                />
                            </g>
                            <text x={mirrorTipX} y={mirrorTipY - 30} fill="#2563eb" fontSize="24" fontWeight="bold">å¹³é¢é•œ</text>

                            {/* è¿çº¿å±‚ (åœ¨ä¸‹å±‚) */}
                            {showConnectLine && (
                                <g opacity="0.6">
                                    <line x1={objTop.x} y1={objTop.y} x2={refTop.x} y2={refTop.y} stroke="#94a3b8" strokeWidth="3" strokeDasharray="10 6" />
                                    <line x1={objBase.x} y1={objBase.y} x2={refBase.x} y2={refBase.y} stroke="#94a3b8" strokeWidth="3" strokeDasharray="10 6" />
                                    <circle cx={refTop.footX} cy={refTop.footY} r="6" fill="#94a3b8"/>
                                </g>
                            )}

                            {/* è½¨è¿¹å±‚ */}
                            {showTrajectory && (
                                <g>
                                    <polyline points={trajectoryRef.current.map(p => `${p.ox},${p.oy}`).join(' ')} fill="none" stroke="#fbbf24" strokeWidth="6" opacity="0.6" />
                                    <polyline points={trajectoryRef.current.map(p => `${p.ix},${p.iy}`).join(' ')} fill="none" stroke="#10b981" strokeWidth="6" opacity="0.6" strokeDasharray="8 8" />
                                </g>
                            )}

                            {/* ç‰©ä½“ A (èœ¡çƒ›æ”¾å¤§ç‰ˆ) */}
                            <g transform={`translate(${candleX}, ${candleY})`} filter="url(#dropShadow)">
                                {/* èœ¡çƒ›èº« */}
                                <rect x={-candleW/2} y={-candleH} width={candleW} height={candleH} fill="#ef4444" stroke="#b91c1c" strokeWidth="3" rx="4" />
                                {/* çƒ›èŠ¯ */}
                                <line x1="0" y1={-candleH} x2="0" y2={-candleH - 8} stroke="#333" strokeWidth="3" />
                                {/* ç«ç„°åŠ¨ç”» */}
                                <g className="animate-pulse origin-bottom" style={{transformBox: 'fill-box', transformOrigin: 'center bottom'}}>
                                    <path d={`M0,${-candleH-8} Q${-10},${-candleH-25} 0,${-candleH-40} Q${10},${-candleH-25} 0,${-candleH-8}`} fill="#fbbf24" />
                                    <path d={`M0,${-candleH-8} Q${-5},${-candleH-20} 0,${-candleH-30} Q${5},${-candleH-20} 0,${-candleH-8}`} fill="#f59e0b" />
                                </g>
                                <text x="0" y="40" textAnchor="middle" fontSize="28" fill="#333" fontWeight="bold">A</text>
                                {/* é€Ÿåº¦ç®­å¤´ */}
                                {isAutoPlaying && <line x1={candleW} y1={-candleH/2} x2={candleW + 60} y2={-candleH/2} stroke="#ef4444" strokeWidth="6" markerEnd="url(#arrow)" />}
                            </g>

                            {/* åƒ A' (èœ¡çƒ›æ”¾å¤§ç‰ˆ) */}
                            <g transform={`translate(${refBase.x}, ${refBase.y}) rotate(${rotationTransform})`} opacity="0.8">
                                <rect x={-candleW/2} y={-candleH} width={candleW} height={candleH} fill="#10b981" fillOpacity="0.3" stroke="#059669" strokeWidth="3" strokeDasharray="8 4" rx="4" />
                                <line x1="0" y1={-candleH} x2="0" y2={-candleH - 8} stroke="#059669" strokeWidth="2" />
                                <g opacity="0.6">
                                    <path d={`M0,${-candleH-8} Q${-10},${-candleH-25} 0,${-candleH-40} Q${10},${-candleH-25} 0,${-candleH-8}`} fill="#fbbf24" />
                                </g>
                                {/* æ–‡å­—åå‘æ—‹è½¬ */}
                                <text x="0" y="-120" textAnchor="middle" fontSize="28" fill="#059669" fontWeight="bold" transform={`rotate(${-rotationTransform})`}>åƒ A'</text>
                            </g>

                            {/* åƒçš„é€Ÿåº¦ç®­å¤´ (ç‹¬ç«‹åæ ‡ç³») */}
                            {isAutoPlaying && (
                                <g transform={`translate(${refTop.x}, ${refTop.y}) rotate(${imageMoveDir - 90})`}> 
                                    <line x1="0" y1="0" x2="80" y2="0" stroke="#10b981" strokeWidth="6" markerEnd="url(#arrow)" />
                                </g>
                            )}

                        </svg>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>