<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‰çš„æŠ˜å°„ - äº’åŠ¨å¯è§†åŒ–æ¼”ç¤º</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f3f4f6;
            user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }
        canvas {
            touch-action: none; /* é˜»æ­¢ç§»åŠ¨ç«¯é»˜è®¤æ»šåŠ¨ï¼Œä¿è¯æ‹–åŠ¨ä½“éªŒ */
            cursor: pointer;
        }
        .control-group {
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .label-switch {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            cursor: pointer;
        }
        .label-switch input {
            margin-right: 0.5rem;
            width: 1.2rem;
            height: 1.2rem;
        }
        /* æ»‘å—æ ·å¼ä¼˜åŒ– */
        input[type=range] {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            transition: background .15s ease-in-out;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #2563eb;
        }
        .math-text {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
    </style>
</head>
<body class="h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div class="w-full md:w-1/3 p-4 overflow-y-auto border-r border-gray-200 bg-gray-50 flex flex-col">
        <h1 class="text-2xl font-bold text-gray-800 mb-2">å…‰çš„æŠ˜å°„å¯è§†åŒ–</h1>
        <p class="text-sm text-gray-600 mb-4 bg-yellow-50 p-2 rounded border border-yellow-200">
            <strong>é¢˜ç›®å¤§æ„/åŸç†ï¼š</strong><br>
            å…‰ä»ä¸€ç§ä»‹è´¨æ–œå°„å…¥å¦ä¸€ç§ä»‹è´¨æ—¶ï¼Œä¼ æ’­æ–¹å‘å‘ç”Ÿæ”¹å˜ã€‚éµå®ˆæ–¯æ¶…å°”å®šå¾‹ï¼š
            <span class="math-text font-bold">nâ‚ sin Î¸â‚ = nâ‚‚ sin Î¸â‚‚</span>ã€‚
            <br>è¯·æ‹–åŠ¨å³ä¾§å…‰çº¿æˆ–è°ƒèŠ‚ä¸‹æ–¹å‚æ•°è§‚å¯Ÿç°è±¡ã€‚
        </p>

        <!-- ä»‹è´¨å‚æ•°æ§åˆ¶ -->
        <div class="control-group">
            <h3 class="font-bold text-gray-700 mb-3 border-b pb-1">ä»‹è´¨è®¾ç½®</h3>
            
            <div class="mb-4">
                <div class="flex justify-between mb-1">
                    <label class="text-sm font-medium text-blue-700">ä¸Šæ–¹ä»‹è´¨æŠ˜å°„ç‡ (nâ‚)</label>
                    <span id="val-n1" class="text-sm font-bold text-blue-700">1.00 (ç©ºæ°”)</span>
                </div>
                <input type="range" id="input-n1" min="1.00" max="2.50" step="0.01" value="1.00">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>çœŸç©º/ç©ºæ°”</span>
                    <span>æ°´</span>
                    <span>ç»ç’ƒ</span>
                    <span>é’»çŸ³</span>
                </div>
            </div>

            <div class="mb-2">
                <div class="flex justify-between mb-1">
                    <label class="text-sm font-medium text-cyan-700">ä¸‹æ–¹ä»‹è´¨æŠ˜å°„ç‡ (nâ‚‚)</label>
                    <span id="val-n2" class="text-sm font-bold text-cyan-700">1.33 (æ°´)</span>
                </div>
                <input type="range" id="input-n2" min="1.00" max="2.50" step="0.01" value="1.33">
            </div>
        </div>

        <!-- å¯è§†åŒ–å¼€å…³ -->
        <div class="control-group">
            <h3 class="font-bold text-gray-700 mb-3 border-b pb-1">å›¾å±‚/æ¦‚å¿µå¼€å…³</h3>
            <label class="label-switch">
                <input type="checkbox" id="check-normal" checked>
                <span>æ˜¾ç¤ºæ³•çº¿ (Normal)</span>
            </label>
            <label class="label-switch">
                <input type="checkbox" id="check-angles" checked>
                <span>æ˜¾ç¤ºè§’åº¦æ•°å€¼ (Î¸â‚, Î¸â‚‚)</span>
            </label>
            <label class="label-switch">
                <input type="checkbox" id="check-reflection" checked>
                <span>æ˜¾ç¤ºåå°„å…‰çº¿</span>
            </label>
             <label class="label-switch">
                <input type="checkbox" id="check-component">
                <span>æ˜¾ç¤ºé€Ÿåº¦åˆ†é‡ç¤ºæ„ (ä»…ç¤ºæ„)</span>
            </label>
        </div>

        <!-- å®æ—¶æ•°æ®çœ‹æ¿ -->
        <div class="control-group bg-blue-50 border border-blue-100">
            <h3 class="font-bold text-gray-700 mb-2">å½“å‰çŠ¶æ€</h3>
            <div class="grid grid-cols-2 gap-2 text-sm">
                <div>å…¥å°„è§’ Î¸â‚: <span id="disp-angle1" class="font-mono font-bold">45.0Â°</span></div>
                <div>æŠ˜å°„è§’ Î¸â‚‚: <span id="disp-angle2" class="font-mono font-bold">32.1Â°</span></div>
            </div>
            <div id="tir-warning" class="hidden mt-2 text-red-600 font-bold text-center animate-pulse">
                âš ï¸ å‘ç”Ÿå…¨åå°„ (Total Internal Reflection)
            </div>
            <div id="formula-display" class="mt-2 text-xs text-gray-500 text-center font-mono pt-2 border-t border-blue-200">
                1.00 Ã— sin(45Â°) â‰ˆ 1.33 Ã— sin(32.1Â°)
            </div>
        </div>
    </div>

    <!-- å³ä¾§å¯è§†åŒ–åŒºåŸŸ -->
    <div class="w-full md:w-2/3 relative bg-gray-200 flex items-center justify-center overflow-hidden" id="canvas-container">
        <!-- Canvas å°†åœ¨è¿™é‡Œç»˜åˆ¶ -->
        <canvas id="simCanvas" class="bg-white shadow-lg rounded-lg"></canvas>
        
        <!-- æ“ä½œæç¤ºæµ®å±‚ -->
        <div class="absolute top-4 right-4 bg-white/80 backdrop-blur px-3 py-1 rounded text-sm text-gray-600 pointer-events-none border border-gray-300">
            ğŸ’¡ æç¤ºï¼šæ‹–åŠ¨æ¿€å…‰ç¬”æ”¹å˜å…¥å°„è§’åº¦
        </div>
    </div>

<script>
/**
 * ç‰©ç†ä¸ç»˜å›¾é€»è¾‘æ ¸å¿ƒ
 */

// çŠ¶æ€ç®¡ç†
const state = {
    n1: 1.00,       // ä¸Šæ–¹ä»‹è´¨æŠ˜å°„ç‡
    n2: 1.33,       // ä¸‹æ–¹ä»‹è´¨æŠ˜å°„ç‡
    angleInc: 45,   // å…¥å°„è§’ (åº¦)ï¼Œç›¸å¯¹äºæ³•çº¿
    isDragging: false,
    
    // æ˜¾ç¤ºå¼€å…³
    showNormal: true,
    showAngles: true,
    showReflection: true,
    showComponent: false
};

// DOM å…ƒç´ å¼•ç”¨
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

// UI å…ƒç´ 
const elN1 = document.getElementById('input-n1');
const elN2 = document.getElementById('input-n2');
const txtN1 = document.getElementById('val-n1');
const txtN2 = document.getElementById('val-n2');
const txtA1 = document.getElementById('disp-angle1');
const txtA2 = document.getElementById('disp-angle2');
const elWarn = document.getElementById('tir-warning');
const elFormula = document.getElementById('formula-display');

// å¼€å…³å…ƒç´ 
const chkNormal = document.getElementById('check-normal');
const chkAngles = document.getElementById('check-angles');
const chkReflection = document.getElementById('check-reflection');
const chkComponent = document.getElementById('check-component');

// ç‰©ç†å¸¸é‡ä¸ç»˜å›¾é…ç½®
const PADDING = 20;
const CENTER_Y_RATIO = 0.5; // ç•Œé¢çº¿åœ¨ç”»å¸ƒå‚ç›´æ–¹å‘çš„æ¯”ä¾‹

// åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬
function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ç»‘å®šæ»‘å—
    elN1.addEventListener('input', (e) => {
        state.n1 = parseFloat(e.target.value);
        updateUI();
        draw();
    });
    elN2.addEventListener('input', (e) => {
        state.n2 = parseFloat(e.target.value);
        updateUI();
        draw();
    });

    // ç»‘å®šå¼€å…³
    chkNormal.addEventListener('change', (e) => { state.showNormal = e.target.checked; draw(); });
    chkAngles.addEventListener('change', (e) => { state.showAngles = e.target.checked; draw(); });
    chkReflection.addEventListener('change', (e) => { state.showReflection = e.target.checked; draw(); });
    chkComponent.addEventListener('change', (e) => { state.showComponent = e.target.checked; draw(); });

    // é¼ æ ‡/è§¦æ§äº¤äº’
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', handleDrag);
    window.addEventListener('mouseup', stopDrag);
    
    canvas.addEventListener('touchstart', startDrag, {passive: false});
    canvas.addEventListener('touchmove', handleDrag, {passive: false});
    window.addEventListener('touchend', stopDrag);

    updateUI();
    draw();
}

function resizeCanvas() {
    canvas.width = container.clientWidth - PADDING * 2;
    canvas.height = container.clientHeight - PADDING * 2;
    draw();
}

function updateUI() {
    // æ›´æ–°æ»‘å—æ—è¾¹çš„æ–‡å­—
    txtN1.textContent = `${state.n1.toFixed(2)} (${getMediumName(state.n1)})`;
    txtN2.textContent = `${state.n2.toFixed(2)} (${getMediumName(state.n2)})`;
    
    // æ›´æ–°èƒŒæ™¯é¢œè‰²ç¤ºæ„ (æŠ˜å°„ç‡è¶Šå¤§é¢œè‰²è¶Šæ·±)
    // é€»è¾‘åœ¨ draw å‡½æ•°ä¸­å¤„ç†
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®æŠ˜å°„ç‡çŒœæµ‹ä»‹è´¨åç§°
function getMediumName(n) {
    if (n < 1.01) return 'æ¥è¿‘çœŸç©º/ç©ºæ°”';
    if (n >= 1.30 && n <= 1.36) return 'æ°´';
    if (n >= 1.45 && n <= 1.60) return 'ç»ç’ƒ';
    if (n >= 2.40) return 'é’»çŸ³';
    return 'è‡ªå®šä¹‰ä»‹è´¨';
}

// æ ¸å¿ƒè®¡ç®—ä¸ç»˜åˆ¶å‡½æ•°
function draw() {
    const w = canvas.width;
    const h = canvas.height;
    const cy = h * CENTER_Y_RATIO;
    const cx = w / 2;
    
    // æ¸…ç©º
    ctx.clearRect(0, 0, w, h);

    // 1. ç»˜åˆ¶ä»‹è´¨èƒŒæ™¯
    // ä»‹è´¨1 (ä¸Š)
    const opacity1 = (state.n1 - 1) * 0.3; 
    ctx.fillStyle = `rgba(59, 130, 246, ${Math.max(0.05, opacity1)})`; // Blue base
    ctx.fillRect(0, 0, w, cy);
    
    // ä»‹è´¨2 (ä¸‹)
    const opacity2 = (state.n2 - 1) * 0.3;
    ctx.fillStyle = `rgba(6, 182, 212, ${Math.max(0.05, opacity2)})`; // Cyan base
    ctx.fillRect(0, cy, w, h - cy);

    // 2. ç»˜åˆ¶åˆ†ç•Œçº¿
    ctx.beginPath();
    ctx.moveTo(0, cy);
    ctx.lineTo(w, cy);
    ctx.strokeStyle = '#374151'; // Gray-700
    ctx.lineWidth = 3;
    ctx.stroke();

    // 3. ç»˜åˆ¶æ³•çº¿ (Normal)
    if (state.showNormal) {
        ctx.beginPath();
        ctx.setLineDash([10, 5]);
        ctx.moveTo(cx, PADDING);
        ctx.lineTo(cx, h - PADDING);
        ctx.strokeStyle = '#6B7280'; // Gray-500
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);
        
        // æ³•çº¿æ ‡ç­¾
        ctx.fillStyle = '#6B7280';
        ctx.font = '12px Arial';
        ctx.fillText('N (æ³•çº¿)', cx + 5, PADDING + 10);
    }

    // --- ç‰©ç†è®¡ç®— ---
    // å°†è§’åº¦è½¬æ¢ä¸ºå¼§åº¦è¿›è¡Œè®¡ç®—
    // æ³¨æ„ï¼šstate.angleInc æ˜¯å…¥å°„è§’ï¼Œå³å…‰çº¿ä¸æ³•çº¿çš„å¤¹è§’
    // è®¡ç®—æœºåæ ‡ç³»ä¸­ï¼Œå‚ç›´å‘ä¸Šæ˜¯ -90åº¦ (-PI/2)ã€‚
    // å…¥å°„å…‰çº¿åœ¨ç¬¬äºŒè±¡é™(å·¦ä¸Š)ã€‚
    // å…¥å°„å…‰çº¿å‘é‡è§’åº¦ = -90 - angleInc (å¦‚æœ angleInc æ˜¯æ­£å€¼)
    // ä¸ºäº†æ–¹ä¾¿è®¡ç®—ï¼Œæˆ‘ä»¬å®šä¹‰ angle1 ä¸ºå¼§åº¦
    
    const theta1Rad = state.angleInc * Math.PI / 180;
    
    // æ–¯æ¶…å°”å®šå¾‹: n1 * sin(t1) = n2 * sin(t2)
    // sin(t2) = (n1 / n2) * sin(t1)
    const sinTheta2 = (state.n1 / state.n2) * Math.sin(theta1Rad);
    
    let isTIR = false; // æ˜¯å¦å…¨åå°„
    let theta2Rad = 0;

    if (Math.abs(sinTheta2) > 1.000001) { // æµ®ç‚¹å®¹é”™
        isTIR = true;
    } else {
        theta2Rad = Math.asin(Math.min(1, Math.max(-1, sinTheta2)));
    }

    // ç»˜å›¾åŠå¾„
    const rayLength = Math.min(w, h) * 0.45;

    // --- 4. ç»˜åˆ¶å…¥å°„å…‰çº¿ (Incident Ray) ---
    // å…¥å°„å…‰èµ·ç‚¹ (é¼ æ ‡æ§åˆ¶çš„ç‚¹)
    // åæ ‡è®¡ç®—: x = cx - r * sin(t1), y = cy - r * cos(t1)
    const incX = cx - rayLength * Math.sin(theta1Rad);
    const incY = cy - rayLength * Math.cos(theta1Rad);

    // ç»˜åˆ¶å…‰çº¿
    ctx.beginPath();
    ctx.moveTo(incX, incY);
    ctx.lineTo(cx, cy);
    ctx.strokeStyle = '#DC2626'; // Red-600
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // ç»˜åˆ¶ç®­å¤´
    drawArrow(incX, incY, cx, cy, '#DC2626');

    // å…‰æºæ‰‹æŸ„ (è®©ç”¨æˆ·çŸ¥é“è¿™é‡Œå¯ä»¥æ‹–åŠ¨)
    ctx.beginPath();
    ctx.arc(incX, incY, 12, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.strokeStyle = '#DC2626';
    ctx.lineWidth = 2;
    ctx.stroke();
    // æ‰‹æŸ„å†…ç‚¹
    ctx.beginPath();
    ctx.arc(incX, incY, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#DC2626';
    ctx.fill();


    // --- 5. ç»˜åˆ¶åå°„å…‰çº¿ (Reflected Ray) ---
    // åå°„å®šå¾‹: åå°„è§’ = å…¥å°„è§’
    // å³ä½¿å‘ç”ŸæŠ˜å°„ï¼Œåå°„å…‰çº¿é€šå¸¸ä¹Ÿå­˜åœ¨ï¼ˆè™½ç„¶èƒ½é‡ä¼šåˆ†æµï¼Œä½†ä¸ºäº†ç‰©ç†å®Œæ•´æ€§æˆ–TIRï¼Œæˆ‘ä»¬ç»˜åˆ¶å®ƒï¼‰
    // å¦‚æœæ˜¯å…¨åå°„ï¼Œåå°„å…‰çº¿æ›´å¼º(ç”»ç²—ç‚¹)ï¼Œå¦åˆ™ç»†ç‚¹
    if (state.showReflection || isTIR) {
        const refX = cx + rayLength * Math.sin(theta1Rad);
        const refY = cy - rayLength * Math.cos(theta1Rad);

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(refX, refY);
        ctx.strokeStyle = isTIR ? '#DC2626' : 'rgba(220, 38, 38, 0.4)'; // å…¨åå°„æ—¶å…¨çº¢ï¼Œå¦åˆ™åŠé€æ˜
        ctx.lineWidth = isTIR ? 4 : 2;
        ctx.stroke();

        // ç®­å¤´ (Optional for reflection)
        // drawArrow(cx, cy, refX, refY, ctx.strokeStyle);
    }

    // --- 6. ç»˜åˆ¶æŠ˜å°„å…‰çº¿ (Refracted Ray) ---
    if (!isTIR) {
        // åæ ‡è®¡ç®—: x = cx + r * sin(t2), y = cy + r * cos(t2)
        const refrX = cx + rayLength * Math.sin(theta2Rad);
        const refrY = cy + rayLength * Math.cos(theta2Rad);

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(refrX, refrY);
        ctx.strokeStyle = '#2563EB'; // Blue-600
        ctx.lineWidth = 4;
        ctx.stroke();

        drawArrow(cx, cy, refrX, refrY, '#2563EB');
        
        // é€Ÿåº¦åˆ†é‡ç¤ºæ„ (Component Visualization)
        if(state.showComponent) {
            drawSpeedComponents(cx, cy, refrX, refrY, theta2Rad, state.n2, 'rgba(37, 99, 235, 0.3)');
            // å…¥å°„å…‰çš„é€Ÿåº¦åˆ†é‡
            drawSpeedComponents(incX, incY, cx, cy, theta1Rad, state.n1, 'rgba(220, 38, 38, 0.3)');
        }
    }

    // --- 7. æ ‡æ³¨è§’åº¦ ---
    if (state.showAngles) {
        // å…¥å°„è§’ arc
        drawAngleArc(cx, cy, -Math.PI/2 - theta1Rad, -Math.PI/2, 50, 'rgba(220, 38, 38, 0.2)');
        // æ–‡å­—
        ctx.fillStyle = '#991B1B';
        ctx.font = 'bold 14px monospace';
        ctx.fillText(`Î¸â‚=${state.angleInc.toFixed(1)}Â°`, cx - 60, cy - 60);

        if (!isTIR) {
            // æŠ˜å°„è§’ arc
            const deg2 = theta2Rad * 180 / Math.PI;
            drawAngleArc(cx, cy, Math.PI/2, Math.PI/2 - theta2Rad, 50, 'rgba(37, 99, 235, 0.2)');
            
            ctx.fillStyle = '#1E40AF';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(`Î¸â‚‚=${deg2.toFixed(1)}Â°`, cx + 20, cy + 60);
        }
    }

    // --- 8. æ›´æ–° DOM æ–‡æœ¬ ---
    txtA1.innerText = `${state.angleInc.toFixed(1)}Â°`;
    if (isTIR) {
        txtA2.innerText = "ä¸å­˜åœ¨";
        elWarn.classList.remove('hidden');
        elFormula.innerHTML = `${state.n1.toFixed(2)} Ã— sin(${state.angleInc.toFixed(1)}Â°) > ${state.n2.toFixed(2)} Ã— 1 <br> <span class='text-red-500'>æ•°å­¦è§£ä¸å­˜åœ¨ (sinÎ¸ > 1)</span>`;
    } else {
        const deg2 = theta2Rad * 180 / Math.PI;
        txtA2.innerText = `${deg2.toFixed(1)}Â°`;
        elWarn.classList.add('hidden');
        elFormula.innerHTML = `${state.n1.toFixed(2)} Ã— sin(${state.angleInc.toFixed(1)}Â°) = ${state.n2.toFixed(2)} Ã— sin(${deg2.toFixed(1)}Â°)`;
    }
}

// è¾…åŠ©ç»˜å›¾ï¼šç®­å¤´
function drawArrow(fromX, fromY, toX, toY, color) {
    const headlen = 10;
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(dy, dx);
    const midX = (fromX + toX) / 2;
    const midY = (fromY + toY) / 2;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    
    // åœ¨çº¿æ®µä¸­é—´ç”»ç®­å¤´
    ctx.beginPath();
    ctx.moveTo(midX, midY);
    ctx.lineTo(midX - headlen * Math.cos(angle - Math.PI / 6), midY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX - headlen * Math.cos(angle + Math.PI / 6), midY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.fill(); // å¡«å……å®å¿ƒç®­å¤´
    
    ctx.restore();
}

// è¾…åŠ©ç»˜å›¾ï¼šè§’åº¦å¼§çº¿
function drawAngleArc(x, y, startAngle, endAngle, r, color) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.arc(x, y, r, startAngle, endAngle, false); // false = clockwise? depends on angles.
    // ä¿®æ­£ï¼šarcæ€»æ˜¯å¡«å……æ‰‡å½¢ï¼Œä¸ºäº†å¥½çœ‹æˆ‘ä»¬åªç”»å¼§çº¿å’Œå¡«å……åŠé€æ˜
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    
    // è¾¹ç¼˜çº¿
    ctx.beginPath();
    ctx.arc(x, y, r, startAngle, endAngle, false);
    ctx.strokeStyle = color.replace('0.2', '0.6');
    ctx.stroke();
}

// è¾…åŠ©ç»˜å›¾ï¼šé€Ÿåº¦/æ³¢å‰ç¤ºæ„ (ç®€åŒ–çš„åŒå¿ƒåœ†/çº¿æ®µï¼Œè¡¨ç°å…‰ç–ä»‹è´¨æ³¢é•¿é•¿é€Ÿåº¦å¿«)
function drawSpeedComponents(x1, y1, x2, y2, angleRad, n, color) {
    // åªæ˜¯ç®€å•ç¤ºæ„ï¼Œnè¶Šå¤§ï¼Œé€Ÿåº¦è¶Šå°ï¼Œæ˜¾ç¤ºçš„æ³¢å‰è¶Šå¯†é›†
    // è¿™é‡Œä¸ºäº†ç®€æ´ï¼Œä¸å®ç°å¤æ‚çš„æ³¢å‰åŠ¨ç”»ï¼Œä»…ä¿ç•™æ¥å£æˆ–åšç®€å•è£…é¥°
}

// --- äº¤äº’å¤„ç† ---

function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX || evt.touches[0].clientX) - rect.left;
    const y = (evt.clientY || evt.touches[0].clientY) - rect.top;
    return { x, y };
}

function startDrag(e) {
    const pos = getMousePos(e);
    // åˆ¤æ–­æ˜¯å¦ç‚¹å‡»äº†å…¥å°„å…‰æºæ‰‹æŸ„é™„è¿‘
    // æ‰‹æŸ„ä½ç½®
    const w = canvas.width;
    const h = canvas.height;
    const cy = h * CENTER_Y_RATIO;
    const cx = w / 2;
    const rayLength = Math.min(w, h) * 0.45;
    const thetaRad = state.angleInc * Math.PI / 180;
    const handleX = cx - rayLength * Math.sin(thetaRad);
    const handleY = cy - rayLength * Math.cos(thetaRad);
    
    const dist = Math.sqrt((pos.x - handleX)**2 + (pos.y - handleY)**2);
    
    if (dist < 40) { // åˆ¤å®šåŠå¾„å®½æ¾ä¸€ç‚¹
        state.isDragging = true;
        e.preventDefault();
    }
}

function handleDrag(e) {
    if (!state.isDragging) return;
    e.preventDefault();
    
    const pos = getMousePos(e);
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h * CENTER_Y_RATIO;
    
    // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºä¸­å¿ƒçš„è§’åº¦
    // æˆ‘ä»¬åªå…³å¿ƒä¸ŠåŠå¹³é¢
    const dx = pos.x - cx;
    const dy = pos.y - cy;
    
    // Math.atan2(dy, dx) è¿”å›å€¼ (-PI åˆ° PI)
    // å‚ç›´å‘ä¸Šæ˜¯ -PI/2
    // æˆ‘ä»¬é™åˆ¶åªèƒ½åœ¨ä¸Šæ–¹æ‹–åŠ¨ (dy < 0)
    if (dy > 0) return; 

    // è®¡ç®—ä¸ -Y è½´ (æ³•çº¿) çš„å¤¹è§’
    // å‘é‡ V1(0, -1) æ³•çº¿, V2(dx, dy) é¼ æ ‡
    // ç®€å•ç‚¹ï¼šatan2(dy, dx)
    // å¦‚æœåœ¨å·¦è¾¹ dx < 0, angle is near -PI
    // å¦‚æœåœ¨å³è¾¹ dx > 0, angle is near 0
    // æˆ‘ä»¬å¸Œæœ›å…¥å°„å…‰ä¸»è¦åœ¨å·¦ä¸Šæˆ–å³ä¸Šï¼Œé€šå¸¸ä¹ æƒ¯ä»å·¦å°„å…¥
    
    let angleRad = Math.atan2(dy, dx); 
    // angleRad èŒƒå›´ -PI (å·¦) åˆ° 0 (å³)
    
    // è½¬æ¢ä¸ºä¸æ³•çº¿ (-PI/2) çš„å¤¹è§’
    let angleFromNormal = angleRad - (-Math.PI/2);
    
    // é™åˆ¶è§’åº¦èŒƒå›´ï¼Œé¿å…è¿‡äºè´´è¿‘ç•Œé¢ (-85 åˆ° 85 åº¦)
    let degrees = angleFromNormal * 180 / Math.PI;
    
    // ç”±äºå…¥å°„å…‰é€šå¸¸å®šä¹‰ä¸ºæ­£å€¼è§’åº¦(0-90)ï¼Œæˆ‘ä»¬å–ç»å¯¹å€¼ï¼Œ
    // ä½†ä¸ºäº†è®©ç”¨æˆ·å¯ä»¥æŠŠå…‰ç§»åˆ°å³è¾¹ï¼Œä¿ç•™ç¬¦å·é€»è¾‘ã€‚
    // è¿™é‡Œæˆ‘ä»¬å¼ºåˆ¶å…‰çº¿ä»"ä¸Šæ–¹"å°„å…¥ã€‚
    // ä¹ æƒ¯ä¸Šå¯ä»¥å·¦å³æ‘†åŠ¨ã€‚
    
    // ä¿®æ­£ï¼šæˆ‘ä»¬å‡å®šå…‰çº¿æ€»æ˜¯ä»"é¼ æ ‡ä½ç½®"å°„å‘"ä¸­å¿ƒ"ã€‚
    // ç•Œé¢æ˜¾ç¤ºçš„ Î¸1 æ˜¯ä¸æ³•çº¿çš„å¤¹è§’ï¼ˆç»å¯¹å€¼ï¼‰ã€‚
    // ä½†ç»˜å›¾éœ€è¦çŸ¥é“æ˜¯åœ¨å·¦ä¾§è¿˜æ˜¯å³ä¾§ã€‚
    // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªå…è®¸åœ¨å·¦ä¾§åŠåœ†æ‹–åŠ¨ï¼Œæˆ–è€…å…è®¸å·¦å³ã€‚
    // ä¸ºäº†æœ€é€šç”¨çš„æ¼”ç¤ºï¼Œå…è®¸å·¦å³ï¼Œä½† Î¸1 æ˜¾ç¤ºä¸ºæ­£å€¼ã€‚
    
    // è¿™é‡Œçš„ state.angleInc å­˜å‚¨ç»å¯¹å€¼å—ï¼Ÿ
    // è®©æˆ‘ä»¬åšä¸ªé™åˆ¶ï¼šåªèƒ½åœ¨å·¦ä¾§æ‹–åŠ¨ (0 ~ 90åº¦)ï¼Œç¬¦åˆæ•™ç§‘ä¹¦ç»å…¸å›¾ç¤º
    if (degrees > 88) degrees = 88;
    if (degrees < -88) degrees = -88;
    
    // å¦‚æœåªå…è®¸å·¦ä¾§å°„å…¥ (ç¬¬äºŒè±¡é™)
    if (degrees > 0) degrees = 0; // å¼ºè¡Œé™åˆ¶åœ¨å·¦ä¾§
    
    // æ­¤æ—¶ degrees æ˜¯è´Ÿæ•° (ä¾‹å¦‚ -45)
    state.angleInc = Math.abs(degrees);
    
    draw();
}

function stopDrag() {
    state.isDragging = false;
}

// å¯åŠ¨
init();

</script>
</body>
</html>