<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°†å†›é¥®é©¬é—®é¢˜å¯è§†åŒ– (Shortest Path Problem)</title>
    <!-- Load p5.js (Visualization Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <!-- Load MathJax (Formula Rendering) -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Modern CSS Reset & Layout */
        :root {
            --primary-color: #2563eb;
            --secondary-color: #475569;
            --success-color: #16a34a;
            --danger-color: #dc2626;
            --bg-color: #f8fafc;
            --panel-width: 380px; /* Slightly wider for text */
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Noto Sans CJK SC", sans-serif;
            background-color: var(--bg-color);
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }

        /* Header */
        header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            z-index: 20;
        }

        h1 {
            font-size: 1.25rem;
            margin: 0;
            color: #1e293b;
            font-weight: 600;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Control Panel (Left) */
        .control-panel {
            width: var(--panel-width);
            background: white;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* Problem Description */
        .problem-box {
            background: #eff6ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary-color);
        }

        .problem-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .problem-text {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #475569;
        }

        /* Step-by-Step Guide Section (New) */
        .guide-section {
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .guide-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #b45309;
            font-weight: bold;
            font-size: 0.95rem;
        }

        .guide-content {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #78350f;
            margin-bottom: 15px;
            min-height: 80px; /* Slightly taller for explanations */
        }

        .guide-controls {
            display: flex;
            gap: 10px;
        }

        .guide-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #d97706;
            background: #fff;
            color: #d97706;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .guide-btn:hover:not(:disabled) {
            background: #fff7ed;
        }

        .guide-btn.primary {
            background: #d97706;
            color: white;
        }
        
        .guide-btn.primary:hover:not(:disabled) {
            background: #b45309;
        }

        .guide-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #cbd5e1;
            color: #94a3b8;
            background: #f1f5f9;
        }

        /* Settings Group */
        .controls-group {
            margin-bottom: 25px;
            padding-top: 10px;
            border-top: 1px solid #f1f5f9;
        }

        .group-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            margin-bottom: 12px;
            font-weight: 700;
        }

        .control-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            background: #f8fafc;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .control-label {
            font-size: 0.9rem;
            color: #334155;
            flex: 1;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        /* Result Display */
        .result-box {
            margin-top: auto;
            padding: 15px;
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .result-box.highlight {
            background: #fee2e2;
            border-color: #fca5a5;
            transform: scale(1.02);
            box-shadow: 0 4px 6px -1px rgba(220, 38, 38, 0.1);
        }

        .math-display {
            font-size: 1.1rem;
            margin: 5px 0;
        }

        /* Status Bar */
        .status-bar {
            background: #1e293b;
            color: #f8fafc;
            padding: 8px 20px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #canvas-container {
            flex: 1;
            background: #fff;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        /* Interactive Hints on Canvas */
        .canvas-hint {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #cbd5e1;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #475569;
            pointer-events: none;
            display: none; /* Controlled by JS */
        }
    </style>
</head>
<body>

    <header>
        <h1>å°†å†›é¥®é©¬é—®é¢˜å¯è§†åŒ– (Shortest Path Problem)</h1>
    </header>

    <div class="main-container">
        <!-- Control Panel -->
        <aside class="control-panel">
            <!-- Problem Statement -->
            <div class="problem-box">
                <div class="problem-title">é¢˜ç›®å¤§æ„</div>
                <div class="problem-text">
                    å·²çŸ¥ç‚¹ \(A(2,2)\) å’Œ \(B(4,5)\)ï¼Œåœ¨ \(y\) è½´ä¸Šæ‰¾ä¸€ç‚¹ \(P(0,y)\)ï¼Œä½¿å¾— \(PA + PB\) çš„å€¼æœ€å°ã€‚
                </div>
            </div>

            <!-- Step-by-Step Guide -->
            <div class="guide-section">
                <div class="guide-header">
                    <span>ğŸ’¡ åˆ†æ­¥æ•™å­¦å‘å¯¼</span>
                    <span id="step-indicator">1 / 4</span>
                </div>
                <div class="guide-content" id="guide-text">
                    <!-- Dynamic Text Here -->
                    è¯•ç€æ‹–åŠ¨ y è½´ä¸Šçš„ç‚¹ Pï¼Œè§‚å¯Ÿ \(PA+PB\) çš„é•¿åº¦å˜åŒ–ã€‚ä½ è§‰å¾— P åœ¨ä»€ä¹ˆä½ç½®æ—¶è·¯å¾„æœ€çŸ­ï¼Ÿ
                </div>
                <div class="guide-controls">
                    <button class="guide-btn" id="btn-prev" disabled>ä¸Šä¸€æ­¥</button>
                    <button class="guide-btn primary" id="btn-next">ä¸‹ä¸€æ­¥</button>
                </div>
            </div>

            <!-- Manual Controls (Visual Settings) -->
            <div class="controls-group">
                <div class="group-title">è§†å›¾è®¾ç½® (å¯æ‰‹åŠ¨å¹²é¢„)</div>
                
                <div class="control-item">
                    <span class="control-label">æ˜¾ç¤ºå¯¹ç§°ç‚¹ \(A'(-2,2)\)</span>
                    <input type="checkbox" id="toggle-reflection">
                </div>

                <div class="control-item">
                    <span class="control-label">æ˜¾ç¤ºè¾…åŠ©çº¿ \(A'B\)</span>
                    <input type="checkbox" id="toggle-line">
                </div>

                <div class="control-item">
                    <span class="control-label">æ˜¾ç¤ºç½‘æ ¼</span>
                    <input type="checkbox" id="toggle-grid" checked>
                </div>
                
                <button class="guide-btn" style="width:100%; border-color:#cbd5e1; color:#475569;" id="btn-reset">é‡ç½®æ‰€æœ‰çŠ¶æ€</button>
            </div>

            <!-- Result Display -->
            <div class="result-box" id="result-box">
                <div style="font-size:0.9rem; color:#64748b; margin-bottom:4px;">å½“å‰æ€»é•¿åº¦</div>
                <div class="math-display" id="length-display">
                    <span style="font-family: 'Times New Roman', serif; font-style: italic;">L</span> = PA + PB = <strong>?</strong>
                </div>
                <div id="conclusion-text" style="font-size:0.85rem; color:#dc2626; margin-top:5px; opacity:0; font-weight:bold;">
                    å·²è¾¾åˆ°æœ€å°å€¼ï¼(ä¸‰ç‚¹å…±çº¿)
                </div>
            </div>
        </aside>

        <!-- Visualization Canvas -->
        <div id="canvas-container">
            <div id="tooltip" class="canvas-hint"></div>
        </div>
    </div>

    <!-- Status Bar -->
    <footer class="status-bar">
        <span id="status-left">çŠ¶æ€: è‡ªç”±æ¢ç´¢æ¨¡å¼</span>
        <span id="status-right">æç¤º: æ‹–åŠ¨ P ç‚¹æ”¹å˜ä½ç½®</span>
    </footer>

    <script>
        // --- 1. CONFIG & STATE ---
        const CONFIG = {
            unitScale: 50,         // pixels per unit
            pointRadius: 8,
            dragThreshold: 20,
            axisColor: '#64748b',
            gridColor: '#e2e8f0',
            textColor: '#334155',
            mainLineColor: '#2563eb', // Blue
            auxLineColor: '#94a3b8',  // Gray dashed
            highlightColor: '#dc2626', // Red for min
            targetY: 3.0,          // The math answer for min
            epsilon: 0.08,         // Snap threshold
            animSpeed: 0.15        // Animation speed
        };

        const PROBLEM = {
            A: { x: 2, y: 2 },
            B: { x: 4, y: 5 },
            A_prime: { x: -2, y: 2 } // Reflection of A
        };

        // Teaching Steps Data
        // NOTE: In JS strings, we must use double backslash \\ for LaTeX commands and delimiters.
        // e.g. \\( ... \\) for inline math.
        const STEPS = [
            {
                id: 1,
                text: "ã€ç¬¬ä¸€æ­¥ï¼šè‡ªç”±æ¢ç´¢ã€‘<br>è¯·è¯•ç€ä¸Šä¸‹æ‹–åŠ¨ y è½´ä¸Šçš„ç‚¹ <b>P</b>ã€‚<br>è§‚å¯Ÿä¸‹æ–¹æ•°å€¼çš„å˜åŒ–ï¼Œå‡­ç›´è§‰çŒœçŒœçœ‹ï¼šP å¤§æ¦‚åœ¨ä»€ä¹ˆä½ç½®æ—¶ï¼Œ\\(PA+PB\\) æœ€å°ï¼Ÿ",
                showReflection: false,
                showLine: false,
                forceOptimal: false
            },
            {
                id: 2,
                text: "ã€ç¬¬äºŒæ­¥ï¼šè½¬åŒ–é—®é¢˜ã€‘<br>æˆ‘ä»¬ä½œç‚¹ A å…³äº y è½´çš„å¯¹ç§°ç‚¹ \\(A'\\)ã€‚<br>æ ¹æ®å‚ç›´å¹³åˆ†çº¿æ€§è´¨ï¼Œ<b>\\(PA = PA'\\)</b>ã€‚<br>æ—¢ç„¶é•¿åº¦ç›¸ç­‰ï¼Œé‚£æ±‚ \\(PA+PB\\) çš„æœ€å°å€¼ï¼Œå…¶å®å°±æ˜¯æ±‚ <b>\\(PA'+PB\\)</b> çš„æœ€å°å€¼ã€‚",
                showReflection: true,
                showLine: false,
                forceOptimal: false
            },
            {
                id: 3,
                text: "ã€ç¬¬ä¸‰æ­¥ï¼šåŒ–æŠ˜ä¸ºç›´ã€‘<br>ç°åœ¨ä½ çœ‹ï¼šè¦ä» \\(A'\\) èµ°åˆ° \\(B\\)ï¼Œæœ‰ä¸¤æ¡è·¯ï¼š<br>1. èµ°æŠ˜çº¿ \\(A' \\to P \\to B\\)<br>2. èµ°ç›´çº¿ \\(A' \\to B\\)<br>æ˜¾ç„¶ï¼š<b>ä¸¤ç‚¹ä¹‹é—´ï¼Œçº¿æ®µæœ€çŸ­ã€‚</b>æŠ˜çº¿æ€»æ˜¯æ¯”ç›´çº¿é•¿ï¼ˆä¸‰è§’å½¢ä¸¤è¾¹ä¹‹å’Œå¤§äºç¬¬ä¸‰è¾¹ï¼‰ã€‚",
                showReflection: true,
                showLine: true,
                forceOptimal: false
            },
            {
                id: 4,
                text: "ã€ç¬¬å››æ­¥ï¼šå¾—å‡ºç»“è®ºã€‘<br>å½“ \\(A', P, B\\) ä¸‰ç‚¹å…±çº¿æ—¶ï¼Œè·¯ç¨‹æœ€çŸ­ã€‚<br>è¿æ¥ \\(A'B\\) ä¸ y è½´çš„äº¤ç‚¹å³ä¸ºæ‰€æ±‚ã€‚<br>æ­¤æ—¶æœ€å°å€¼ \\( L_{min} = A'B \\)ã€‚<br>ç‚¹å‡»â€œé‡ç½®â€å¯é‡æ–°ä½“éªŒã€‚",
                showReflection: true,
                showLine: true,
                forceOptimal: true // Trigger animation to optimal
            }
        ];

        let state = {
            Py: 0.0,
            isDragging: false,
            showReflection: false,
            showLine: false,
            showGrid: true,
            isAnimating: false,
            isOptimal: false,
            currentStepIndex: 0 // 0 to 3
        };

        // DOM Elements
        let lengthDisplay, conclusionText, resultBox, statusBarLeft;
        let guideText, stepIndicator, btnPrev, btnNext;

        // --- 2. SETUP ---
        function setup() {
            let container = document.getElementById('canvas-container');
            let canvas = createCanvas(container.clientWidth, container.clientHeight);
            canvas.parent('canvas-container');
            
            state.Py = 1.0; // Initial position slightly off

            // DOM refs
            lengthDisplay = document.getElementById('length-display');
            conclusionText = document.getElementById('conclusion-text');
            resultBox = document.getElementById('result-box');
            statusBarLeft = document.getElementById('status-left');
            
            guideText = document.getElementById('guide-text');
            stepIndicator = document.getElementById('step-indicator');
            btnPrev = document.getElementById('btn-prev');
            btnNext = document.getElementById('btn-next');

            // Listeners
            document.getElementById('toggle-reflection').addEventListener('change', (e) => state.showReflection = e.target.checked);
            document.getElementById('toggle-line').addEventListener('change', (e) => state.showLine = e.target.checked);
            document.getElementById('toggle-grid').addEventListener('change', (e) => state.showGrid = e.target.checked);
            document.getElementById('btn-reset').addEventListener('click', resetSim);

            // Step Buttons
            btnPrev.addEventListener('click', () => changeStep(-1));
            btnNext.addEventListener('click', () => changeStep(1));

            textFont('sans-serif');
            updateFormula();
            updateStepUI(); // Initialize Guide
        }

        function windowResized() {
            let container = document.getElementById('canvas-container');
            resizeCanvas(container.clientWidth, container.clientHeight);
        }

        // --- 3. DRAW LOOP ---
        function draw() {
            background(255);
            translate(width / 2, height * 0.7);
            scale(1, -1);

            if (state.showGrid) drawGrid();
            drawAxes();

            // Animation Logic (for Step 4 or Snap)
            if (state.isAnimating) {
                let diff = CONFIG.targetY - state.Py;
                if (Math.abs(diff) < 0.01) {
                    state.Py = CONFIG.targetY;
                    state.isAnimating = false;
                } else {
                    state.Py += diff * CONFIG.animSpeed;
                    updateFormula();
                }
            }

            // Coordinates
            let ax = PROBLEM.A.x * CONFIG.unitScale;
            let ay = PROBLEM.A.y * CONFIG.unitScale;
            let bx = PROBLEM.B.x * CONFIG.unitScale;
            let by = PROBLEM.B.y * CONFIG.unitScale;
            let apx = PROBLEM.A_prime.x * CONFIG.unitScale;
            let apy = PROBLEM.A_prime.y * CONFIG.unitScale;
            let px = 0;
            let py = state.Py * CONFIG.unitScale;

            state.isOptimal = Math.abs(state.Py - CONFIG.targetY) < CONFIG.epsilon;

            // --- DRAWING LAYERS ---

            // 1. Auxiliary: Reflection Point A' & Dashed Line AA'
            if (state.showReflection) {
                // Dashed AA'
                stroke(150); strokeWeight(1);
                drawingContext.setLineDash([5, 5]);
                line(ax, ay, apx, apy);
                
                // Point A'
                fill(100); noStroke();
                ellipse(apx, apy, CONFIG.pointRadius, CONFIG.pointRadius);
                drawLabel("A'", apx - 25, apy);
                
                // Connection PA' (Critical for Step 2)
                stroke(state.isOptimal ? CONFIG.highlightColor : CONFIG.auxLineColor);
                strokeWeight(state.isOptimal ? 3 : 1.5);
                drawingContext.setLineDash([5, 5]);
                line(apx, apy, px, py);
                
                // Add tick marks to show equality PA = PA'
                // (Visual polish only if not optimal to avoid clutter)
                if (!state.isOptimal) {
                   // drawTickMark((ax+px)/2, (ay+py)/2); // Simplified: skip for clarity
                }
            }

            // 2. Auxiliary: Straight Line A'B (Target Path)
            if (state.showLine) {
                stroke(CONFIG.auxLineColor);
                strokeWeight(2);
                drawingContext.setLineDash([8, 6]);
                line(apx, apy, bx, by);
            }
            drawingContext.setLineDash([]); // Reset dash

            // 3. Main Path: PA + PB
            let mainColor = state.isOptimal ? CONFIG.highlightColor : CONFIG.mainLineColor;
            stroke(mainColor);
            strokeWeight(state.isOptimal ? 4 : 3);
            line(px, py, ax, ay);
            line(px, py, bx, by);

            // 4. Points
            noStroke();
            
            // A & B
            fill(0);
            ellipse(ax, ay, CONFIG.pointRadius, CONFIG.pointRadius);
            drawLabel("A", ax + 10, ay);
            ellipse(bx, by, CONFIG.pointRadius, CONFIG.pointRadius);
            drawLabel("B", bx + 10, by);

            // P (Interactive)
            let mouseLogical = getMouseLogical();
            let dP = dist(mouseLogical.x * CONFIG.unitScale, mouseLogical.y * CONFIG.unitScale, px, py);
            let isHover = dP < CONFIG.dragThreshold && !state.isAnimating;

            // Cursor & Color logic
            if (state.isDragging || isHover) {
                cursor(MOVE);
                fill(state.isOptimal ? '#ef4444' : '#3b82f6');
                drawingContext.shadowBlur = 10;
                drawingContext.shadowColor = "rgba(0,0,0,0.2)";
            } else {
                cursor(ARROW);
                fill(state.isOptimal ? CONFIG.highlightColor : '#2563eb');
                drawingContext.shadowBlur = 0;
            }

            // P Glow if optimal
            if (state.isOptimal) {
                drawingContext.shadowBlur = 20;
                drawingContext.shadowColor = CONFIG.highlightColor;
            }

            ellipse(px, py, 14, 14);
            drawingContext.shadowBlur = 0;
            drawLabel("P", px - 25, py);

            // UI Feedback
            updateUIFeedback();
        }

        // --- 4. STEP LOGIC ---

        function changeStep(dir) {
            let newIndex = state.currentStepIndex + dir;
            if (newIndex >= 0 && newIndex < STEPS.length) {
                state.currentStepIndex = newIndex;
                updateStepUI();
            }
        }

        function updateStepUI() {
            let step = STEPS[state.currentStepIndex];
            
            // Update Text
            stepIndicator.textContent = `${state.currentStepIndex + 1} / ${STEPS.length}`;
            guideText.innerHTML = step.text; // Allow HTML tags like <br>
            
            // Update Buttons
            btnPrev.disabled = (state.currentStepIndex === 0);
            btnNext.textContent = (state.currentStepIndex === STEPS.length - 1) ? "å®Œæˆ" : "ä¸‹ä¸€æ­¥";
            if (state.currentStepIndex === STEPS.length - 1) {
                btnNext.disabled = true;
            } else {
                btnNext.disabled = false;
            }

            // Sync Visual State
            state.showReflection = step.showReflection;
            state.showLine = step.showLine;
            
            // Sync Checkboxes
            document.getElementById('toggle-reflection').checked = step.showReflection;
            document.getElementById('toggle-line').checked = step.showLine;

            // Trigger Animation if needed
            if (step.forceOptimal) {
                state.isAnimating = true;
                statusBarLeft.textContent = "çŠ¶æ€: è‡ªåŠ¨æ¼”ç¤ºæœ€ä¼˜ä½ç½®";
            } else {
                statusBarLeft.textContent = `çŠ¶æ€: æ•™å­¦æ­¥éª¤ ${state.currentStepIndex + 1}`;
            }

            // Re-render math
            MathJax.typesetPromise([guideText]);
        }

        // --- 5. INTERACTION & HELPERS ---

        function drawGrid() {
            stroke(CONFIG.gridColor); strokeWeight(1);
            let stepsX = floor(width / (2 * CONFIG.unitScale)) + 1;
            let stepsY = floor(height / CONFIG.unitScale) + 1;
            for (let i = -stepsX; i <= stepsX; i++) line(i * CONFIG.unitScale, -height, i * CONFIG.unitScale, height);
            for (let i = -stepsY; i <= stepsY; i++) line(-width, i * CONFIG.unitScale, width, i * CONFIG.unitScale);
        }

        function drawAxes() {
            stroke(CONFIG.axisColor); strokeWeight(2);
            line(-width/2, 0, width/2, 0);
            line(0, -height*0.7, 0, height*0.3);
            fill(CONFIG.axisColor); noStroke();
            triangle(0, height*0.3, -4, height*0.3 - 10, 4, height*0.3 - 10);
            triangle(width/2, 0, width/2 - 10, 4, width/2 - 10, -4);
            push(); scale(1, -1); textSize(14);
            text("x", width/2 - 20, 20); text("y", 10, -height*0.3 + 20); text("O", -15, 20);
            pop();
        }

        function drawLabel(str, x, y) {
            push(); scale(1, -1); fill(CONFIG.textColor); noStroke(); textSize(14);
            text(str, x, -y - 8); pop();
        }

        function getMouseLogical() {
            let mx = (mouseX - width / 2) / CONFIG.unitScale;
            let my = -(mouseY - height * 0.7) / CONFIG.unitScale;
            return { x: mx, y: my };
        }

        function mousePressed() {
            if (state.isAnimating) return;
            let m = getMouseLogical();
            let threshold = CONFIG.dragThreshold / CONFIG.unitScale;
            if (Math.abs(m.x) < threshold && Math.abs(m.y - state.Py) < threshold) {
                state.isDragging = true;
                statusBarLeft.textContent = "çŠ¶æ€: æ­£åœ¨æ‹–åŠ¨ P";
            }
        }

        function mouseDragged() {
            if (state.isDragging) {
                let m = getMouseLogical();
                state.Py = Math.max(-2, Math.min(8, m.y));
                
                // Magnetic snap to optimal
                if (Math.abs(state.Py - CONFIG.targetY) < 0.1) {
                    state.Py = CONFIG.targetY;
                }
                updateFormula();
            }
        }

        function mouseReleased() {
            state.isDragging = false;
            statusBarLeft.textContent = "çŠ¶æ€: å°±ç»ª";
        }

        function updateFormula() {
            // Calculate lengths
            let y = state.Py;
            // Distances
            let dA = Math.sqrt(Math.pow(PROBLEM.A.x, 2) + Math.pow(PROBLEM.A.y - y, 2));
            let dB = Math.sqrt(Math.pow(PROBLEM.B.x, 2) + Math.pow(PROBLEM.B.y - y, 2));
            let total = dA + dB;

            let lenVal = total.toFixed(3);
            lengthDisplay.innerHTML = `<span style="font-family: 'Times New Roman', serif; font-style: italic;">L</span> = PA + PB = <strong>${lenVal}</strong>`;
        }

        function updateUIFeedback() {
            if (state.isOptimal) {
                if (!resultBox.classList.contains('highlight')) {
                    resultBox.classList.add('highlight');
                    conclusionText.style.opacity = 1;
                }
            } else {
                resultBox.classList.remove('highlight');
                conclusionText.style.opacity = 0;
            }
        }

        function resetSim() {
            state.currentStepIndex = 0;
            state.Py = 1.0;
            state.isAnimating = false;
            updateStepUI();
            updateFormula();
            statusBarLeft.textContent = "çŠ¶æ€: å·²é‡ç½®";
        }

    </script>
</body>
</html>