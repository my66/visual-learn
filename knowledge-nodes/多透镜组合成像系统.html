<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜æ¸…ç‰©ç†å®éªŒå®¤ï¼šå¤šé€é•œç»„åˆæˆåƒç³»ç»Ÿ (v4.7 çœŸå®å­”å¾„ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        /* --- åŸºç¡€å¸ƒå±€ --- */
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #f8fafc;
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            color: #334155;
            user-select: none;
        }

        #app-container {
            display: flex;
            width: 100vw; height: 100vh;
        }

        /* --- ä¾§è¾¹æ  --- */
        #sidebar {
            width: 400px;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            padding: 0;
            display: flex;
            flex-direction: column;
            z-index: 20;
            box-shadow: 4px 0 16px rgba(0,0,0,0.05);
        }

        .sidebar-header {
            padding: 20px 20px 15px 20px;
            border-bottom: 1px solid #f1f5f9;
            background: #fff;
        }
        .sidebar-header h1 {
            margin: 0; font-size: 18px; color: #0f172a;
            display: flex; justify-content: space-between; align-items: center;
        }
        .badge {
            font-size: 10px; background: #3b82f6; color: white;
            padding: 2px 6px; border-radius: 4px; font-weight: bold;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex; flex-direction: column; gap: 20px;
        }

        /* --- æ§ä»¶æ ·å¼ --- */
        .control-section {
            display: flex; flex-direction: column; gap: 10px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f1f5f9;
        }
        .control-section:last-child { border-bottom: none; }

        h2 {
            font-size: 12px; font-weight: 700; color: #64748b;
            text-transform: uppercase; letter-spacing: 0.5px; margin: 0;
        }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: flex; gap: 8px; }
        .btn {
            flex: 1; padding: 8px;
            border: 1px solid #cbd5e1; background: #f8fafc;
            border-radius: 6px; cursor: pointer;
            font-size: 13px; color: #475569;
            transition: all 0.2s;
            text-align: center;
        }
        .btn:hover { background: #e2e8f0; }
        .btn.active {
            background: #3b82f6; color: white; border-color: #3b82f6; font-weight: 600;
        }
        
        .btn-primary {
            background: #3b82f6; color: white; border-color: #2563eb;
        }
        .btn-primary:hover { background: #2563eb; }

        .btn-add {
            background: #ecfdf5; color: #059669; border-color: #a7f3d0;
            display: flex; align-items: center; justify-content: center; gap: 5px;
            font-weight: 600;
        }
        .btn-add:hover { background: #d1fae5; }
        
        .btn-danger {
            background: #fff1f2; color: #e11d48; border-color: #fecdd3;
            padding: 4px 8px; font-size: 11px; width: auto; flex: none;
        }
        .btn-danger:hover { background: #ffe4e6; }

        /* åœºæ™¯æŒ‰é’®ç½‘æ ¼ */
        .scenario-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
        }
        .scenario-btn {
            background: #fff; border: 1px solid #e2e8f0;
            border-radius: 6px; padding: 8px 10px;
            text-align: left; cursor: pointer;
            transition: all 0.2s; display: flex; flex-direction: column;
        }
        .scenario-btn:hover { border-color: #3b82f6; background: #eff6ff; }
        .scenario-btn .stitle { font-weight: bold; font-size: 12px; color: #334155; margin-bottom: 2px; }
        .scenario-btn .sdesc { font-size: 10px; color: #64748b; }

        /* æ–°å¢é€é•œé¢æ¿ */
        #add-lens-panel {
            background: #fff7ed; border: 1px solid #fed7aa;
            border-radius: 8px; padding: 15px;
            display: none; /* é»˜è®¤éšè— */
            flex-direction: column; gap: 10px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* é€é•œåˆ—è¡¨å¡ç‰‡ */
        .lens-list { display: flex; flex-direction: column; gap: 10px; margin-top: 5px; }
        .lens-card {
            background: #f8fafc; border: 1px solid #e2e8f0;
            border-left: 3px solid #94a3b8;
            border-radius: 6px; padding: 10px;
            transition: border-color 0.2s;
        }
        .lens-card.is-main { border-left-color: #3b82f6; background: #eff6ff; }
        .lens-card:hover { border-color: #cbd5e1; }
        
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px; font-size: 12px; font-weight: bold; color: #334155;
        }
        
        /* æ»‘å— */
        input[type="range"] {
            width: 100%; height: 4px; background: #cbd5e1;
            border-radius: 2px; outline: none; appearance: none; margin: 10px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 14px; height: 14px;
            background: #3b82f6; border: 2px solid white; border-radius: 50%;
            cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        /* æ•°æ®é¢æ¿ */
        .data-panel {
            background: #1e293b; color: #e2e8f0;
            border-radius: 8px; padding: 15px;
            font-family: 'Consolas', monospace; font-size: 12px;
            margin-top: auto;
        }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .data-val { color: #38bdf8; font-weight: bold; }

        /* å¤é€‰æ¡† */
        .checkbox-group { display: flex; flex-wrap: wrap; gap: 10px; }
        .checkbox-label {
            display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;
        }
        input[type="checkbox"] { accent-color: #3b82f6; }

        /* ç”»å¸ƒ */
        #canvas-container {
            flex: 1; position: relative;
            background-color: #fff;
            overflow: hidden;
        }

        #toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(15,23,42,0.9); color: white;
            padding: 8px 16px; border-radius: 20px; font-size: 13px;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 100; text-align: center; white-space: pre-line;
        }
    </style>
</head>
<body>

<div id="app-container">
    <div id="sidebar">
        <div class="sidebar-header">
            <h1>å…‰å­¦å®éªŒå®¤ <span class="badge">v4.7 Aperture</span></h1>
        </div>

        <div class="sidebar-content">
            <!-- 1. ä¸»é€é•œæ§åˆ¶ -->
            <div class="control-section">
                <h2>ä¸»é€é•œè®¾ç½® (Main Lens)</h2>
                <div class="btn-group">
                    <button class="btn active" id="btn-main-convex" onclick="setMainLensType('convex')">å‡¸é€é•œ</button>
                    <button class="btn" id="btn-main-concave" onclick="setMainLensType('concave')">å‡¹é€é•œ</button>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#64748b; margin-top:8px;">
                    <span>ç„¦è· / åšåº¦</span>
                    <span id="main-f-val">f=160</span>
                </div>
                <input type="range" id="slider-main-f" min="50" max="400" step="5" value="160">
            </div>

            <!-- 2. ç»å…¸åœºæ™¯ -->
            <div class="control-section">
                <h2>ä¸€é”®æ¼”ç¤º (ç»å…¸è€ƒç‚¹)</h2>
                <div class="scenario-grid">
                    <button class="scenario-btn" onclick="setScenario(1)">
                        <span class="stitle">u > 2f</span>
                        <span class="sdesc">ç…§ç›¸æœº (ç¼©å°å®åƒ)</span>
                    </button>
                    <button class="scenario-btn" onclick="setScenario(2)">
                        <span class="stitle">u = 2f</span>
                        <span class="sdesc">æµ‹ç„¦è· (ç­‰å¤§å®åƒ)</span>
                    </button>
                    <button class="scenario-btn" onclick="setScenario(3)">
                        <span class="stitle">f < u < 2f</span>
                        <span class="sdesc">æŠ•å½±ä»ª (æ”¾å¤§å®åƒ)</span>
                    </button>
                    <button class="scenario-btn" onclick="setScenario(4)">
                        <span class="stitle">u = f</span>
                        <span class="sdesc">æ¢ç…§ç¯ (ä¸æˆåƒ)</span>
                    </button>
                    <button class="scenario-btn" onclick="setScenario(5)">
                        <span class="stitle">u < f</span>
                        <span class="sdesc">æ”¾å¤§é•œ (æ”¾å¤§è™šåƒ)</span>
                    </button>
                    <button class="scenario-btn" onclick="setScenario(6)">
                        <span class="stitle">å‡¹é€é•œ</span>
                        <span class="sdesc">è¿‘è§†é•œ (ç¼©å°è™šåƒ)</span>
                    </button>
                </div>
            </div>

            <!-- 3. é€é•œç®¡ç† -->
            <div class="control-section">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h2>å…‰å­¦å…ƒä»¶åˆ—è¡¨</h2>
                    <button id="btn-start-add" class="btn btn-add" onclick="startAddLens()" style="width:auto; padding:5px 10px;">
                        <span>+</span> å‡†å¤‡æ·»åŠ é€é•œ
                    </button>
                </div>

                <!-- é¢„è§ˆ/æ·»åŠ é¢æ¿ -->
                <div id="add-lens-panel">
                    <div style="font-weight:bold; color:#c2410c; font-size:13px; margin-bottom:5px;">é…ç½®æ–°é€é•œ (é¢„è§ˆæ¨¡å¼)</div>
                    <div style="font-size:11px; color:#9a3412; margin-bottom:10px;">
                        æ‹–åŠ¨è™šçº¿é€é•œåˆ°ç›®æ ‡ä½ç½®ï¼Œè°ƒæ•´ç„¦è·ã€‚
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn active" id="btn-prev-convex" onclick="updatePreviewLens('type', 'convex')">å‡¸é€é•œ</button>
                        <button class="btn" id="btn-prev-concave" onclick="updatePreviewLens('type', 'concave')">å‡¹é€é•œ</button>
                    </div>
                    
                    <div style="display:flex; justify-content:space-between; font-size:11px; color:#64748b; margin-top:10px;">
                        <span>ç„¦è· f</span>
                        <span id="preview-f-val">150</span>
                    </div>
                    <input type="range" min="50" max="400" value="150" oninput="updatePreviewLens('f', this.value)">

                    <div class="btn-group" style="margin-top:10px;">
                        <button class="btn" onclick="cancelAddLens()">å–æ¶ˆ</button>
                        <button class="btn btn-primary" onclick="confirmAddLens()">ç¡®è®¤åŠ å…¥</button>
                    </div>
                </div>
                
                <div id="lens-list-container" class="lens-list">
                    <!-- åˆ—è¡¨ -->
                </div>
            </div>

            <!-- 4. ç‰©ä½“æ§åˆ¶ -->
            <div class="control-section">
                <h2>å…‰æºç‰©ä½“ (Object)</h2>
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#64748b; margin-top:5px;">
                    <span>é«˜åº¦ (Height)</span>
                    <span id="obj-h-val">120</span>
                </div>
                <input type="range" id="slider-obj-h" min="-150" max="150" step="10" value="120">
            </div>

            <!-- 5. æ˜¾ç¤ºè®¾ç½® -->
            <div class="control-section">
                <h2>æ˜¾ç¤ºé€‰é¡¹</h2>
                <div class="checkbox-group">
                    <label class="checkbox-label"><input type="checkbox" id="chk-rays" checked> æ˜¾ç¤ºå…‰æŸ</label>
                    <label class="checkbox-label"><input type="checkbox" id="chk-grid" checked> ç½‘æ ¼/æ ‡å°º</label>
                    <label class="checkbox-label"><input type="checkbox" id="chk-values" checked> æ•°å€¼æ ‡æ³¨ (F/2F)</label>
                    <label class="checkbox-label"><input type="checkbox" id="chk-eye" checked> è§‚å¯Ÿè€…äººçœ¼</label>
                    <label class="checkbox-label" style="color:#059669; font-weight:bold;">
                        <input type="checkbox" id="chk-focal-planes"> æ˜¾ç¤ºç„¦å¹³é¢
                    </label>
                    <label class="checkbox-label" style="color:#7c3aed; font-weight:bold;">
                        <input type="checkbox" id="chk-thick"> çœŸå®å…‰å¿ƒä¾§ç§»(ç¤ºæ„)
                    </label>
                    <label class="checkbox-label" style="color:#e11d48; font-weight:bold;">
                        <input type="checkbox" id="chk-block"> é®æŒ¡å®éªŒ(ä¸»é€é•œ)
                    </label>
                    <label class="checkbox-label" style="color:#64748b;">
                        <input type="checkbox" id="chk-ghost" checked> æ˜¾ç¤ºæ·»åŠ å‰åŸåƒ
                    </label>
                    <!-- æ–°å¢åŠŸèƒ½å¼€å…³ -->
                    <label class="checkbox-label" style="color:#2563eb; font-weight:bold;">
                        <input type="checkbox" id="chk-aperture"> çœŸå®å­”å¾„é™åˆ¶ (è¿›é˜¶)
                    </label>
                    <label class="checkbox-label"><input type="checkbox" id="chk-debug"> è°ƒè¯•æ•°æ®</label>
                </div>
            </div>

            <!-- 6. ç³»ç»Ÿå¤ä½ -->
            <div class="control-section">
                <button class="btn" onclick="resetSystem()">ğŸ”„ é‡ç½®ç³»ç»Ÿ (Reset)</button>
            </div>

            <!-- 7. æ•°æ®é¢æ¿ -->
            <div class="data-panel">
                <div style="border-bottom:1px solid #334155; padding-bottom:5px; margin-bottom:8px; font-weight:bold;">ç³»ç»Ÿæˆåƒåˆ†æ</div>
                <div class="data-row"><span>é€é•œæ•°é‡:</span> <span class="data-val" id="val-count">1</span></div>
                <div class="data-row"><span>æ€»æ”¾å¤§ç‡:</span> <span class="data-val" id="val-m">--</span></div>
                <div class="data-row"><span>æœ€ç»ˆåƒåæ ‡X:</span> <span class="data-val" id="val-img-x">--</span></div>
                <div style="margin-top:10px; color:#cbd5e1; font-size:11px; line-height:1.4;" id="val-desc">
                    --
                </div>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <div id="toast">æç¤ºä¿¡æ¯</div>
    </div>
</div>

<script>
    // --- æ ¸å¿ƒçŠ¶æ€ ---
    const STATE = {
        mode: 'view', // 'view' | 'adding'
        lenses: [],
        nextId: 1,
        previewLens: null, 
        referenceImage: null,
        objX: -300,  
        objH: 120,   
        view: { zoom: 1.0, panX: 0, panY: 0 },
        dragging: null, 
        panStart: null,
        showRays: true,
        showGrid: true,
        showValues: true,
        showEye: true,
        showThick: false, 
        showGhost: true,
        showFocalPlanes: false, 
        showDebug: false,
        useRealAperture: false, // æ–°å¢ï¼šçœŸå®å­”å¾„å¼€å…³
        isBlocked: false 
    };

    // --- æ ¸å¿ƒç®—æ³•ï¼šç‰©ç†è®¡ç®— ---
    function calculateSystem(lensesToCalc) {
        let sortedLenses = [...lensesToCalc].sort((a, b) => a.x - b.x);
        let currImg = { x: STATE.objX, h: STATE.objH };
        let totalM = 1;
        let isLastReal = true;
        let valid = true;
        let isParallel = false;

        for (let lens of sortedLenses) {
            let u = lens.x - currImg.x;
            let f = lens.type === 'convex' ? lens.f : -lens.f;
            
            if (Math.abs(u - f) < 1.0) { 
                valid = false; isParallel = true; break; 
            }

            let v = (u * f) / (u - f);
            let m = -v / u; 
            currImg.x = lens.x + v;
            currImg.h = currImg.h * m;
            totalM *= m;
            isLastReal = v > 0;
        }

        let finalImage = valid ? { x: currImg.x, h: currImg.h, isReal: isLastReal } : null;
        return { sortedLenses, finalImage, totalM, isParallel };
    }

    // p5.js å®ä¾‹
    let sketch = (p) => {
        let cvs;

        p.setup = () => {
            let container = document.getElementById('canvas-container');
            cvs = p.createCanvas(container.offsetWidth, container.offsetHeight);
            cvs.parent('canvas-container');
            p.textFont('Segoe UI');
            resetSystem();
        };

        p.windowResized = () => {
            let container = document.getElementById('canvas-container');
            p.resizeCanvas(container.offsetWidth, container.offsetHeight);
        };

        const screenToWorld = (sx, sy) => {
            let cx = p.width / 2;
            let cy = p.height / 2;
            return {
                x: (sx - cx - STATE.view.panX) / STATE.view.zoom,
                y: (sy - cy - STATE.view.panY) / STATE.view.zoom
            };
        };

        p.draw = () => {
            p.background(255);
            
            let cx = p.width / 2;
            let cy = p.height / 2;

            p.push();
            p.translate(cx + STATE.view.panX, cy + STATE.view.panY);
            p.scale(STATE.view.zoom);

            if (STATE.showGrid) {
                drawGridLines(p);
                drawRuler(p);
            } else {
                drawAxis(p);
            }

            if (STATE.showGhost && STATE.referenceImage) {
                drawGhostImage(p, STATE.referenceImage);
            }

            STATE.lenses.forEach(lens => drawLens(p, lens, false));
            
            if (STATE.mode === 'adding' && STATE.previewLens) {
                drawLens(p, STATE.previewLens, true); 
            }

            drawObject(p);

            if (STATE.isBlocked) drawBlocker(p);

            if (STATE.showFocalPlanes) drawFocalPlanes(p);

            let systemResult = calculateSystem(STATE.lenses);
            
            if (STATE.showRays) {
                let imgToDraw = systemResult.isParallel ? null : systemResult.finalImage;
                traceAndDrawRays(p, systemResult.sortedLenses, imgToDraw);
            }

            if (systemResult.finalImage) {
                drawFinalImage(p, systemResult.finalImage);
                if (STATE.showEye && !systemResult.finalImage.isReal) {
                    drawEye(p); 
                }
            }

            if (STATE.showValues) {
                drawDimensions(p, systemResult);
            }

            p.pop();

            drawStatusOverlay(p, systemResult);

            handleCursor(p);
            updateDataPanel(systemResult);
        };

        // --- ç»˜å›¾è¾…åŠ©å‡½æ•° ---

        function drawGridLines(p) {
            p.push();
            p.stroke(230); p.strokeWeight(1 / STATE.view.zoom);
            let left = -3000; let right = 3000;
            let top = -2000; let bottom = 2000;
            for (let x = left; x <= right; x += 50) p.line(x, top, x, bottom);
            for (let y = top; y <= bottom; y += 50) p.line(left, y, right, y);
            p.pop();
        }

        function drawRuler(p) {
            p.push();
            p.stroke(100); p.strokeWeight(1.5 / STATE.view.zoom);
            p.line(-10000, 0, 10000, 0); 
            p.fill(150); p.noStroke(); p.textAlign(p.CENTER, p.TOP);
            p.textSize(10 / STATE.view.zoom);
            for (let x = -3000; x <= 3000; x += 100) {
                p.stroke(150); p.strokeWeight(1 / STATE.view.zoom);
                p.line(x, 0, x, 5);
                if (x !== 0 && Math.abs(x)%200===0) { p.noStroke(); p.text(x, x, 8); }
            }
            p.fill(50); p.textStyle(p.BOLD); p.textSize(12 / STATE.view.zoom);
            p.text("O", 0, 8);
            p.pop();
        }

        function drawAxis(p) {
            p.stroke(100); p.strokeWeight(1.5 / STATE.view.zoom);
            p.line(-10000, 0, 10000, 0);
        }

        function drawFocalPlanes(p) {
            let mainLens = STATE.lenses.find(l => l.isMain);
            if (!mainLens) return;
            p.push();
            p.stroke(255, 100, 100, 100); 
            p.strokeWeight(1 / STATE.view.zoom);
            p.drawingContext.setLineDash([5, 5]);
            let f1 = mainLens.x - mainLens.f;
            let f2 = mainLens.x + mainLens.f;
            p.line(f1, -2000, f1, 2000);
            p.line(f2, -2000, f2, 2000);
            p.noStroke();
            p.fill(255, 100, 100);
            p.textSize(11 / STATE.view.zoom);
            p.textAlign(p.LEFT, p.TOP);
            p.text("ç„¦å¹³é¢", f1 + 5, -200);
            p.text("ç„¦å¹³é¢", f2 + 5, -200);
            p.pop();
        }

        function drawLens(p, lens, isPreview) {
            p.push();
            p.translate(lens.x, 0);
            
            let isHover = false;
            if (STATE.dragging && STATE.dragging.id === lens.id) isHover = true;
            
            let baseColor;
            if (isPreview) {
                baseColor = [249, 115, 22]; 
                p.drawingContext.setLineDash([5, 5]);
            } else {
                baseColor = lens.isMain ? [59, 130, 246] : [100, 116, 139]; 
                p.drawingContext.setLineDash([]);
            }
            if (isHover) baseColor = [245, 158, 11];

            p.stroke(baseColor); 
            p.strokeWeight(isPreview ? 1.5/STATE.view.zoom : 2/STATE.view.zoom);
            p.fill(baseColor[0], baseColor[1], baseColor[2], isPreview ? 10 : 30);

            let thickness = p.map(lens.f, 50, 500, 40, 10);
            let h = 200;

            if (lens.type === 'convex') {
                p.ellipse(0, 0, thickness, h);
                p.line(0, -h/2 + 10, 0, h/2 - 10);
            } else {
                p.beginShape();
                p.vertex(-thickness/2, -h/2); p.vertex(thickness/2, -h/2);
                p.quadraticVertex(5, 0, thickness/2, h/2);
                p.vertex(-thickness/2, h/2);
                p.quadraticVertex(-5, 0, -thickness/2, -h/2);
                p.endShape(p.CLOSE);
                p.line(0, -h/2 + 10, 0, h/2 - 10);
            }

            p.fill(baseColor); p.noStroke();
            let r = 5 / STATE.view.zoom; 
            p.circle(-lens.f, 0, r); 
            p.circle(lens.f, 0, r);  
            
            if (!isPreview && (lens.isMain || lens.type === 'convex')) {
                p.circle(-lens.f * 2, 0, r);
                p.circle(lens.f * 2, 0, r);
            }
            
            if (STATE.showValues || isPreview) {
                p.textSize(10 / STATE.view.zoom);
                p.textAlign(p.CENTER, p.TOP);
                p.fill(baseColor);
                
                if (isPreview || lens.isMain || lens.type === 'convex') {
                    p.text("F", -lens.f, 8);
                    p.text("F'", lens.f, 8);
                }
                
                if (!isPreview && (lens.isMain || lens.type === 'convex')) {
                    p.text("2F", -lens.f * 2, 8);
                    p.text("2F'", lens.f * 2, 8);
                }

                let label = isPreview ? "é¢„è§ˆä½ç½®" : (lens.isMain ? "ä¸»é€é•œ" : `é€é•œ ${lens.id}`);
                p.text(label, 0, -h/2 - 15);
                p.text(`f=${lens.f}`, 0, h/2 + 5);
            }
            p.pop();
        }

        function drawObject(p) {
            p.push();
            p.translate(STATE.objX, 0);
            let color = [220, 38, 38];
            p.stroke(color); p.strokeWeight(3 / STATE.view.zoom);
            p.line(0, 0, 0, -STATE.objH);
            p.fill(color); p.noStroke();
            let yTip = -STATE.objH;
            let dir = STATE.objH > 0 ? 1 : -1;
            let arrowSize = 10 / STATE.view.zoom;
            p.triangle(-arrowSize/2, yTip + arrowSize*dir, arrowSize/2, yTip + arrowSize*dir, 0, yTip);
            
            if (STATE.showValues) {
                p.textAlign(p.CENTER, STATE.objH > 0 ? p.BOTTOM : p.TOP);
                p.textSize(14 / STATE.view.zoom);
                p.text("ç‰©ä½“", 0, yTip - 12 * dir);
                p.textSize(10 / STATE.view.zoom);
                p.text(`u=${Math.abs(Math.round(STATE.objX))}`, 0, 5 * dir);
            }
            p.pop();
        }

        function drawBlocker(p) {
            let mainLens = STATE.lenses.find(l => l.isMain) || {x:0};
            p.push();
            p.translate(mainLens.x, 0);
            p.fill(50, 50, 50, 200); p.noStroke();
            p.rect(-5, -200, 10, 200); 
            p.fill(255); p.textSize(12 / STATE.view.zoom);
            p.textAlign(p.CENTER, p.CENTER); p.text("é®æŒ¡", 0, -100);
            p.pop();
        }

        function drawFinalImage(p, img) {
            if (Math.abs(img.x) > 20000 || Math.abs(img.h) > 10000) return;
            p.push();
            p.translate(img.x, 0);
            let color = img.isReal ? "#10b981" : "#8b5cf6"; 
            if (STATE.isBlocked && img.isReal) color = "#6ee7b7"; 
            
            // æ–°å¢ï¼šçœŸå®å­”å¾„æ¨¡å¼ä¸‹ï¼Œæˆåƒå˜æš—ï¼ˆé€æ˜åº¦é™ä½ï¼‰
            if (STATE.useRealAperture) {
                // p5 color with alpha
                let c = p.color(color);
                c.setAlpha(120); // å˜æš—/åŠé€æ˜
                p.stroke(c);
                p.fill(c);
            } else {
                p.stroke(color);
                p.fill(color);
            }

            p.strokeWeight(3 / STATE.view.zoom);
            if (!img.isReal) p.drawingContext.setLineDash([5, 5]);
            p.line(0, 0, 0, -img.h);
            p.noStroke(); // Fill for triangle uses same color
            p.drawingContext.setLineDash([]);
            let yTip = -img.h;
            let dir = img.h > 0 ? 1 : -1;
            let arrowSize = 10 / STATE.view.zoom;
            p.triangle(-arrowSize/2, yTip + arrowSize*dir, arrowSize/2, yTip + arrowSize*dir, 0, yTip);
            
            if (STATE.showValues) {
                p.textAlign(p.CENTER, img.h > 0 ? p.BOTTOM : p.TOP);
                p.textSize(14 / STATE.view.zoom);
                p.text(img.isReal ? "æœ€ç»ˆåƒ" : "æœ€ç»ˆè™šåƒ", 0, yTip - 10 * dir);
            }
            p.pop();
        }

        function drawGhostImage(p, img) {
            if (Math.abs(img.x) > 20000) return;
            p.push();
            p.translate(img.x, 0);
            let color = [150, 150, 150, 100]; 
            p.stroke(color); p.strokeWeight(2 / STATE.view.zoom);
            if (!img.isReal) p.drawingContext.setLineDash([5, 5]);
            p.line(0, 0, 0, -img.h);
            p.fill(color); p.noStroke(); p.drawingContext.setLineDash([]);
            let yTip = -img.h;
            let dir = img.h > 0 ? 1 : -1;
            let arrowSize = 8 / STATE.view.zoom;
            p.triangle(-arrowSize/2, yTip + arrowSize*dir, arrowSize/2, yTip + arrowSize*dir, 0, yTip);
            p.textAlign(p.CENTER, img.h > 0 ? p.TOP : p.BOTTOM); 
            p.textSize(11 / STATE.view.zoom);
            p.fill(150);
            p.text("åŸåƒ", 0, 5);
            p.pop();
        }

        function drawDimensions(p, res) {
            p.push();
            let yLevel = 180;
            p.strokeWeight(1 / STATE.view.zoom);
            p.textSize(11 / STATE.view.zoom);
            p.textAlign(p.CENTER, p.BOTTOM);

            let mainLens = STATE.lenses.find(l => l.isMain) || {x:0};
            let mx = mainLens.x;
            
            let fColor = "#3b82f6";
            drawDimLine(p, mx, mx - mainLens.f, yLevel + 12, `f=${mainLens.f}`, fColor);

            let uColor = "#ef4444";
            drawDimLine(p, STATE.objX, mx, yLevel, `u=${Math.abs(Math.round(mx - STATE.objX))}`, uColor);

            if (res.finalImage) {
                let vColor = res.finalImage.isReal ? "#10b981" : "#8b5cf6";
                drawDimLine(p, mx, res.finalImage.x, yLevel + 25, `x(åƒåæ ‡)=${Math.round(res.finalImage.x - mx)}`, vColor);
            }
            p.pop();
        }

        function drawDimLine(p, x1, x2, y, label, color) {
            if (Math.abs(x1 - x2) < 2) return;
            p.stroke(color); p.fill(color);
            p.line(x1, y, x2, y);
            let h = 3 / STATE.view.zoom;
            p.line(x1, y-h, x1, y+h);
            p.line(x2, y-h, x2, y+h);
            p.noStroke();
            let mid = (x1 + x2) / 2;
            p.text(label, mid, y - 2);
            p.strokeWeight(1 / STATE.view.zoom); 
        }

        function drawEye(p) {
            p.push();
            let rightmostX = 0;
            STATE.lenses.forEach(l => { if(l.x > rightmostX) rightmostX = l.x; });
            if (STATE.mode === 'adding' && STATE.previewLens && STATE.previewLens.x > rightmostX) {
                rightmostX = STATE.previewLens.x;
            }
            let eyeX = Math.max(500, rightmostX + 400);
            p.translate(eyeX, 0);
            p.scale(1 / STATE.view.zoom); 
            p.stroke(50); p.strokeWeight(2); p.fill(255);
            p.beginShape();
            p.vertex(15, -10); p.quadraticVertex(-15, 0, 15, 10);
            p.endShape(p.CLOSE);
            p.fill(0); p.circle(0, 0, 6);
            p.noStroke(); p.fill(80); p.textAlign(p.CENTER, p.TOP);
            p.textSize(12);
            p.text("è§‚å¯Ÿæ–¹å‘", 0, 15);
            p.pop();
        }

        function drawStatusOverlay(p, res) {
            if (!res) return;
            let text = "", subText = "", color = [50, 50, 50];
            let isSingleLens = (STATE.lenses.length === 1);

            if (res.isParallel) {
                text = "å…‰çº¿å¹³è¡Œ Â· ä¸æˆåƒ";
                subText = isSingleLens ? "åŸç†ï¼šæ¢ç…§ç¯ / å¹³è¡Œå…‰æº (u = f)" : "ç³»ç»Ÿå°„å‡ºå¹³è¡Œå…‰";
                color = [234, 88, 12];
            } else if (res.finalImage) {
                let m = res.totalM;
                let isReal = res.finalImage.isReal;
                let absM = Math.abs(m);

                if (isReal) {
                    if (Math.abs(absM - 1.0) < 0.05) {
                        text = "å€’ç«‹ Â· ç­‰å¤§ Â· å®åƒ";
                        subText = isSingleLens ? "åŸç†ï¼šæµ‹ç„¦è· (u = 2f)" : "æ”¾å¤§ç‡ |M| â‰ˆ 1";
                        color = [16, 185, 129];
                    } else if (absM < 1.0) {
                        text = "å€’ç«‹ Â· ç¼©å° Â· å®åƒ";
                        subText = isSingleLens ? "åŸç†ï¼šç…§ç›¸æœº (u > 2f)" : "èµ·ç¼©å°ä½œç”¨";
                        color = [16, 185, 129];
                    } else {
                        text = "å€’ç«‹ Â· æ”¾å¤§ Â· å®åƒ";
                        subText = isSingleLens ? "åŸç†ï¼šæŠ•å½±ä»ª (f < u < 2f)" : "èµ·æ”¾å¤§ä½œç”¨";
                        color = [16, 185, 129];
                    }
                } else {
                    if (absM > 1.0) {
                        text = "æ­£ç«‹ Â· æ”¾å¤§ Â· è™šåƒ";
                        subText = isSingleLens ? "åŸç†ï¼šæ”¾å¤§é•œ (u < f)" : "èµ·æ”¾å¤§ä½œç”¨";
                        color = [139, 92, 246];
                    } else {
                        text = "æ­£ç«‹ Â· ç¼©å° Â· è™šåƒ";
                        subText = isSingleLens ? "åŸç†ï¼šè¿‘è§†çœ¼é•œ" : "èµ·ç¼©å°ä½œç”¨";
                        color = [139, 92, 246];
                    }
                }
            } else { return; }
            
            if(STATE.isBlocked && res.finalImage && res.finalImage.isReal) {
                subText += " (é®æŒ¡æç¤ºï¼šåƒå®Œæ•´ï¼Œäº®åº¦å˜æš—)";
            }
            // æ–°å¢ï¼šçœŸå®å­”å¾„æç¤º
            if(STATE.useRealAperture) {
                subText += " | çœŸå®å­”å¾„å¼€å¯";
            }

            p.push();
            p.resetMatrix(); 
            p.translate(p.width / 2, 45); 
            p.rectMode(p.CENTER);
            p.noStroke(); p.fill(0, 0, 0, 20); p.rect(2, 2, 320, 56, 28);
            p.fill(255, 255, 255, 240); p.stroke(220); p.strokeWeight(1); p.rect(0, 0, 320, 56, 28);
            p.textAlign(p.CENTER, p.CENTER); p.noStroke(); p.fill(color);
            p.textSize(18); p.textStyle(p.BOLD); p.text(text, 0, -8);
            p.fill(100, 116, 139); p.textSize(12); p.textStyle(p.NORMAL); p.text(subText, 0, 12);
            p.pop();
        }

        function traceAndDrawRays(p, sortedLenses, finalImage) {
            let startX = STATE.objX;
            let startY = -STATE.objH;
            
            let firstLensX = sortedLenses.length > 0 ? sortedLenses[0].x : startX + 200;
            if (firstLensX <= startX) firstLensX = startX + 200; 

            let slopes = [0]; 
            slopes.push((0 - startY) / (firstLensX - startX)); 
            if (sortedLenses.length > 0) {
                let l1 = sortedLenses[0];
                let targetFX = l1.type === 'convex' ? (l1.x - l1.f) : (l1.x + l1.f);
                if (Math.abs(targetFX - startX) > 1) slopes.push((0 - startY) / (targetFX - startX));
            }
            for(let i = -0.15; i <= 0.15; i+=0.06) {
                if (Math.abs(i) > 0.01) slopes.push(Math.atan2(-startY, firstLensX-startX) + i);
            }

            p.noFill();
            p.strokeWeight(1 / STATE.view.zoom);

            slopes.forEach(k => {
                p.stroke(245, 158, 11, 150); 
                if (Math.abs(k) < 0.001) p.stroke(245, 158, 11, 200); 

                p.beginShape();
                p.vertex(startX, startY);

                let currX = startX;
                let currY = startY;
                let currK = k; 
                let rayStopped = false;

                for (let lens of sortedLenses) {
                    if (lens.x <= currX + 0.1) continue;

                    let dx = lens.x - currX;
                    let dy = dx * currK; 
                    let hitY = currY + dy;

                    // é®æŒ¡åˆ¤æ–­ (ä¸»é€é•œä¸ŠåŠéƒ¨)
                    if (STATE.isBlocked && lens.isMain && hitY < 0) {
                         p.vertex(lens.x, hitY); rayStopped = true; break; 
                    }

                    // --- æ–°å¢ï¼šçœŸå®å­”å¾„é€»è¾‘ (Aperture) ---
                    // å‡è®¾é€é•œç‰©ç†é«˜åº¦é™åˆ¶ä¸º Â±100 (å³å¯è§†åŒ–çš„ h=200)
                    if (STATE.useRealAperture && Math.abs(hitY) > 100) {
                        // å…‰çº¿æ‰“åœ¨é€é•œå¤–ï¼Œç›´æ¥ç©¿è¿‡ï¼Œä¸å‘ç”ŸæŠ˜å°„
                        // ç»˜åˆ¶åˆ°é€é•œå¹³é¢çš„ç‚¹
                        p.vertex(lens.x, hitY);
                        currX = lens.x;
                        currY = hitY;
                        // currK ä¿æŒä¸å˜ (ç›´çº¿ä¼ æ’­)
                        continue; 
                    }

                    if (STATE.showThick) {
                        let thickness = p.map(lens.f, 50, 500, 40, 10);
                        let halfT = thickness / 2;
                        let entryX = lens.x - halfT;
                        let exitX = lens.x + halfT;
                        let entryY = hitY - halfT * currK; 
                        let kIn = currK / 1.5;
                        let exitY = entryY + thickness * kIn;
                        p.vertex(entryX, entryY); p.vertex(exitX, exitY);
                        hitY = exitY; currX = exitX;
                    } else {
                        p.vertex(lens.x, hitY); currX = lens.x;
                    }

                    let f = lens.type === 'convex' ? lens.f : -lens.f;
                    let dk = -hitY / f;
                    currK += dk; currY = hitY;
                }

                if (!rayStopped) {
                    let endX = currX + 2000;
                    let endY = currY + (endX - currX) * currK;
                    p.vertex(endX, endY);
                    
                    if (finalImage && !finalImage.isReal) {
                        // å¦‚æœå¼€å¯äº†çœŸå®å­”å¾„ä¸”å…‰çº¿æ²¡æ‰“ä¸­é€é•œï¼Œè¿™æ¡å…‰çº¿ä¸åº”è¯¥å‚ä¸è™šåƒçš„åå‘å»¶é•¿
                        // ç®€åŒ–å¤„ç†ï¼šä¾ç„¶ç”»åå‘å»¶é•¿ï¼Œä½†ç‰©ç†ä¸Šå…¶å®å®ƒä¸æ„æˆåƒ
                        // ä¸ºäº†æ•™å­¦æ¸…æ™°ï¼Œä¿æŒç°æœ‰é€»è¾‘
                        p.endShape(); 
                        p.push();
                        p.stroke(147, 51, 234, 80); 
                        p.strokeWeight(1 / STATE.view.zoom);
                        p.drawingContext.setLineDash([5, 5]);
                        p.beginShape();
                        p.vertex(currX, currY); 
                        p.vertex(finalImage.x, finalImage.h * -1); 
                        p.endShape();
                        p.pop();
                        return; 
                    }
                }
                p.endShape();
            });
        }

        // --- äº¤äº’é€»è¾‘ ---

        function handleCursor(p) {
            if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) return;
            let wm = screenToWorld(p.mouseX, p.mouseY);
            
            let cursorStyle = 'default';
            
            // 1. ç‰©ä½“
            if (Math.abs(wm.x - STATE.objX) < 40 && wm.y < 50 && wm.y > -Math.abs(STATE.objH)*1.5) cursorStyle = 'grab';
            
            // 2. ä¸»é€é•œç„¦ç‚¹ (Left F or Right F)
            let mainLens = STATE.lenses.find(l => l.isMain);
            if (mainLens) {
                if (Math.abs(wm.x - (mainLens.x - mainLens.f)) < 20 && Math.abs(wm.y) < 20) cursorStyle = 'ew-resize';
                if (Math.abs(wm.x - (mainLens.x + mainLens.f)) < 20 && Math.abs(wm.y) < 20) cursorStyle = 'ew-resize';
            }

            // 3. å…¶ä»–é€é•œ
            let hitLens = STATE.lenses.find(l => Math.abs(wm.x - l.x) < 40 && Math.abs(wm.y) < 150);
            if (hitLens) cursorStyle = 'grab';
            
            if (STATE.mode === 'adding' && STATE.previewLens) {
                if (Math.abs(wm.x - STATE.previewLens.x) < 40 && Math.abs(wm.y) < 150) cursorStyle = 'grab';
            }

            if (STATE.dragging || STATE.panStart) cursorStyle = 'grabbing';
            p.cursor(cursorStyle);
        }

        p.mousePressed = () => {
            if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) return;
            let wm = screenToWorld(p.mouseX, p.mouseY);
            
            // 1. æ‹–åŠ¨ç‰©ä½“
            if (Math.abs(wm.x - STATE.objX) < 40 && wm.y < 50 && wm.y > -Math.abs(STATE.objH)*1.5) {
                STATE.dragging = { type: 'obj', startX: STATE.objX, offsetX: STATE.objX - wm.x };
                return;
            }

            // 2. æ‹–åŠ¨ä¸»é€é•œç„¦ç‚¹ (è°ƒèŠ‚ç„¦è·) - ä¼˜å…ˆçº§é«˜
            let mainLens = STATE.lenses.find(l => l.isMain);
            if (mainLens) {
                // å·¦ç„¦ç‚¹
                if (Math.abs(wm.x - (mainLens.x - mainLens.f)) < 20 && Math.abs(wm.y) < 20) {
                    STATE.dragging = { type: 'focus', lens: mainLens, side: -1 }; // side -1 = left
                    return;
                }
                // å³ç„¦ç‚¹
                if (Math.abs(wm.x - (mainLens.x + mainLens.f)) < 20 && Math.abs(wm.y) < 20) {
                    STATE.dragging = { type: 'focus', lens: mainLens, side: 1 }; // side 1 = right
                    return;
                }
            }

            // 3. æ‹–åŠ¨é¢„è§ˆé€é•œ (ä¼˜å…ˆ)
            if (STATE.mode === 'adding' && STATE.previewLens) {
                if (Math.abs(wm.x - STATE.previewLens.x) < 40 && Math.abs(wm.y) < 150) {
                    STATE.dragging = { type: 'preview', offsetX: STATE.previewLens.x - wm.x };
                    return;
                }
            }

            // 4. æ‹–åŠ¨ç°æœ‰é€é•œ (éæ·»åŠ æ¨¡å¼)
            if (STATE.mode !== 'adding') {
                let hitLens = STATE.lenses.find(l => Math.abs(wm.x - l.x) < 40 && Math.abs(wm.y) < 150);
                if (hitLens) {
                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯ä¸»é€é•œæœ¬ä½“ï¼Œæš‚æ—¶ä¸å…è®¸ç§»åŠ¨ä½ç½®ï¼ˆé€šå¸¸å›ºå®š0ç‚¹ï¼‰ï¼Œåªå…è®¸éä¸»é€é•œç§»åŠ¨
                    if (!hitLens.isMain) {
                        STATE.dragging = { type: 'lens', id: hitLens.id, startX: hitLens.x, offsetX: hitLens.x - wm.x };
                        return;
                    }
                }
            }

            // 5. å¹³ç§»ç”»å¸ƒ
            STATE.panStart = { x: p.mouseX, y: p.mouseY, viewX: STATE.view.panX, viewY: STATE.view.panY };
        };

        p.mouseDragged = () => {
            if (STATE.dragging) {
                let wm = screenToWorld(p.mouseX, p.mouseY);
                let d = STATE.dragging;
                
                if (d.type === 'obj') {
                    STATE.objX = wm.x + d.offsetX;
                    if (STATE.objX > -20) STATE.objX = -20; 
                } else if (d.type === 'focus') {
                    // è°ƒèŠ‚ç„¦è·
                    // è·ç¦» = |MouseX - LensX|
                    let newF = Math.abs(wm.x - d.lens.x);
                    newF = Math.max(50, Math.min(newF, 400));
                    d.lens.f = newF;
                    // åŒæ­¥åˆ° UI
                    updateMainLensUI();
                } else if (d.type === 'lens') {
                    let lens = STATE.lenses.find(l => l.id === d.id);
                    if (lens) {
                        lens.x = wm.x + d.offsetX;
                        renderLensList();
                    }
                } else if (d.type === 'preview') {
                    if (STATE.previewLens) {
                        STATE.previewLens.x = wm.x + d.offsetX;
                    }
                }
                return; 
            }
            if (STATE.panStart) {
                let dx = p.mouseX - STATE.panStart.x;
                let dy = p.mouseY - STATE.panStart.y;
                STATE.view.panX = STATE.panStart.viewX + dx;
                STATE.view.panY = STATE.panStart.viewY + dy;
            }
        };

        p.mouseReleased = () => { STATE.dragging = null; STATE.panStart = null; };
        p.mouseWheel = (e) => {
            let s = e.delta > 0 ? 0.9 : 1.1;
            STATE.view.zoom = p.constrain(STATE.view.zoom * s, 0.2, 5);
            return false;
        };
    };

    let myp5 = new p5(sketch);

    // --- ä¸šåŠ¡ä¸æ§åˆ¶é€»è¾‘ ---

    function resetSystem(keepLens = false) {
        if (!keepLens) {
            STATE.lenses = [{ id: 1, x: 0, f: 160, type: 'convex', isMain: true }];
            STATE.nextId = 2;
        }
        STATE.objX = -320; 
        STATE.objH = 120;
        STATE.view = { zoom: 1.0, panX: -100, panY: 0 }; // é»˜è®¤ç•¥å¾®å·¦ç§»
        STATE.mode = 'view';
        STATE.previewLens = null;
        STATE.referenceImage = null;
        
        // é‡ç½®æ‰€æœ‰é€‰é¡¹
        STATE.showThick = false;
        STATE.isBlocked = false;
        STATE.showFocalPlanes = false;
        STATE.useRealAperture = false;
        document.getElementById('chk-thick').checked = false;
        document.getElementById('chk-block').checked = false;
        document.getElementById('chk-focal-planes').checked = false;
        document.getElementById('chk-aperture').checked = false;
        
        toggleAddModeUI(false);
        renderLensList();
        updateUI();
        showToast("ç³»ç»Ÿå·²é‡ç½®");
    }

    // --- ä¸»é€é•œæ§åˆ¶ (æ–°å¢) ---
    window.setMainLensType = (type) => {
        let mainLens = STATE.lenses.find(l => l.isMain);
        if(mainLens) {
            mainLens.type = type;
            updateMainLensUI();
        }
    };

    // ç„¦è·æ»‘å—äº‹ä»¶ç›‘å¬
    document.getElementById('slider-main-f').addEventListener('input', (e) => {
        let val = parseInt(e.target.value);
        let mainLens = STATE.lenses.find(l => l.isMain);
        if(mainLens) {
            mainLens.f = val;
            updateMainLensUI(true); // true = skip slider update to avoid feedback loop
        }
    });

    function updateMainLensUI(skipSlider = false) {
        let mainLens = STATE.lenses.find(l => l.isMain);
        if(!mainLens) return;

        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        document.getElementById('btn-main-convex').className = `btn ${mainLens.type==='convex'?'active':''}`;
        document.getElementById('btn-main-concave').className = `btn ${mainLens.type==='concave'?'active':''}`;
        
        // æ›´æ–°æ•°å€¼æ˜¾ç¤º
        document.getElementById('main-f-val').innerText = `f=${Math.round(mainLens.f)}`;
        
        // æ›´æ–°æ»‘å—ä½ç½® (å¦‚æœæ˜¯æ‹–åŠ¨Fç‚¹è§¦å‘çš„ï¼Œéœ€è¦åŒæ­¥æ»‘å—)
        if(!skipSlider) {
            document.getElementById('slider-main-f').value = mainLens.f;
        }
    }

    // --- åœºæ™¯è®¾ç½® ---
    window.setScenario = (id) => {
        STATE.referenceImage = null;
        STATE.lenses = [{ id: 1, x: 0, f: 160, type: 'convex', isMain: true }];
        STATE.nextId = 2;
        
        // é‡ç½®é€‰é¡¹
        STATE.showThick = false;
        STATE.isBlocked = false;
        STATE.showFocalPlanes = false;
        STATE.useRealAperture = false;
        document.getElementById('chk-thick').checked = false;
        document.getElementById('chk-block').checked = false;
        document.getElementById('chk-focal-planes').checked = false;
        document.getElementById('chk-aperture').checked = false;

        let f = 160;
        let lens = STATE.lenses[0];

        switch(id) {
            case 1: STATE.objX = -2.5 * f; break;
            case 2: STATE.objX = -2.0 * f; break;
            case 3: STATE.objX = -1.5 * f; break;
            case 4: STATE.objX = -1.0 * f; break;
            case 5: STATE.objX = -0.6 * f; break;
            case 6: lens.type = 'concave'; STATE.objX = -2.0 * f; break;
        }
        
        STATE.view.panX = -100; // å¾®è°ƒè§†å›¾ï¼Œç•™å‡ºå³ä¾§ç©ºé—´
        STATE.view.zoom = 1.0;
        renderLensList();
        updateUI();
    };

    // --- æ·»åŠ é€é•œæµç¨‹ ---
    window.startAddLens = () => {
        STATE.mode = 'adding';
        STATE.previewLens = { 
            id: -1, x: STATE.objX / 2, f: 150, type: 'convex', isMain: false 
        };
        toggleAddModeUI(true);
        updatePreviewUI();
        showToast("æ‹–åŠ¨è™šçº¿é€é•œåˆ°ç›®æ ‡ä½ç½®\nè§‚å¯ŸFç‚¹ï¼Œç¡®è®¤åç”Ÿæ•ˆ");
    };

    window.cancelAddLens = () => {
        STATE.mode = 'view';
        STATE.previewLens = null;
        toggleAddModeUI(false);
    };

    window.confirmAddLens = () => {
        if (!STATE.previewLens) return;
        
        let currentRes = calculateSystem(STATE.lenses);
        if (currentRes.finalImage) {
            STATE.referenceImage = { ...currentRes.finalImage }; 
        } else {
            STATE.referenceImage = null; 
        }

        let newLens = { ...STATE.previewLens, id: STATE.nextId++ };
        STATE.lenses.push(newLens);
        STATE.mode = 'view';
        STATE.previewLens = null;
        
        toggleAddModeUI(false);
        renderLensList();
        showToast("é€é•œå·²æ·»åŠ \nç°è‰²è™šåƒä¸ºæ·»åŠ å‰çš„ä½ç½®");
    };

    window.updatePreviewLens = (prop, val) => {
        if (!STATE.previewLens) return;
        if (prop === 'f') STATE.previewLens.f = parseInt(val);
        if (prop === 'type') STATE.previewLens.type = val;
        updatePreviewUI();
    };

    function updatePreviewUI() {
        if (!STATE.previewLens) return;
        document.getElementById('preview-f-val').innerText = STATE.previewLens.f;
        document.getElementById('btn-prev-convex').className = `btn ${STATE.previewLens.type==='convex'?'active':''}`;
        document.getElementById('btn-prev-concave').className = `btn ${STATE.previewLens.type==='concave'?'active':''}`;
    }

    function toggleAddModeUI(isAdding) {
        document.getElementById('add-lens-panel').style.display = isAdding ? 'flex' : 'none';
        document.getElementById('btn-start-add').style.display = isAdding ? 'none' : 'flex';
    }

    function addLens() { startAddLens(); } 

    function removeLens(id) {
        STATE.lenses = STATE.lenses.filter(l => l.id !== id);
        STATE.referenceImage = null;
        renderLensList();
    }

    function renderLensList() {
        let container = document.getElementById('lens-list-container');
        container.innerHTML = '';
        STATE.lenses.forEach((lens) => {
            let isMain = lens.isMain;
            // ä¸»é€é•œä¸æ˜¾ç¤ºåœ¨ç§»é™¤åˆ—è¡¨ä¸­
            if (isMain) return; 

            let title = `é€é•œ L${lens.id}`;
            let card = document.createElement('div');
            card.className = `lens-card`;
            let html = `
                <div class="card-header">
                    <span>${title}</span>
                    <button class="btn btn-danger" onclick="removeLens(${lens.id})">ç§»é™¤</button>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#64748b;">
                    <span>f: ${lens.f}</span>
                    <span>x: ${Math.round(lens.x)}</span>
                </div>
            `;
            card.innerHTML = html;
            container.appendChild(card);
        });
        
        updateMainLensUI();
    }

    document.getElementById('slider-obj-h').addEventListener('input', (e) => {
        STATE.objH = parseInt(e.target.value);
        document.getElementById('obj-h-val').innerText = STATE.objH;
    });

    ['chk-rays', 'chk-values', 'chk-thick', 'chk-ghost', 'chk-grid', 'chk-eye', 'chk-block', 'chk-debug', 'chk-focal-planes', 'chk-aperture'].forEach(id => {
        document.getElementById(id).addEventListener('change', (e) => {
            let key = id.replace('chk-', '');
            if(key === 'block') STATE.isBlocked = e.target.checked;
            else if(key === 'thick') STATE.showThick = e.target.checked;
            else if(key === 'ghost') STATE.showGhost = e.target.checked;
            else if(key === 'grid') STATE.showGrid = e.target.checked;
            else if(key === 'eye') STATE.showEye = e.target.checked;
            else if(key === 'debug') STATE.showDebug = e.target.checked;
            else if(key === 'rays') STATE.showRays = e.target.checked;
            else if(key === 'values') STATE.showValues = e.target.checked;
            else if(key === 'focal-planes') STATE.showFocalPlanes = e.target.checked;
            else if(key === 'aperture') STATE.useRealAperture = e.target.checked; // æ–°å¢
        });
    });

    function updateDataPanel(res) {
        if (!res) return;
        document.getElementById('val-count').innerText = STATE.lenses.length;
        if (res.finalImage) {
            document.getElementById('val-m').innerText = res.totalM.toFixed(2) + "x";
            document.getElementById('val-img-x').innerText = res.finalImage.x.toFixed(0);
            let nature = res.finalImage.isReal ? "å®åƒ" : "è™šåƒ";
            document.getElementById('val-desc').innerText = nature;
        } else {
            document.getElementById('val-m').innerText = "--";
            document.getElementById('val-img-x').innerText = "âˆ";
            document.getElementById('val-desc').innerText = "æœªæˆåƒ";
        }
    }

    function updateUI() {
        document.getElementById('slider-obj-h').value = STATE.objH;
        document.getElementById('obj-h-val').innerText = STATE.objH;
        updateMainLensUI();
    }

    function showToast(msg) {
        let t = document.getElementById('toast');
        t.innerText = msg;
        t.style.opacity = 1; t.style.top = "40px";
        setTimeout(() => { t.style.opacity = 0; t.style.top = "20px"; }, 2000);
    }
</script>
</body>
</html>