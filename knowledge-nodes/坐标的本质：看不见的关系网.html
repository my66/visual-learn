<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åæ ‡çš„æœ¬è´¨ï¼šçœ‹ä¸è§çš„å…³ç³»ç½‘</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #f8fafc; font-family: "Noto Sans SC", system-ui, sans-serif; }
    /* ä¾§è¾¹æ ä¸å¸ƒå±€ */
    #sidebar {
      position: absolute; left: 0; top: 0; bottom: 0; width: 380px;
      background: white; border-right: 1px solid #e2e8f0; overflow-y: auto; z-index: 20;
      display: flex; flex-direction: column; shadow: 4px 0 24px rgba(0,0,0,0.05);
    }
    #canvas-container {
      position: absolute; left: 380px; top: 0; right: 0; bottom: 0;
      background: #f1f5f9; overflow: hidden; touch-action: none;
    }
    /* å¼•å¯¼å±‚ Overlay - å·²è°ƒæ•´ä½ç½®åˆ°å³ä¾§ */
    #guided-overlay {
      position: absolute; 
      top: 20px; 
      right: 40px; /* æ”¹ä¸ºé å³ï¼Œé¿å¼€å·¦ä¾§Yè½´ */
      left: auto; 
      transform: none;
      width: 420px; /* ç¨å¾®è°ƒçª„ */
      max-height: 80vh;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(8px);
      border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      border: 1px solid rgba(255,255,255,0.5);
      z-index: 30; display: flex; flex-direction: column;
      transition: opacity 0.3s ease;
    }
    .overlay-header {
      padding: 16px; border-bottom: 1px solid #f1f5f9;
      display: flex; justify-content: space-between; align-items: center;
      background: #fff; border-radius: 12px 12px 0 0;
    }
    .overlay-body {
      padding: 20px; overflow-y: auto; font-size: 15px; line-height: 1.6; color: #334155;
    }
    /* ç»„ä»¶æ ·å¼ */
    .btn {
      padding: 8px 16px; border-radius: 6px; font-weight: 500; cursor: pointer;
      transition: all 0.2s; border: 1px solid #cbd5e1; background: white; color: #475569;
    }
    .btn:hover { background: #f8fafc; border-color: #94a3b8; }
    .btn-primary { background: #3b82f6; color: white; border: none; }
    .btn-primary:hover { background: #2563eb; }
    .card { background: #fff; border-radius: 8px; border: 1px solid #e2e8f0; padding: 12px; margin-bottom: 12px; }
    .status-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 32px;
      background: #1e293b; color: #94a3b8; font-size: 12px;
      display: flex; align-items: center; padding: 0 16px; z-index: 40;
    }
    /* MathJax éšè— */
    .tex-container { visibility: hidden; min-height: 1.2em; }
    
    /* åœºæ™¯åˆ‡æ¢ Tab */
    .scene-tab {
      flex: 1; text-align: center; padding: 8px; font-size: 13px; cursor: pointer;
      border-bottom: 2px solid transparent; color: #64748b;
    }
    .scene-tab.active {
      border-bottom-color: #3b82f6; color: #3b82f6; font-weight: bold; background: #eff6ff;
    }
  </style>
</head>
<body>

  <!-- ä¾§è¾¹æ  -->
  <div id="sidebar">
    <!-- é¢˜ç›®/æ¦‚å¿µå¡ç‰‡ -->
    <div class="p-4 border-b border-gray-100 bg-white sticky top-0 z-10">
      <h2 class="text-lg font-bold text-slate-800 flex items-center gap-2">
        <span class="text-xl">ğŸ“ˆ</span> åæ ‡çš„æœ¬è´¨
      </h2>
      <div class="mt-2 text-sm text-slate-600 bg-slate-50 p-3 rounded border border-slate-200">
        <div class="font-semibold mb-1">æ ¸å¿ƒæ¦‚å¿µï¼š</div>
        <div id="problem-text">
          åæ ‡ç³»ä¸ä»…ä»…æ˜¯åœ°å›¾ä¸Šçš„â€œä½ç½®â€ï¼Œå®ƒæ›´æ˜¯è®°å½•<strong>ä¸¤ä¸ªå˜é‡ä¹‹é—´å…³ç³»</strong>çš„å·¥å…·ã€‚
          <br>
          é€šè¿‡æ¨ªè½´ï¼ˆXï¼‰å’Œçºµè½´ï¼ˆYï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠçœ‹ä¸è§çš„â€œå˜åŒ–è§„å¾‹â€ç”»æˆçœ‹å¾—è§çš„â€œçº¿â€ã€‚
        </div>
        <button onclick="copyProblem()" class="mt-2 text-xs text-blue-600 hover:text-blue-800 flex items-center gap-1">
          <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          å¤åˆ¶æ¦‚å¿µå®šä¹‰
        </button>
      </div>
    </div>

    <!-- æ¨¡å¼åˆ‡æ¢ -->
    <div class="flex border-b border-gray-200">
      <div id="tab-guided" class="w-1/2 p-3 text-center cursor-pointer font-bold border-b-2 border-blue-500 text-blue-600 bg-blue-50" onclick="setMode('guided')">
        ğŸ“š å¼•å¯¼å­¦ä¹ æ¨¡å¼
      </div>
      <div id="tab-sandbox" class="w-1/2 p-3 text-center cursor-pointer font-bold text-gray-500 hover:bg-gray-50" onclick="setMode('sandbox')">
        ğŸ› ï¸ è‡ªç”±æ¢ç´¢æ¨¡å¼
      </div>
    </div>

    <!-- åœºæ™¯é€‰æ‹© (ä»…æ²™ç›’æ¨¡å¼) -->
    <div id="sandbox-controls" class="hidden p-4">
      <div class="text-xs font-bold text-slate-400 uppercase mb-2 tracking-wider">é€‰æ‹©ç”Ÿæ´»åœºæ™¯</div>
      <div class="flex border rounded-lg overflow-hidden mb-4">
        <div class="scene-tab active" onclick="switchScene(0)">ğŸŒ¡ï¸ æ¸©åº¦å˜åŒ–</div>
        <div class="scene-tab" onclick="switchScene(1)">ğŸ’ƒ è·³èˆè½¨è¿¹</div>
        <div class="scene-tab" onclick="switchScene(2)">ğŸ è‹¹æœä»·æ ¼</div>
        <div class="scene-tab" onclick="switchScene(3)">ğŸ§  è®°å¿†é—å¿˜</div>
      </div>
    </div>

    <!-- åŠ¨æ€æ§åˆ¶åŒº -->
    <div class="flex-1 p-4 space-y-4 overflow-y-auto">
      
      <!-- æ’­æ”¾æ§åˆ¶ -->
      <div class="card space-y-3">
        <div class="flex justify-between items-center mb-1">
          <span class="font-bold text-sm text-slate-700">æ—¶é—´/å˜é‡æ§åˆ¶å™¨</span>
          <span id="var-val-display" class="text-xs font-mono bg-slate-100 px-2 py-1 rounded">X = 0</span>
        </div>
        <input type="range" id="main-slider" min="0" max="100" value="0" step="0.5" class="w-full accent-blue-600 cursor-pointer">
        <div class="flex gap-2">
          <button onclick="togglePlay()" id="play-btn" class="btn btn-primary flex-1 flex justify-center items-center gap-2">
            <span>â–¶</span> è‡ªåŠ¨æ¼”ç¤º
          </button>
          <button onclick="resetSim()" class="btn flex-1">â†º é‡ç½®</button>
        </div>
      </div>

      <!-- éªŒè¯/è§‚å¯Ÿé¢æ¿ -->
      <div class="card bg-slate-50 border-slate-200">
        <div class="flex justify-between items-center border-b border-slate-200 pb-2 mb-2">
          <span class="font-bold text-sm text-slate-700">ğŸ” è§‚å¯Ÿè®°å½•</span>
          <div id="verify-badge" class="px-2 py-0.5 rounded-full text-xs font-bold bg-gray-200 text-gray-500">å¾…è§‚å¯Ÿ</div>
        </div>
        <div id="observation-text" class="text-sm text-slate-600 space-y-2">
          ç§»åŠ¨æ»‘å—æˆ–ç‚¹å‡»æ’­æ”¾ï¼Œè§‚å¯Ÿå·¦ä¾§â€œç°å®â€ä¸å³ä¾§â€œå›¾åƒâ€çš„å¯¹åº”å…³ç³»ã€‚
        </div>
      </div>

      <!-- å¸¸è§é”™è¯¯ -->
      <div id="misconception-box" class="hidden card border-l-4 border-orange-400 bg-orange-50">
        <div class="flex items-center justify-between">
          <h4 class="font-bold text-sm text-orange-800">âš ï¸ å¸¸è§æ€ç»´è¯¯åŒº</h4>
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" id="error-toggle" class="sr-only peer" onchange="updateState()">
            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-orange-500"></div>
          </label>
        </div>
        <p class="text-xs text-orange-700 mt-1" id="misconception-text">
          æœ‰äº›åŒå­¦ä¼šä»¥ä¸ºå›¾åƒè¶Šé«˜ä»£è¡¨â€œè·‘å¾—è¶Šè¿œâ€ï¼Œå…¶å®è¿™é‡Œæ˜¯ä»£è¡¨...
        </p>
      </div>

    </div>
  </div>

  <!-- ä¸»ç”»å¸ƒ -->
  <div id="canvas-container"></div>

  <!-- å¼•å¯¼æ¨¡å¼å åŠ å±‚ -->
  <div id="guided-overlay" class="hidden">
    <div class="overlay-header">
      <div class="flex items-center gap-3">
        <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs font-bold">æ­¥éª¤ <span id="step-count">1/8</span></span>
        <h3 id="step-title" class="font-bold text-slate-800 text-base">å‡†å¤‡å¼€å§‹</h3>
      </div>
      <div class="flex gap-2">
        <button onclick="prevStep()" id="btn-prev" class="btn text-xs px-3 py-1" disabled>ä¸Šä¸€æ­¥</button>
        <button onclick="nextStep()" id="btn-next" class="btn btn-primary text-xs px-3 py-1">ä¸‹ä¸€æ­¥</button>
      </div>
    </div>
    <div class="overlay-body">
      <div id="step-reasoning" class="mb-4"></div>
      <div id="step-math" class="tex-container bg-blue-50 p-3 rounded border border-blue-100 text-slate-700 text-center"></div>
    </div>
  </div>

  <!-- çŠ¶æ€æ  -->
  <div class="status-bar">
    <div id="status-msg">å‡†å¤‡å°±ç»ª</div>
    <div class="flex-1"></div>
    <div class="flex gap-4">
      <span title="æ»šè½®ç¼©æ”¾ï¼Œå³é”®å¹³ç§»">ğŸ–±ï¸ è§†å›¾æ“ä½œï¼šå¹³ç§»/ç¼©æ”¾</span>
    </div>
  </div>

<script>
/**
 * MathPhysics Engine v3.1.5
 * Core: p5.js (Logic-First) + MathJax
 */

// ==========================================
// 1. STATE & CONSTANTS
// ==========================================
const STATE = {
  mode: 'guided', // 'guided' | 'sandbox'
  sceneIndex: 0,  // 0:Temp, 1:Dance, 2:Shop, 3:Memory
  sliderVal: 0,   // 0.0 to 100.0 (abstract progress)
  isPlaying: false,
  stepIndex: 0,
  view: { scale: 1.0, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 },
  misconceptionActive: false,
  problem: {
    statementCN: "åæ ‡çš„æœ¬è´¨ï¼šå°†ä¸¤ä¸ªç›¸å…³çš„é‡ï¼ˆå¦‚æ—¶é—´ä¸æ¸©åº¦ã€æ•°é‡ä¸ä»·æ ¼ï¼‰æ˜ å°„ä¸ºå¹³é¢ä¸Šçš„ç‚¹ï¼Œä»è€Œæ­ç¤ºå˜é‡é—´çš„å‡½æ•°å…³ç³»ã€‚",
    statementTeX: String.raw`P(x, y) \leftrightarrow (Independent, Dependent)`
  }
};

// åœºæ™¯é…ç½®å®šä¹‰
const SCENES = [
  {
    id: 'temp',
    name: 'æ—¶é—´ä¸æ¸©åº¦',
    xLabel: 'æ—¶é—´ (å°æ—¶)',
    yLabel: 'æ¸©åº¦ (Â°C)',
    xRange: [0, 24],
    yRange: [0, 40],
    color: '#ef4444', // Red
    icon: 'ğŸŒ¡ï¸',
    // æ¨¡æ‹Ÿä¸€å¤©æ°”æ¸©ï¼šå‡Œæ™¨ä½ï¼Œåˆåé«˜ï¼Œæ·±å¤œé™
    func: (x) => {
      // x in 0..24
      // Base 20, amplitude 10, peak at 14:00
      let t = (x - 14) / 24 * Math.PI * 2;
      return 20 + 10 * Math.cos(t) - 5 * Math.cos(2*t); // ç¨å¾®å¤æ‚ä¸€ç‚¹çš„æ›²çº¿
    },
    xToSlider: (x) => (x / 24) * 100,
    sliderToX: (s) => (s / 100) * 24,
    desc: "Xè½´ä»£è¡¨æ—¶é—´æµé€ï¼ŒYè½´ä»£è¡¨æ¸©åº¦é«˜ä½ã€‚è¿™æ˜¯ä¸€æ¡è¿ç»­çš„æ›²çº¿ã€‚"
  },
  {
    id: 'dance',
    name: 'è·³èˆé«˜åº¦',
    xLabel: 'æ—¶é—´ (ç§’)',
    yLabel: 'é«˜åº¦ (cm)',
    xRange: [0, 10],
    yRange: [0, 150],
    color: '#8b5cf6', // Purple
    icon: 'ğŸ’ƒ',
    // æ¨¡æ‹Ÿè·³è·ƒï¼šä¸€ç³»åˆ—æŠ›ç‰©çº¿
    func: (x) => {
      // x in 0..10
      let cycle = x % 2; // 2ç§’ä¸€è·³
      if (cycle < 1) { // è·³è·ƒé˜¶æ®µ
        // 0..1 -> parabola 0..100..0
        let t = cycle - 0.5;
        return 120 * (0.25 - t*t) * 4; 
      }
      return 0; // ç«™ç«‹é˜¶æ®µ
    },
    xToSlider: (x) => (x / 10) * 100,
    sliderToX: (s) => (s / 100) * 10,
    desc: "è®°å½•è¿™ä¸€åˆ»ç¦»åœ°å¤šé«˜ã€‚æ›²çº¿çš„èµ·ä¼å°±æ˜¯ä½ è·³è·ƒçš„è½¨è¿¹ã€‚"
  },
  {
    id: 'shop',
    name: 'è‹¹æœä»·æ ¼',
    xLabel: 'æ•°é‡ (ä¸ª)',
    yLabel: 'æ€»ä»· (å…ƒ)',
    xRange: [0, 20],
    yRange: [0, 100],
    color: '#f97316', // Orange
    icon: 'ğŸ',
    discrete: true, // ç¦»æ•£ç‚¹
    // çº¿æ€§å…³ç³»ï¼šå•ä»· 4å…ƒ
    func: (x) => 4 * Math.round(x), 
    xToSlider: (x) => (x / 20) * 100,
    sliderToX: (s) => (s / 100) * 20,
    desc: "è¿™é‡Œæ²¡æœ‰æ—¶é—´æµé€ã€‚Xè½´æ˜¯ä¹°äº†å‡ ä¸ªï¼ŒYè½´æ˜¯è¦ä»˜å¤šå°‘é’±ã€‚è¿™æ˜¯ä¸€ç»„ç¦»æ•£çš„ç‚¹ã€‚"
  },
  {
    id: 'memory',
    name: 'é—å¿˜æ›²çº¿',
    xLabel: 'å­¦ä¹ åå¤©æ•° (å¤©)',
    yLabel: 'è®°å¿†ç•™å­˜ç‡ (%)',
    xRange: [0, 7],
    yRange: [0, 100],
    color: '#3b82f6', // Blue
    icon: 'ğŸ§ ',
    // è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿è¿‘ä¼¼
    func: (x) => {
      // y = 100 * (1 / (1+x)^0.6) ç±»ä¼¼è¡°å‡
      // 0å¤©=100%, 1å¤©=50%, 7å¤©=20%
      return 100 / (1 + x * 0.8);
    },
    xToSlider: (x) => (x / 7) * 100,
    sliderToX: (s) => (s / 100) * 7,
    desc: "æŠ½è±¡å…³ç³»ï¼šè®°å¿†ä¼šéšæ—¶é—´â€œæºœèµ°â€ã€‚æ›²çº¿ä¸‹é™å¾—å¾ˆå¿«ï¼Œæ‰€ä»¥è¦åŠæ—¶å¤ä¹ ï¼"
  }
];

// å¼•å¯¼æ­¥éª¤ (Logic-First Teaching)
const PLAN_STEPS = [
  {
    titleCN: "åªæœ‰ä¸€ä¸ªæ•°çš„æ—¶å€™",
    reasoningCN: "åœ¨æ²¡æœ‰åæ ‡ç³»ä¹‹å‰ï¼Œæˆ‘ä»¬åªæœ‰ä¸€æ ¹â€œå°ºå­â€ï¼ˆæ•°è½´ï¼‰ã€‚æ¯”å¦‚ï¼Œåªçœ‹<b>æ¸©åº¦è®¡</b>ï¼Œæˆ‘ä»¬åªèƒ½çŸ¥é“â€œç°åœ¨çš„æ¸©åº¦â€æ˜¯å¤šå°‘ï¼Œä½†ä¸çŸ¥é“è¿‡å»å‘ç”Ÿäº†ä»€ä¹ˆã€‚",
    formulasTeX: [String.raw`T = 20^{\circ}\text{C}`],
    sceneIdx: 0,
    focus: 'y-axis-only',
    checkItem: "è§‚å¯Ÿå·¦è¾¹æ¸©åº¦è®¡çš„å˜åŒ–"
  },
  {
    titleCN: "å¼•å…¥è®°å½•å‘˜ï¼šæ—¶é—´è½´",
    reasoningCN: "ä¸ºäº†è®°å½•â€œæ¸©åº¦éšæ—¶é—´çš„å˜åŒ–â€ï¼Œæˆ‘ä»¬éœ€è¦ç¬¬äºŒæŠŠå°ºå­â€”â€”<b>æ—¶é—´è½´ï¼ˆXè½´ï¼‰</b>ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæ¯è¿‡ä¸€å°æ—¶ï¼Œæˆ‘ä»¬å°±åœ¨çº¸ä¸Šç‚¹ä¸€ä¸ªç‚¹ã€‚",
    formulasTeX: [String.raw`\text{Point} = (t, T)`],
    sceneIdx: 0,
    focus: 'axes-intro',
    checkItem: "ç†è§£æ¨ªè½´ä»£è¡¨æ—¶é—´çš„æµé€"
  },
  {
    titleCN: "ç‚¹åŠ¨æˆçº¿",
    reasoningCN: "å½“æˆ‘ä»¬æŠŠæ¯ä¸€åˆ»çš„ç‚¹éƒ½ç”»å‡ºæ¥ï¼Œæ— æ•°ä¸ªç‚¹å°±è¿æˆäº†ä¸€æ¡<b>æ›²çº¿</b>ã€‚è¿™æ¡çº¿å°±æ˜¯è¿™ä¸€æ•´å¤©çš„â€œæ¸©åº¦æ•…äº‹â€ã€‚",
    formulasTeX: [String.raw`T = f(t)`],
    sceneIdx: 0,
    focus: 'trace-curve',
    checkItem: "æ‹–åŠ¨æ»‘å—ï¼Œçœ‹æ›²çº¿å¦‚ä½•ç”Ÿæˆ"
  },
  {
    titleCN: "å¦ä¸€åœºæ•…äº‹ï¼šè·³èˆ",
    reasoningCN: "åæ ‡ä¸åªå¯ä»¥è®°æ¸©åº¦ï¼Œè¿˜å¯ä»¥è®°åŠ¨ä½œã€‚è¿™é‡ŒXè½´è¿˜æ˜¯æ—¶é—´ï¼Œä½†Yè½´å˜æˆäº†<b>é«˜åº¦</b>ã€‚è¯•ç€è·³ä¸€è·³ï¼",
    formulasTeX: [String.raw`h = f(t)`],
    sceneIdx: 1,
    focus: 'motion-trace',
    checkItem: "è§‚å¯Ÿæ³¢æµªçº¿ä»£è¡¨è·³èµ·å’Œè½ä¸‹"
  },
  {
    titleCN: "å¦‚æœæ²¡æœ‰æ—¶é—´å‘¢ï¼Ÿ",
    reasoningCN: "åæ ‡ç³»å¿…é¡»è¦æœ‰æ—¶é—´å—ï¼Ÿ<b>ä¸ä¸€å®šï¼</b>çœ‹çœ‹è¿™ä¸ªè‹¹æœæ‘Šã€‚Xè½´æ˜¯è‹¹æœæ•°é‡ï¼ŒYè½´æ˜¯æ€»ä»·ã€‚è¿™é‡Œæ²¡æœ‰æ—¶é—´æµé€ï¼Œåªæœ‰â€œæ•°é‡â€å’Œâ€œä»·æ ¼â€çš„å¯¹åº”å…³ç³»ã€‚",
    formulasTeX: [String.raw`y = k \cdot x`],
    sceneIdx: 2,
    focus: 'discrete-points',
    checkItem: "æ³¨æ„è¿™é‡Œæ˜¯åˆ†å¼€çš„ç‚¹ï¼Œä¸æ˜¯è¿çº¿"
  },
  {
    titleCN: "çœ‹ä¸è§çš„â€œé—å¿˜â€",
    reasoningCN: "æœ‰äº›ä¸œè¥¿çœ‹ä¸è§ï¼Œä¹Ÿèƒ½ç”¨åæ ‡ç”»å‡ºæ¥ã€‚æ¯”å¦‚<b>è®°å¿†</b>ã€‚Xè½´æ˜¯â€œå­¦å®Œåè¿‡äº†å‡ å¤©â€ï¼ŒYè½´æ˜¯â€œè¿˜è®°å¾—å¤šå°‘â€ã€‚ä½ ä¼šå‘ç°æ›²çº¿ä¸€å¼€å§‹æ‰å¾—ç‰¹åˆ«å¿«ï¼ˆä»100%æ‰åˆ°40%ï¼‰ï¼Œæ‰€ä»¥åˆšå­¦å®Œæ—¶å¤ä¹ æœ€é‡è¦ï¼",
    formulasTeX: [String.raw`R = \frac{100}{1+kt}`],
    sceneIdx: 3,
    focus: 'abstract-curve',
    checkItem: "è§‚å¯Ÿè®°å¿†æ˜¯å¦‚ä½•éšæ—¶é—´æµå¤±çš„"
  },
  {
    titleCN: "å¸¸è§è¯¯åŒºï¼šæ˜¯è·¯ç¨‹å—ï¼Ÿ",
    reasoningCN: "å¾ˆå¤šåŒå­¦çœ‹åˆ°æ³¢æµªçº¿ï¼Œä»¥ä¸ºæ˜¯å°äºº<b>èµ°è¿‡çš„è·¯ï¼ˆåœ°å½¢å›¾ï¼‰</b>ã€‚è¿™æ˜¯ä¸å¯¹çš„ï¼åœ¨è·³èˆçš„ä¾‹å­é‡Œï¼Œå°äººåªåœ¨åŸåœ°ä¸Šä¸‹è·³ï¼Œæ³¢æµªçº¿æ˜¯å› ä¸ºæ—¶é—´ï¼ˆXè½´ï¼‰åœ¨ä¸æ–­å‘å³èµ°ã€‚",
    formulasTeX: [String.raw`\text{Graph} \neq \text{Map}`],
    sceneIdx: 1,
    focus: 'misconception',
    checkItem: "å¼€å¯â€œé”™è¯¯å¯¹æ¯”â€çœ‹çœ‹åŒºåˆ«"
  },
  {
    titleCN: "æ€»ç»“ï¼šåæ ‡çš„æœ¬è´¨",
    reasoningCN: "æ— è®ºXå’ŒYæ˜¯ä»€ä¹ˆï¼Œåæ ‡ç³»çš„æ ¸å¿ƒå°±æ˜¯ï¼š<b>ç”¨å¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹ï¼ŒåŒæ—¶é”å®šäº†ä¸¤ä¸ªä¿¡æ¯</b>ã€‚å®ƒè®©æˆ‘ä»¬ä¸€çœ¼å°±èƒ½çœ‹æ¸…ä¸¤ä¸ªå˜é‡ä¹‹é—´æ˜¯æ€ä¹ˆäº’ç›¸å½±å“çš„ã€‚",
    formulasTeX: [String.raw`(x, y) \rightarrow \text{Relation}`],
    sceneIdx: 0,
    focus: 'summary',
    checkItem: "è‡ªç”±æ¢ç´¢ä¸åŒåœºæ™¯"
  }
];

// ==========================================
// 2. VIEW TRANSFORM HELPER
// ==========================================
class ViewTransform {
  static toWorld(screenX, screenY, width, height) {
    return { x: screenX, y: screenY }; 
  }
}

// ==========================================
// 3. P5.JS ENGINE
// ==========================================
let canvas;

function setup() {
  const container = document.getElementById('canvas-container');
  canvas = createCanvas(container.offsetWidth, container.offsetHeight);
  canvas.parent('canvas-container');
  
  // ç»‘å®šäº‹ä»¶åˆ° Canvas å…ƒç´ 
  canvas.elt.addEventListener('wheel', handleWheel, { passive: false });
  canvas.elt.addEventListener('pointerdown', handlePointerDown);
  canvas.elt.addEventListener('pointermove', handlePointerMove);
  canvas.elt.addEventListener('pointerup', handlePointerUp);
  
  textFont("Noto Sans SC");
  updateOverlay();
}

function windowResized() {
  const container = document.getElementById('canvas-container');
  resizeCanvas(container.offsetWidth, container.offsetHeight);
}

function draw() {
  background(241, 245, 249); // slate-100
  
  const scene = SCENES[STATE.sceneIndex];
  
  // Layout parameters
  // UPDATED: Increased margin for better spacing
  const margin = 80;
  const w = width;
  const h = height;
  
  // Split Screen Layout
  // Left: Reality (30%), Right: Graph (70%)
  const splitX = w * 0.35;
  
  // 1. Draw Reality (Left Side)
  drawRealityPane(0, 0, splitX, h, scene);
  
  // 2. Draw Graph (Right Side)
  // Map xRange -> [splitX + margin, w - margin]
  // Map yRange -> [h - margin, margin]
  const graphRect = {
    x: splitX + margin,
    y: margin,
    w: w - splitX - margin * 2,
    h: h - margin * 2
  };
  
  drawGraphPane(graphRect, scene);
  
  // Animation loop logic
  if (STATE.isPlaying) {
    STATE.sliderVal += 0.5; // Speed
    if (STATE.sliderVal > 100) {
      STATE.sliderVal = 0;
    }
    // Update slider UI
    document.getElementById('main-slider').value = STATE.sliderVal;
    updateStatus();
  }
}

// --- Drawing Helpers ---

function drawRealityPane(x, y, w, h, scene) {
  push();
  translate(x, y);
  
  // Background
  fill(255);
  noStroke();
  rect(10, 10, w - 20, h - 20, 12);
  
  // Title
  fill(50);
  textSize(16);
  textAlign(CENTER, TOP);
  text("ç°å®ä¸–ç•Œ / å®éªŒå°", w/2, 25);
  
  // Dynamic Value
  let currentX = scene.sliderToX(STATE.sliderVal);
  let currentY = scene.func(currentX);
  
  // Scene Specific Visuals
  translate(w/2, h/2); // Center of reality pane
  
  if (scene.id === 'temp') {
    // Thermometer & Sun/Moon
    drawThermometer(currentY, scene.yRange);
    drawTimeIcon(currentX); // Sun/Moon based on hour
  } else if (scene.id === 'dance') {
    // Dancer
    drawDancer(currentY);
  } else if (scene.id === 'shop') {
    // Apple Basket
    drawBasket(currentX, currentY);
  } else if (scene.id === 'memory') {
    // Brain
    drawBrain(currentX, currentY);
  }
  
  pop();
}

function drawGraphPane(rect, scene) {
  const {x, y, w, h} = rect;
  
  push();
  translate(x, y);
  
  // 1. Grid & Axes
  drawAxes(w, h, scene);
  
  // 2. Curve / Points
  noFill();
  stroke(scene.color);
  strokeWeight(3);
  
  let currentXVal = scene.sliderToX(STATE.sliderVal);
  
  if (scene.discrete) {
    // Discrete dots
    for (let i = scene.xRange[0]; i <= scene.xRange[1]; i++) {
      let px = map(i, scene.xRange[0], scene.xRange[1], 0, w);
      let py = map(scene.func(i), scene.yRange[0], scene.yRange[1], h, 0);
      
      if (i <= currentXVal) {
        fill(scene.color);
        noStroke();
        circle(px, py, 8);
        
        // Connect to axis if it's the current one
        if (Math.abs(i - Math.round(currentXVal)) < 0.1) {
          drawGuideLines(px, py, w, h, scene.color);
        }
      } else {
        // Ghost future points
        fill(200);
        noStroke();
        circle(px, py, 4);
      }
    }
  } else {
    // Continuous Curve
    beginShape();
    let step = (scene.xRange[1] - scene.xRange[0]) / 100;
    for (let val = scene.xRange[0]; val <= currentXVal; val += step) {
      let px = map(val, scene.xRange[0], scene.xRange[1], 0, w);
      let py = map(scene.func(val), scene.yRange[0], scene.yRange[1], h, 0);
      vertex(px, py);
    }
    // Ensure the very tip is accurate
    let tipX = map(currentXVal, scene.xRange[0], scene.xRange[1], 0, w);
    let tipY = map(scene.func(currentXVal), scene.yRange[0], scene.yRange[1], h, 0);
    vertex(tipX, tipY);
    endShape();
    
    // Draw Current Point
    fill(scene.color);
    noStroke();
    circle(tipX, tipY, 10);
    drawGuideLines(tipX, tipY, w, h, scene.color);
    
    // Misconception: "Path" (Ghost of the dancer moving right)
    if (STATE.misconceptionActive && scene.id === 'dance') {
      stroke(150);
      strokeWeight(1);
      drawingContext.setLineDash([5, 5]);
      line(0, tipY, w, tipY); // Pure horizontal level
      noStroke();
      fill(100);
      textSize(12);
      text("è¯¯åŒºï¼šå°äººæ²¡æœ‰å¾€å³è·‘ï¼å¾€å³è·‘çš„æ˜¯æ—¶é—´ã€‚", tipX + 10, tipY - 10);
      drawingContext.setLineDash([]);
    }
  }

  // Label Current Coordinate
  let valY = scene.func(currentXVal);
  fill(50);
  noStroke();
  textSize(14);
  textAlign(LEFT, BOTTOM);
  text(`(${currentXVal.toFixed(1)}, ${valY.toFixed(1)})`, 10, -10);
  
  pop();
}

function drawAxes(w, h, scene) {
  stroke(203, 213, 225); // slate-300
  strokeWeight(1);
  fill(100, 116, 139); // slate-500
  textSize(10);
  
  // Grid & Labels
  // X Grid
  let xSteps = 6;
  for(let i=0; i<=xSteps; i++) {
    let x = map(i, 0, xSteps, 0, w);
    line(x, 0, x, h);
    
    // X Axis Numeric Labels
    noStroke();
    textAlign(CENTER, TOP);
    let val = map(i, 0, xSteps, scene.xRange[0], scene.xRange[1]);
    text(Math.round(val), x, h + 5);
    stroke(203, 213, 225);
  }
  
  // Y Grid
  let ySteps = 5;
  for(let i=0; i<=ySteps; i++) {
    let y = map(i, 0, ySteps, h, 0);
    line(0, y, w, y);
    
    // Y Axis Numeric Labels
    noStroke();
    textAlign(RIGHT, CENTER);
    let val = map(i, 0, ySteps, scene.yRange[0], scene.yRange[1]);
    text(Math.round(val), -5, y);
    stroke(203, 213, 225);
  }
  
  // Main Axes
  stroke(51, 65, 85); // slate-700
  strokeWeight(2);
  line(0, h, w, h); // X Axis
  line(0, 0, 0, h); // Y Axis
  
  // Axis Names Labels
  fill(71, 85, 105);
  noStroke();
  textSize(12);
  
  // X Label Name
  textAlign(RIGHT, TOP);
  text(scene.xLabel, w, h + 20);
  
  // Y Label Name
  textAlign(LEFT, BOTTOM);
  push();
  translate(-30, 0); // Move left a bit more to avoid overlap with numbers
  rotate(-HALF_PI);
  text(scene.yLabel, 0, 0);
  pop();
}

function drawGuideLines(x, y, w, h, col) {
  stroke(col);
  strokeWeight(1);
  drawingContext.setLineDash([4, 4]);
  line(x, h, x, y); // Vertical to X
  line(0, y, x, y); // Horizontal to Y
  drawingContext.setLineDash([]);
  
  // Axis ticks highlights
  fill(col);
  noStroke();
  // On X axis
  triangle(x, h, x-3, h+5, x+3, h+5);
  // On Y axis
  triangle(0, y, -5, y-3, -5, y+3);
}

// --- Specific Scene Drawers ---

function drawThermometer(temp, range) {
  // Simple Thermometer
  let h = 150;
  let w = 20;
  let fillH = map(temp, range[0], range[1], 0, h);
  
  fill(220);
  rect(-w/2, -h/2, w, h, 10);
  fill(239, 68, 68);
  rect(-w/2 + 2, h/2 - fillH, w - 4, fillH, 8);
  
  fill(50);
  textAlign(CENTER);
  text(`${temp.toFixed(1)}Â°C`, 0, h/2 + 20);
}

function drawTimeIcon(hour) {
  let isNight = hour < 6 || hour > 18;
  textSize(40);
  textAlign(CENTER, CENTER);
  text(isNight ? 'ğŸŒ™' : 'â˜€ï¸', 0, -100);
  textSize(16);
  text(`${Math.floor(hour)}:00`, 0, -130);
}

function drawDancer(heightVal) {
  // Ground
  stroke(100);
  line(-50, 80, 50, 80);
  
  // Dancer
  let yPos = 80 - heightVal; 
  
  textSize(60);
  textAlign(CENTER, BOTTOM);
  text('ğŸ’ƒ', 0, yPos);
  
  // Shadow
  if (heightVal > 0) {
    noStroke();
    fill(0, 0, 0, 50 - heightVal/3);
    ellipse(0, 80, 40 - heightVal/5, 10);
  }
}

function drawBasket(count, price) {
  textSize(60);
  textAlign(CENTER, CENTER);
  text('ğŸ§º', 0, 20);
  
  // Draw apples inside?
  let num = Math.round(count);
  textSize(20);
  for(let i=0; i<num; i++) {
    // pile them up
    let row = Math.floor(i/4);
    let col = i % 4;
    text('ğŸ', (col-1.5)*15, 20 - row*15);
  }
  
  fill(50);
  textSize(16);
  text(`${num} ä¸ª`, 0, 60);
  fill(234, 88, 12);
  text(`æ€»ä»·: Â¥${price}`, 0, 80);
}

function drawBrain(days, retention) {
  textSize(80);
  textAlign(CENTER, CENTER);
  
  // Brain Emoji state based on retention
  let emoji = 'ğŸ§ '; 
  // Fading effect visual
  let alphaVal = map(retention, 0, 100, 50, 255);
  
  fill(0, 0, 0, alphaVal);
  text(emoji, 0, 0);
  
  // Overlay "fading" if retention is low
  if (retention < 50) {
     textSize(30);
     text('â“', 30, -30);
  }
  
  textSize(14);
  fill(50);
  text(`è¿‡äº†: ${days.toFixed(1)} å¤©`, 0, 60);
  
  // Color code retention
  if (retention > 80) fill(22, 163, 74); // Green
  else if (retention > 40) fill(234, 179, 8); // Yellow
  else fill(220, 38, 38); // Red
  
  text(`è¿˜è®°å¾—: ${retention.toFixed(1)}%`, 0, 80);
}

// ==========================================
// 4. INTERACTION & DOM
// ==========================================

function updateStatus() {
  const scene = SCENES[STATE.sceneIndex];
  const x = scene.sliderToX(STATE.sliderVal);
  const y = scene.func(x);
  
  document.getElementById('var-val-display').innerText = `X = ${x.toFixed(1)}`;
  
  // Update verification badge
  const badge = document.getElementById('verify-badge');
  if (scene.discrete && Math.abs(x - Math.round(x)) > 0.1) {
    badge.innerText = "éæ•´æ•°ç‚¹";
    badge.className = "px-2 py-0.5 rounded-full text-xs font-bold bg-yellow-100 text-yellow-700";
  } else {
    badge.innerText = "æ•°æ®æœ‰æ•ˆ";
    badge.className = "px-2 py-0.5 rounded-full text-xs font-bold bg-green-100 text-green-700";
  }
}

// Slider Input
document.getElementById('main-slider').addEventListener('input', (e) => {
  STATE.sliderVal = parseFloat(e.target.value);
  STATE.isPlaying = false; // Stop auto-play on manual interact
  updateStatus();
});

// Scene Switching
function switchScene(idx) {
  STATE.sceneIndex = idx;
  STATE.sliderVal = 0;
  STATE.isPlaying = false;
  STATE.misconceptionActive = false;
  document.getElementById('main-slider').value = 0;
  document.getElementById('error-toggle').checked = false;
  
  // Update Tab UI
  document.querySelectorAll('.scene-tab').forEach((el, i) => {
    if(i === idx) el.classList.add('active');
    else el.classList.remove('active');
  });
  
  // Update misconception toggle visibility
  const box = document.getElementById('misconception-box');
  if (SCENES[idx].id === 'dance') {
    box.classList.remove('hidden');
  } else {
    box.classList.add('hidden');
  }

  // Update Description
  document.getElementById('observation-text').innerText = SCENES[idx].desc;
  
  updateStatus();
}

// Mode Switching
function setMode(mode) {
  STATE.mode = mode;
  document.getElementById('tab-guided').className = mode === 'guided' ? 
    "w-1/2 p-3 text-center cursor-pointer font-bold border-b-2 border-blue-500 text-blue-600 bg-blue-50" :
    "w-1/2 p-3 text-center cursor-pointer font-bold text-gray-500 hover:bg-gray-50";
  document.getElementById('tab-sandbox').className = mode === 'sandbox' ? 
    "w-1/2 p-3 text-center cursor-pointer font-bold border-b-2 border-blue-500 text-blue-600 bg-blue-50" :
    "w-1/2 p-3 text-center cursor-pointer font-bold text-gray-500 hover:bg-gray-50";

  if (mode === 'guided') {
    document.getElementById('guided-overlay').classList.remove('hidden');
    document.getElementById('sandbox-controls').classList.add('hidden');
    STATE.stepIndex = 0;
    loadStep(0);
  } else {
    document.getElementById('guided-overlay').classList.add('hidden');
    document.getElementById('sandbox-controls').classList.remove('hidden');
    switchScene(STATE.sceneIndex); // Refresh
  }
}

// Guided Step Logic
function loadStep(idx) {
  if (idx < 0 || idx >= PLAN_STEPS.length) return;
  STATE.stepIndex = idx;
  const step = PLAN_STEPS[idx];
  
  // Set UI
  document.getElementById('step-count').innerText = `${idx + 1}/${PLAN_STEPS.length}`;
  document.getElementById('step-title').innerText = step.titleCN;
  document.getElementById('step-reasoning').innerHTML = step.reasoningCN;
  
  // MathJax
  const mathEl = document.getElementById('step-math');
  mathEl.style.visibility = 'hidden';
  mathEl.innerText = `\\[ ${step.formulasTeX.join(' \\] \\[ ')} \\]`;
  MathJax.typesetPromise([mathEl]).then(() => {
    mathEl.style.visibility = 'visible';
  });

  // Buttons
  document.getElementById('btn-prev').disabled = idx === 0;
  document.getElementById('btn-next').innerText = idx === PLAN_STEPS.length - 1 ? "å®Œæˆ" : "ä¸‹ä¸€æ­¥";
  
  // Execute Step State
  if (step.sceneIdx !== undefined) {
    switchScene(step.sceneIdx); // Auto switch scene
  }
  
  // Step specific interactions
  if (step.focus === 'trace-curve') {
    STATE.isPlaying = true;
  } else {
    STATE.isPlaying = false;
  }
  
  if (step.focus === 'misconception') {
    STATE.misconceptionActive = true;
    document.getElementById('misconception-box').classList.remove('hidden');
    document.getElementById('error-toggle').checked = true;
  } else {
    STATE.misconceptionActive = false;
    document.getElementById('error-toggle').checked = false;
  }
}

function nextStep() {
  if (STATE.stepIndex < PLAN_STEPS.length - 1) loadStep(STATE.stepIndex + 1);
}
function prevStep() {
  if (STATE.stepIndex > 0) loadStep(STATE.stepIndex - 1);
}

// Playback
function togglePlay() {
  STATE.isPlaying = !STATE.isPlaying;
  document.getElementById('play-btn').innerHTML = STATE.isPlaying ? "<span>||</span> æš‚åœ" : "<span>â–¶</span> è‡ªåŠ¨æ¼”ç¤º";
}

function resetSim() {
  STATE.sliderVal = 0;
  STATE.isPlaying = false;
  document.getElementById('main-slider').value = 0;
  document.getElementById('play-btn').innerHTML = "<span>â–¶</span> è‡ªåŠ¨æ¼”ç¤º";
  updateStatus();
}

function updateOverlay() {
  // Can be used to sync overlay position if needed, currently CSS handled
}

function updateState() {
  STATE.misconceptionActive = document.getElementById('error-toggle').checked;
}

function copyProblem() {
  const text = document.getElementById('problem-text').innerText;
  navigator.clipboard.writeText(text).then(() => {
    alert("æ¦‚å¿µå®šä¹‰å·²å¤åˆ¶ï¼");
  });
}

function handleWheel(e) { e.preventDefault(); }
function handlePointerDown(e) {}
function handlePointerMove(e) {}
function handlePointerUp(e) {}

// Init
setMode('guided');

</script>
</body>
</html>