<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¹³é¢é•œæˆåƒé€šç”¨æ¢ç©¶å®éªŒå®¤</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header-area {
            width: 100%;
            background-color: #fff;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
        }

        .header-area h1 { margin: 0; font-size: 20px; color: #2c3e50; }
        .header-area p { margin: 5px 0 0; font-size: 13px; color: #7f8c8d; }

        .main-wrapper {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 95%;
            max-width: 1400px;
            padding-bottom: 40px;
        }

        .canvas-card {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 0;
            flex: 1 1 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
            overflow: hidden;
            position: relative;
        }

        .controls-card {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: fit-content;
        }

        .section-title {
            font-size: 15px;
            font-weight: 700;
            color: #34495e;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }

        .control-row { margin-bottom: 15px; }
        .control-row label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #555;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #dfe6e9;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #0984e3;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.15s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { background: #74b9ff; }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            font-size: 13px;
            user-select: none;
        }
        .toggle-row input { accent-color: #0984e3; }

        .btn-reset {
            background-color: #ff7675;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: 0.2s;
        }
        .btn-reset:hover { background-color: #d63031; }

        .hint-card {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.4;
        }

        .overlay-instruction {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255,255,255,0.85);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            color: #636e72;
            border: 1px solid #b2bec3;
        }
    </style>
</head>
<body>

    <div class="header-area">
        <h1>å¹³é¢é•œæˆåƒé€šç”¨æ¢ç©¶å®éªŒå®¤</h1>
        <p>ç‰©ç†ä»¿çœŸå¼•æ“ï¼šè¿˜åŸå€¾æ–œé•œé¢çš„æˆåƒè§„å¾‹</p>
    </div>

    <div class="main-wrapper">
        <div class="controls-card">
            
            <div class="control-section">
                <div class="section-title">ğŸ› ï¸ å®éªŒè®¾ç½®</div>
                
                <div class="control-row">
                    <label>é•œé¢å€¾æ–œè§’åº¦ <span id="val-angle" style="color:#0984e3; font-weight:bold;">45Â°</span></label>
                    <input type="range" id="slider-angle" min="30" max="150" value="45" step="1">
                    <div style="font-size:11px; color:#999; margin-top:4px;">(45Â°æ—¶åƒå‘ˆæ°´å¹³ï¼Œ90Â°æ—¶åƒå‘ˆç«–ç›´)</div>
                </div>

                <div class="control-row">
                    <label>èœ¡çƒ›ä½ç½® <span id="val-pos" style="color:#0984e3; font-weight:bold;">200</span></label>
                    <input type="range" id="slider-pos" min="50" max="350" value="200" step="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">ğŸ‘€ è§†è§‰è¾…åŠ©</div>
                <label class="toggle-row">
                    <input type="checkbox" id="chk-image" checked>
                    æ˜¾ç¤ºè™šåƒ (A'B') - è™šçº¿
                </label>
                <label class="toggle-row">
                    <input type="checkbox" id="chk-symmetry" checked>
                    æ˜¾ç¤ºå¯¹ç§°è¿çº¿ - å‚ç›´å¹³åˆ†
                </label>
                <label class="toggle-row">
                    <input type="checkbox" id="chk-ray" checked>
                    æ˜¾ç¤ºæˆåƒå…‰è·¯ (çœ¼ç›è§†è§’)
                </label>
                <label class="toggle-row">
                    <input type="checkbox" id="chk-normal" checked>
                    æ˜¾ç¤ºæ³•çº¿ (è¾…åŠ©çº¿)
                </label>
            </div>

            <div class="hint-card">
                <strong>ç°è±¡è§‚å¯Ÿï¼š</strong><br>
                1. ä¿æŒ45Â°è§’ï¼ŒåƒA'B'æ˜¯æ°´å¹³çš„ï¼ˆå€’åœ¨åœ°ä¸‹ï¼‰ã€‚<br>
                2. æ‹–åŠ¨èœ¡çƒ›ï¼Œåƒå§‹ç»ˆå…³äºé•œé¢å¯¹ç§°ç§»åŠ¨ã€‚<br>
                3. â€œåƒâ€åœ¨é•œå­èƒŒé¢ï¼ˆåœ°ä¸‹ï¼‰ï¼Œæ˜¯è™šåƒã€‚
            </div>

            <button class="btn-reset" onclick="resetSim()">é‡ç½®åˆ°é¢˜ç›®çŠ¶æ€ (45Â°)</button>
        </div>

        <div class="canvas-card" id="canvas-container">
            <div class="overlay-instruction">ğŸ’¡ æç¤ºï¼šé¼ æ ‡å¯æ‹–æ‹½ ğŸ•¯ï¸èœ¡çƒ› æˆ– ğŸ‘ï¸çœ¼ç›</div>
            <!-- P5 Canvas Here -->
        </div>
    </div>

    <script>
        // --- å˜é‡å£°æ˜ ---
        let angleSlider, posSlider;
        let chkImage, chkSymmetry, chkRay, chkNormal;
        let valAngleSpan, valPosSpan;

        // ç”»å¸ƒå°ºå¯¸ä¸ç‰©ç†å¸¸é‡
        const CW = 800;
        const CH = 600;
        // å…³é”®è°ƒæ•´ï¼šæŠŠæ¡Œé¢çº¿ä¸Šç§»åˆ° 300 (åŸ450)ï¼Œç•™å‡ºä¸‹æ–¹ 300px ç»™â€œåœ°ä¸‹â€æˆåƒ
        const TABLE_Y = 300; 

        // çŠ¶æ€å¯¹è±¡
        let mirror = {
            pivotX: 450,    // é•œå­åº•ç«¯æ¥è§¦æ¡Œé¢çš„ç‚¹
            pivotY: TABLE_Y, 
            length: 350,    // é•œå­åŠ é•¿ï¼Œé˜²æ­¢å…‰çº¿æ‰“ä¸ä¸­
            angle: 45       // è§’åº¦
        };

        let candle = {
            x: 250,         // é»˜è®¤æ”¾åœ¨å·¦ä¾§
            y: TABLE_Y,     // æ”¾åœ¨æ¡Œé¢ä¸Š
            h: 90,          // èœ¡çƒ›é«˜åº¦
            w: 24,
            isDragging: false
        };

        let eye = {
            x: 650,
            y: 150,
            isDragging: false
        };

        // --- P5.js ç”Ÿå‘½å‘¨æœŸ ---

        function setup() {
            let cnv = createCanvas(CW, CH);
            cnv.parent('canvas-container');
            
            // ç»‘å®š DOM å…ƒç´ 
            angleSlider = select('#slider-angle');
            posSlider = select('#slider-pos');
            valAngleSpan = select('#val-angle');
            valPosSpan = select('#val-pos');
            
            chkImage = select('#chk-image');
            chkSymmetry = select('#chk-symmetry');
            chkRay = select('#chk-ray');
            chkNormal = select('#chk-normal');

            // ç›‘å¬å™¨
            angleSlider.input(updateParams);
            posSlider.input(updateParams);
            
            // åˆå§‹åŒ–
            updateParams();
            textFont('Arial');
        }

        function draw() {
            background(255);
            cursor(ARROW);
            
            handleInteractions();

            // 1. ç”»èƒŒæ™¯ç¯å¢ƒï¼ˆæ¡Œé¢ä¸åœ°ä¸‹ï¼‰
            drawEnvironment();

            // 2. è®¡ç®—é•œå­å‡ ä½•
            // è§’åº¦è¯´æ˜ï¼šp5åæ ‡ç³»Yè½´å‘ä¸‹ã€‚
            // é¢˜æ„ï¼šé•œå­ä»æ¡Œé¢(Pivot)å‘å³ä¸Šæ–¹å»¶ä¼¸ã€‚
            // 45åº¦è§’æ„å‘³ç€å‘é‡ (cos(-45), sin(-45)) -> (0.707, -0.707)
            let rad = radians(-mirror.angle);
            let mTipX = mirror.pivotX + mirror.length * cos(rad);
            let mTipY = mirror.pivotY + mirror.length * sin(rad);

            // 3. ç”»é•œå­
            drawMirror(mirror.pivotX, mirror.pivotY, mTipX, mTipY);

            // 4. ç”»å®ç‰©èœ¡çƒ›
            drawCandle(candle.x, candle.y, candle.h, false);

            // 5. è®¡ç®—åƒçš„ä½ç½® (å…³äºé•œå­ç›´çº¿çš„å¯¹ç§°ç‚¹)
            // é•œå­ç›´çº¿ç”± Pivot å’Œ è§’åº¦ å†³å®š
            let Top = createVector(candle.x, candle.y - candle.h); // èœ¡çƒ›å¤´A
            let Bot = createVector(candle.x, candle.y);            // èœ¡çƒ›åº•B
            
            let Top_Prime = reflectPoint(Top, mirror.pivotX, mirror.pivotY, rad);
            let Bot_Prime = reflectPoint(Bot, mirror.pivotX, mirror.pivotY, rad);

            // 6. ç”»åƒ (å¦‚æœå¼€å¯)
            if (chkImage.checked()) {
                drawGhostCandle(Top_Prime, Bot_Prime);
                
                if (chkSymmetry.checked()) {
                    drawSymmetryLine(Top, Top_Prime);
                    drawSymmetryLine(Bot, Bot_Prime);
                }
            }

            // 7. ç”»å…‰è·¯ (å¦‚æœå¼€å¯)
            // é€»è¾‘ï¼šè¿æ¥ åƒç‚¹(Top_Prime) å’Œ çœ¼ç›(Eye) -> äº¤ç‚¹å³ä¸ºå…¥å°„ç‚¹
            drawEye(eye.x, eye.y);
            
            if (chkRay.checked()) {
                // è®¡ç®—å…¥å°„ç‚¹
                // ç›´çº¿1: Top_Prime -> Eye
                // ç›´çº¿2: Mirror Start -> Mirror End
                let intersect = getLineIntersection(
                    Top_Prime.x, Top_Prime.y, eye.x, eye.y,
                    mirror.pivotX, mirror.pivotY, mTipX, mTipY
                );

                if (intersect) {
                    // æ£€æŸ¥äº¤ç‚¹æ˜¯å¦åœ¨é•œå­èŒƒå›´å†…
                    let dToPivot = dist(intersect.x, intersect.y, mirror.pivotX, mirror.pivotY);
                    
                    if (dToPivot <= mirror.length && dToPivot >= 0 && intersect.x >= mirror.pivotX) {
                        // æœ‰æ•ˆåå°„
                        // A. è™šå…‰çº¿ (A' -> O)
                        stroke(255, 100, 100);
                        drawingContext.setLineDash([5, 5]);
                        line(Top_Prime.x, Top_Prime.y, intersect.x, intersect.y);
                        
                        // B. å®åå°„å…‰çº¿ (O -> Eye)
                        drawingContext.setLineDash([]);
                        stroke(255, 0, 0);
                        strokeWeight(2);
                        line(intersect.x, intersect.y, eye.x, eye.y);
                        drawArrowMid(intersect.x, intersect.y, eye.x, eye.y); // ç®­å¤´
                        
                        // C. å®å…¥å°„å…‰çº¿ (A -> O)
                        line(Top.x, Top.y, intersect.x, intersect.y);
                        drawArrowMid(Top.x, Top.y, intersect.x, intersect.y); // ç®­å¤´

                        // D. æ ‡æ³¨å…¥å°„ç‚¹O
                        fill(200, 0, 0);
                        noStroke();
                        circle(intersect.x, intersect.y, 5);
                        text("O", intersect.x+8, intersect.y+5);

                        // E. æ³•çº¿
                        if (chkNormal.checked()) {
                            drawNormal(intersect, mirror.angle);
                        }

                    } else {
                        // è§†çº¿æ²¡æœ‰æ‰“åœ¨é•œå­ä¸Š
                        fill(150);
                        noStroke();
                        text("è§†çº¿æœªè½åœ¨é•œé¢ä¸Š", eye.x, eye.y + 35);
                    }
                }
            }
        }

        // --- æ ¸å¿ƒç»˜å›¾å‡½æ•° ---

        function drawEnvironment() {
            // æ¡Œé¢çº¿
            stroke(80);
            strokeWeight(4);
            line(0, TABLE_Y, CW, TABLE_Y);
            
            // åœ°ä¸‹åŒºåŸŸ (æµ…ç°)
            noStroke();
            fill(245, 245, 245);
            rect(0, TABLE_Y+2, CW, CH - TABLE_Y);

            // æ ‡æ³¨
            fill(100);
            textSize(14);
            textAlign(RIGHT);
            text("æ¡Œé¢ (Table)", CW - 20, TABLE_Y - 10);
            text("åœ°ä¸‹/é•œåç©ºé—´", CW - 20, TABLE_Y + 25);
        }

        function drawMirror(x1, y1, x2, y2) {
            push();
            // ç»ç’ƒæœ¬ä½“
            stroke(100, 149, 237, 100); // åŠé€æ˜è“
            strokeWeight(8);
            line(x1, y1, x2, y2);
            
            // åå°„é¢ (æ•°å­¦çº¿)
            stroke(50, 50, 150);
            strokeWeight(2);
            line(x1, y1, x2, y2);
            
            // æ¢³å­çŠ¶é˜´å½± (è¡¨ç¤ºèƒŒé¢)
            // éœ€è¦è®¡ç®—æ³•çº¿æ–¹å‘
            let angle = atan2(y2-y1, x2-x1);
            stroke(100);
            strokeWeight(1);
            let len = dist(x1,y1,x2,y2);
            translate(x1, y1);
            rotate(angle);
            for(let i=0; i<len; i+=10) {
                line(i, 0, i+5, 5); // è¿™é‡Œçš„5æ˜¯ç›¸å¯¹äºé•œå­åæ ‡ç³»çš„"ä¸‹æ–¹"
            }
            pop();
        }

        function drawCandle(x, y, h, isVirtual) {
            push();
            translate(x, y);
            if (isVirtual) {
                // è™šåƒæ ·å¼
                stroke(150);
                drawingContext.setLineDash([4, 4]);
                fill(200, 200, 200, 50);
            } else {
                // å®ç‰©æ ·å¼
                stroke(50);
                fill(231, 76, 60);
            }

            // èº«ä½“
            rectMode(CORNER);
            rect(-10, -h, 20, h);
            // çƒ›èŠ¯
            line(0, -h, 0, -h - 6);
            
            // ç«ç„°
            if (!isVirtual) {
                fill(255, 165, 0); noStroke();
                ellipse(0, -h - 12, 10, 18);
            } else {
                fill(180, 180, 180, 100); noStroke();
                ellipse(0, -h - 12, 10, 18);
            }

            // æ ‡æ³¨
            fill(50); noStroke(); textAlign(CENTER);
            if(!isVirtual) {
                drawingContext.setLineDash([]);
                text("A", 0, -h - 25);
                text("B", 0, 15);
            }
            pop();
        }

        function drawGhostCandle(TopP, BotP) {
            // è™šåƒå¯èƒ½æ—‹è½¬ï¼Œæ‰€ä»¥åŸºäº Top' å’Œ Bot' ä¸¤ä¸ªç‚¹æ¥ç”»
            push();
            
            // 1. è¿çº¿ A'B' (è™šçº¿)
            stroke(100);
            strokeWeight(2);
            drawingContext.setLineDash([5, 5]);
            line(BotP.x, BotP.y, TopP.x, TopP.y);
            
            // 2. ç»˜åˆ¶èº«ä½“çŸ©å½¢
            // è®¡ç®—æ–¹å‘å‘é‡ B' -> A'
            let dir = p5.Vector.sub(TopP, BotP);
            let h = dir.mag();
            let angle = dir.heading(); // æ—‹è½¬è§’åº¦
            
            translate(BotP.x, BotP.y);
            rotate(angle + PI/2); // p5 0åº¦æ˜¯å³ï¼ŒçŸ©å½¢é»˜è®¤ç«–ç›´å‘ä¸Šéœ€è¦è°ƒæ•´
            
            // è¿™é‡Œçš„å˜æ¢ç¨å¤æ‚ï¼Œæ”¹ç”¨æ›´ç®€å•çš„æ–¹æ³•ï¼š
            // ç›´æ¥åœ¨ B' å¤„å»ºç«‹å±€éƒ¨åæ ‡ç³»ï¼ŒXè½´æ²¿ç€ B'->A'
            rotate(-PI/2); // æŠµæ¶ˆåˆšæ‰çš„ +PI/2
            
            // ç°åœ¨ Xè½´æ°´å¹³å‘å³ã€‚æˆ‘ä»¬è¦è®© -Y è½´æŒ‡å‘ A' ?
            // ä¸ï¼Œç›´æ¥ç”¨ dir.heading() æ—‹è½¬åæ ‡ç³»ï¼Œä½¿ Xè½´ = B'->A'
            // å®é™…ä¸Š p5 rect é»˜è®¤å‘ä¸‹ã€‚
            // è®©æˆ‘ä»¬é‡ç½®å˜æ¢
            pop(); 
            
            push();
            translate(BotP.x, BotP.y);
            rotate(angle); // ç°åœ¨ Xè½´æŒ‡å‘ A'
            
            fill(200, 200, 200, 80);
            stroke(150);
            drawingContext.setLineDash([4, 4]);
            
            // ç”»èœ¡çƒ›èº«ä½“ (å®½20, é«˜h)
            // åœ¨å±€éƒ¨åæ ‡ç³»ä¸­ï¼ŒA' åœ¨ (h, 0)ï¼Œ B' åœ¨ (0,0)
            // èº«ä½“åº”è¯¥åœ¨è½´çº¿ä¸¤ä¾§ï¼Œå³ y ä» -10 åˆ° 10
            rect(0, -10, h, 20); 
            
            // ç”»ç«ç„° (åœ¨ A' ç«¯ï¼Œå³ x=h)
            noStroke();
            fill(180, 180, 180, 150);
            ellipse(h + 10, 0, 18, 10);
            
            pop();

            // æ ‡æ³¨
            fill(80); noStroke(); textSize(14);
            text("A'", TopP.x + 10, TopP.y);
            text("B'", BotP.x + 10, BotP.y);
        }

        function drawEye(x, y) {
            push();
            translate(x, y);
            if (dist(mouseX, mouseY, x, y) < 30) {
                scale(1.1); cursor(MOVE);
            }
            fill(255); stroke(0); strokeWeight(2);
            
            beginShape();
            vertex(-15, 0);
            bezierVertex(-5, -10, 5, -10, 15, 0);
            bezierVertex(5, 10, -5, 10, -15, 0);
            endShape(CLOSE);
            
            fill(0); circle(0,0,8);
            noStroke(); text("ğŸ‘ï¸", -20, -10);
            pop();
        }

        function drawSymmetryLine(p1, p2) {
            push();
            stroke(0, 150, 255, 80);
            strokeWeight(1);
            drawingContext.setLineDash([2, 4]);
            line(p1.x, p1.y, p2.x, p2.y);
            
            // ç”»å‚ç›´ç¬¦å· (è¿‘ä¼¼åœ¨ä¸­é—´)
            let mid = p5.Vector.add(p1, p2).div(2);
            fill(0, 150, 255); noStroke();
            circle(mid.x, mid.y, 3);
            pop();
        }

        function drawNormal(p, angleDeg) {
            // æ³•çº¿å‚ç›´äºé•œé¢ã€‚é•œé¢è§’åº¦ angleDegã€‚æ³•çº¿è§’åº¦ angleDeg+90
            let rad = radians(-angleDeg - 90);
            push();
            translate(p.x, p.y);
            stroke(100); strokeWeight(1); drawingContext.setLineDash([3,3]);
            let len = 40;
            line(0, 0, len*cos(rad), len*sin(rad));
            line(0, 0, -len*cos(rad), -len*sin(rad));
            pop();
        }

        function drawArrowMid(x1, y1, x2, y2) {
            push();
            let midX = (x1+x2)/2;
            let midY = (y1+y2)/2;
            let angle = atan2(y2-y1, x2-x1);
            translate(midX, midY);
            rotate(angle);
            fill(255, 0, 0); noStroke();
            triangle(-6, 4, 6, 0, -6, -4);
            pop();
        }

        // --- æ•°å­¦è®¡ç®—å‡½æ•° ---

        function reflectPoint(p, pivX, pivY, angRad) {
            // 1. ç§»åˆ°æ¢è½´åŸç‚¹
            let x = p.x - pivX;
            let y = p.y - pivY;
            
            // 2. æ—‹è½¬åæ ‡ç³»ï¼Œä½¿é•œå­å˜æ°´å¹³ (Xè½´)
            // é•œå­è§’åº¦æ˜¯ angRad (è´Ÿå€¼)ã€‚æ—‹è½¬ -angRad å˜æ°´å¹³ã€‚
            let x2 = x * cos(-angRad) - y * sin(-angRad);
            let y2 = x * sin(-angRad) + y * cos(-angRad);
            
            // 3. å…³äºXè½´ç¿»è½¬ (y -> -y)
            y2 = -y2;
            
            // 4. æ—‹è½¬å›æ¥
            let x3 = x2 * cos(angRad) - y2 * sin(angRad);
            let y3 = x2 * sin(angRad) + y2 * cos(angRad);
            
            // 5. ç§»å›åŸä½
            return createVector(x3 + pivX, y3 + pivY);
        }

        function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            let denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom == 0) return null;
            let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            // ub ç”¨äºåˆ¤æ–­çº¿æ®µèŒƒå›´ï¼Œè¿™é‡Œåªå…³å¿ƒæ— é™ç›´çº¿äº¤ç‚¹
            return createVector(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1));
        }

        // --- äº¤äº’å¤„ç† ---

        function updateParams() {
            mirror.angle = parseInt(angleSlider.value());
            candle.x = parseInt(posSlider.value());
            
            valAngleSpan.html(mirror.angle + "Â°");
            valPosSpan.html(candle.x);
        }

        function handleInteractions() {
            if (mouseIsPressed) {
                // æ‹–æ‹½èœ¡çƒ›
                if (!eye.isDragging && (candle.isDragging || dist(mouseX, mouseY, candle.x, candle.y - candle.h/2) < 40)) {
                    candle.isDragging = true;
                    candle.x = constrain(mouseX, 50, mirror.pivotX - 20); // é™åˆ¶åœ¨é•œå­å·¦ä¾§
                    posSlider.value(candle.x);
                    updateParams();
                }
                // æ‹–æ‹½çœ¼ç›
                else if (!candle.isDragging && (eye.isDragging || dist(mouseX, mouseY, eye.x, eye.y) < 30)) {
                    eye.isDragging = true;
                    eye.x = mouseX;
                    eye.y = mouseY;
                }
            } else {
                candle.isDragging = false;
                eye.isDragging = false;
            }
        }

        function resetSim() {
            angleSlider.value(45);
            posSlider.value(250);
            eye.x = 650;
            eye.y = 150;
            updateParams();
        }
    </script>
</body>
</html>
```